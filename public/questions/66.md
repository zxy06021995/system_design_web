# Q66：Design Serverless Architecture System（面试复述版）

## 1. 三句话题目本质
1. Serverless 平台核心是按事件触发函数执行，用户不管理服务器。  
2. 难点是冷启动、突发流量、租户隔离和计费准确性。  
3. 面试要讲清控制面、执行面、弹性策略和故障恢复。  

## 2. 真实场景故事
电商大促期间营销函数在 1 分钟内触发 200 万次。旧平台冷启动过高导致超时。  
改造后通过预热池、队列削峰、并发配额和分层镜像缓存，P95 延迟下降 60%。  

## 3. 术语白话表（>=10）
|术语|白话解释|面试可复述|
|---|---|---|
|FaaS|函数即服务|上传函数就能跑|
|Cold Start|冷启动|容器首次拉起慢|
|Warm Pool|预热池|提前准备执行环境|
|Invoker|执行器|真正拉起函数|
|Event Bus|事件总线|触发函数执行|
|Concurrency|并发|同时间执行数量|
|Throttle|限流|超配额拒绝或排队|
|Sandbox|沙箱隔离|租户安全边界|
|Outbox|事务消息表|可靠发事件|
|DLQ|死信队列|失败任务隔离|
|Hot/Cold Image|镜像冷热层|热镜像驻留节点|
|Billing Meter|计费计量|按执行时长计费|

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能
- 创建函数、发布版本、配置触发器（HTTP/Queue/Cron）。  
- 设置并发限制、超时、内存规格。  
- 查看执行日志、失败重试、死信回放。  
### 4.2 非功能
- 平台可用性 >= 99.95%。  
- HTTP 触发 P95 < 300ms（不含业务耗时）。  
- 计费误差 < 0.1%。  
### 4.3 不做
- 不做长任务编排（交给工作流系统）。  
- 不做 GPU 推理专用调度。  
### 4.4 SLO
- `invoke_latency_p95 < 300ms`
- `cold_start_ratio < 5%`
- `invoke_success_rate > 99.9%`

## 5. 容量估算（数字推导）
- 峰值请求 80k/s，平均执行 120ms。  
- 理论并发约 `80k * 0.12 = 9600`。按 2 倍冗余配 20k 并发槽。  
- 日执行 30 亿次，单日志 1KB，热日志日增约 3TB。  
- 热日志 3 天，冷归档 90 天。  

## 6. 架构（简版+完整版）
### 6.1 简版
```text
API -> Control Plane -> Event Queue -> Invoker -> Runtime Sandbox
```
### 6.2 完整版
```text
Client -> Gateway -> Function API
       -> Metadata DB + Version Store
       -> Tx + Outbox -> MQ(invoke.event)
       -> Scheduler(tenant quota, priority)
       -> Invoker Nodes (warm pool, image cache)
       -> Runtime Sandbox
       -> Metrics/Logs -> Billing Meter -> Invoice
```

## 7. API设计（请求/响应/错误码/幂等）
`POST /api/v1/functions`
```json
{"name":"coupon-calc","runtime":"java21","memoryMb":512,"timeoutSec":30}
```
Response:
```json
{"functionId":"fn_991","status":"ACTIVE"}
```

`POST /api/v1/functions/{id}/invoke`
```json
{"payload":{"userId":"u1","amount":120}}
```
Headers: `Idempotency-Key: inv-fn_991-001`
Response:
```json
{"requestId":"req_11","accepted":true}
```
错误码：`FNS_429_CONCURRENCY_LIMIT`、`FNS_503_INVOKER_BUSY`、`FNS_409_DUP_REQ`。  

## 8. 数据模型（实体/索引/分片）
- `function_def(function_id, tenant_id, runtime, memory_mb, timeout_sec, status)`  
- `function_version(version_id, function_id, image_uri, digest, created_at)`  
- `invoke_request(req_id, function_id, idem_key, state, duration_ms, error)`  
- `billing_usage(tenant_id, req_id, gb_sec, ts)`  
- 索引：`invoke_request(function_id, state, created_at)`。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：写 invoke_request + outbox，异步调度到 invoker。  
2. 高峰：先配额限流，再入队削峰，低优先级延迟。  
3. 故障：invoker 失败自动重试，超限入 DLQ 回放。  

## 10. 一致性与事务边界
- `invoke_request + outbox` 强一致提交。  
- 执行结果异步回写，最终一致。  
- 计费按 requestId 去重写账本。  

## 11. 可用性与容错（含RTO/RPO）
- 控制面多副本，执行面跨 AZ。  
- RTO 15 分钟，RPO 0（请求记录不可丢）。  
- 队列堆积时自动扩 invoker。  

## 12. 可观测性（指标+阈值+处置动作）
- `cold_start_ratio > 8%`：扩 warm pool。  
- `invoke_queue_lag > 5s`：扩执行节点并降级低优先。  
- `error_rate > 1%`：回滚最近版本。  
- `billing_drift > 0.1%`：启动计量对账。  

## 13. 安全与合规
- 沙箱网络隔离、只读根文件系统。  
- 租户密钥 KMS 托管。  
- 调用日志脱敏，审计保留 180 天。  

## 14. 成本与取舍
- 预热池降低延迟但增加闲置成本。  
- 高频函数驻热，低频函数按需冷启。  
- CDN 仅用于控制台静态资源，不参与执行链路。  

## 15. Java关键代码（>=5段）
```java
public InvokeResp invoke(InvokeCmd c){
  String key = c.functionId()+":"+c.idemKey();
  if(idemRepo.exists(key)) return idemRepo.replay(key);
  tx.begin();
  try{
    var req = reqRepo.insert(c);
    outbox.append("INVOKE_REQ", req.id(), req.toJson());
    idemRepo.save(key, req.id());
    tx.commit();
    return new InvokeResp(req.id(), true);
  }catch(Exception e){ tx.rollback(); throw e; }
}
```
```java
public void dispatch(Event e){
  if(!quota.allow(e.tenantId())) throw new BizException("FNS_429_CONCURRENCY_LIMIT");
  scheduler.enqueue(e);
}
```
```java
public RuntimeSlot allocate(String fnId){
  var warm = warmPool.borrow(fnId);
  if(warm != null) return warm;
  return invoker.startCold(fnId);
}
```
```java
public void retryOrDlq(Event e, int n){
  if(n>=5){ mq.send("invoke.dlq", e.id(), "max_retry"); return; }
  mq.sendDelay("invoke.retry", e.id(), (1L<<n)*500);
}
```
```java
public void meter(String reqId, long memoryMb, long durationMs){
  double gbSec = (memoryMb/1024.0) * (durationMs/1000.0);
  billingRepo.upsert(reqId, gbSec);
}
```

## 16. 前端功能代码（React JS >=2段，仅API协作）
```javascript
import { useState } from "react";
export function InvokePanel({ functionId }) {
  const [state,setState]=useState("idle");
  const invoke = async (payload) => {
    setState("loading");
    const resp = await fetch(`/api/v1/functions/${functionId}/invoke`, {
      method:"POST",
      headers:{ "Content-Type":"application/json", "Idempotency-Key":`k-${Date.now()}` },
      body: JSON.stringify({ payload })
    });
    setState(resp.ok ? "done" : "error");
  };
  return null;
}
```
```javascript
import { useEffect,useState } from "react";
export function FunctionHealth() {
  const [tip,setTip]=useState("");
  useEffect(() => {
    let t=null;
    const poll = async () => {
      const r = await fetch("/api/v1/functions/metrics");
      if(!r.ok) setTip("监控暂不可用");
      else {
        const m = await r.json();
        if(m.coldStartRatio > 0.08) setTip("高峰中，已启用预热扩容");
      }
      t=setTimeout(poll,4000);
    };
    poll(); return ()=>clearTimeout(t);
  }, []);
  return null;
}
```

## 17. 测试策略
- 单测：幂等、限流、计费。  
- 集成：创建->调用->回写->计费。  
- 压测：80k/s 触发。  
- 故障：invoker 宕机、队列延迟、镜像拉取失败。  

## 18. 丰富例子（>=10）
1. 冷门函数首次调用冷启动。  
2. 热函数预热命中。  
3. 租户并发超限被 429。  
4. 触发器重复事件不重复计费。  
5. 版本回滚后错误率恢复。  
6. 队列积压触发扩容。  
7. DLQ 回放成功。  
8. 镜像缓存失效重新拉取。  
9. 计费对账发现漂移并修正。  
10. 控制台高峰提示降级。  

## 19. 面试追问+可复述回答
- 问：冷启动怎么优化？答：预热池+镜像缓存+最小运行时。  
- 问：为什么要 outbox？答：保证请求记录与事件投递一致。  
- 问：如何保证不重复计费？答：requestId 唯一账本 upsert。  

## 20. 新手学习路线
1. 控制面/执行面分离。  
2. 事件驱动执行。  
3. 冷启动与弹性策略。  

## 21. 上场前Checklist
- [ ] 能解释冷启动。  
- [ ] 能画触发链路。  
- [ ] 能讲配额与限流。  
- [ ] 能讲计费一致性。  
- [ ] 能给阈值与动作。  

## 22. 与母题差异（Q62）
- 共性：资源调度、弹性、隔离。  
- 差异：本题是函数级短任务调度，强调冷启动与计费。  
- 新增知识：warm pool、invoke 幂等、按 GB-sec 计费、DLQ 回放、触发器治理。  
- 话术：母题偏容器编排，本题偏事件驱动 FaaS 平台。  

## 自审评分
- 完整性20/20 易懂性19/20 面试可讲19/20 技术深度19/20 工程落地19/20  
总分：96/100（通过）
