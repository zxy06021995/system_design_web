# Q23：Uber 地理位置服务设计（95分面试版）

## 1. 三句话题目本质
1. 这题不是“显示地图点位”，而是“在海量实时位置流里，几百毫秒内找对司机并派单成功”。  
2. 你要解决三件事：司机位置要新鲜、附近召回要快、派单状态机要稳。  
3. 面试高分关键是讲清 `Geohash/S2` 空间索引、ETA 排序、超时重试编排、以及高峰故障时如何降级。  

## 2. 一个真实场景故事
周五晚 18:30，机场下雨，网约车需求暴涨：
- 3 分钟内下单请求从每秒 8,000 飙到 45,000。
- 附近司机很多，但道路拥堵，直线距离近不代表到得快。
- 司机手机网络时好时坏，有些位置 8 秒才更新一次。

用户只关心两件事：
- “多久有车接我？”
- “预计多久到？”

所以系统目标不是“数学上最近”，而是“业务上最优匹配”：最快接单 + 最短 ETA + 最高成功率。

## 3. 术语白话表（至少 10 项）
| 术语 | 白话解释 | 面试可直接说法 |
|---|---|---|
| Geohash | 把经纬度编码成网格字符串 | “先按格子找人，不全城扫” |
| S2 Cell | Google 的球面网格系统 | “比普通 geohash 更适合球面距离” |
| Candidate Recall | 候选召回 | “先找一批可能司机” |
| ETA | 预计到达时间 | “看路况后的时间，不是直线距离” |
| Dispatch | 派单 | “给司机发单，等确认，超时再换人” |
| Offer | 派单邀约 | “系统发给司机的抢单机会” |
| CAS | Compare-And-Set | “原子更新，防止一单分给两人” |
| Surge Pricing | 动态加价 | “供不应求时调价平衡市场” |
| Map Matching | 轨迹贴路 | “把漂移 GPS 点修正到道路上” |
| Rebalance | 司机再平衡 | “把空闲司机引导到高需求区” |
| Stale Location | 过期位置 | “超过阈值没更新的位置不能用” |
| Dead Letter Queue | 死信队列 | “重试还失败的任务先隔离人工排查” |
| Hot Zone | 热点区域 | “机场、商圈、演唱会出口等高需求区” |
| Dispatch SLA | 派单时延目标 | “例如 300ms 内完成候选排序” |
| Acceptance Rate | 接单率 | “司机收到 offer 后愿意接的比例” |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 司机每 2~5 秒上报位置、速度、朝向。
- 乘客下单时查询附近司机，并估算 ETA。
- 派单流程：候选召回 -> 排序 -> 发 offer -> 超时重试 -> 成功指派。
- 司机可接单/拒单/超时无响应。
- 支持动态加价（surge）和热点再平衡。

### 4.2 非功能需求（SLO 示例）
- 附近司机查询延迟：`P95 <= 120ms`。
- 派单决策延迟（不含司机响应时间）：`P95 <= 300ms`。
- 定位写入可用性：`>= 99.95%`。
- 派单成功率（首轮+重试）：`>= 92%`（不同城市可分层）。
- 全链路可用性：`>= 99.95%`。

### 4.3 Out of Scope（首版不做）
- 不自研完整地图引擎（路线规划先接第三方地图服务）。
- 不做跨城统一派单（按城市分区隔离）。
- 不做拼车复杂路径优化（可在后续演进）。

## 5. 容量估算（含数字推导）
### 5.1 假设
- 活跃司机：`2,400,000`
- 位置上报间隔：平均 `3 秒/次`
- 峰值打车请求：`60,000 req/s`
- 单次召回候选司机数：`50`
- 每单平均尝试 offer 轮数：`1.8`

### 5.2 位置写入压力
- 位置写入 QPS：`2,400,000 / 3 ≈ 800,000 writes/s`
- 峰值按 1.5 倍：`~1,200,000 writes/s`

### 5.3 派单计算压力
- 候选评估 QPS：`60,000 * 50 = 3,000,000 score ops/s`
- offer 操作 QPS：`60,000 * 1.8 = 108,000 offer ops/s`

### 5.4 关键结论
- 位置存储必须内存化（Redis/内存索引），磁盘库做异步持久。
- 召回必须“先小范围网格、再扩圈”，不能全量距离计算。
- 派单编排必须异步事件化，不能全靠同步 RPC 串行。

## 6. 架构（简版 + 完整版）
### 6.1 简版
```text
司机上报位置 -> 位置服务 -> 空间索引
乘客下单 -> 候选召回 -> ETA排序 -> 派单编排 -> 订单服务
```

### 6.2 完整版
```text
[Driver App]
  -> [Location Gateway]
  -> [Location Ingest Service] -> [Kafka Location Topic]
  -> [Location Processor: 去抖/去重/贴路]
  -> [Geo Index Cluster (Redis + Geohash/S2)]

[Rider App]
  -> [Dispatch API]
  -> [Candidate Recall Service]
  -> [ETA Service (Map API + Cache)]
  -> [Ranking Service]
  -> [Dispatch Orchestrator]
  -> [Offer Service] -> [Driver Push Channel]
  -> [Order Service]

[Pricing Service] [Fraud Service] [Observability]
```

### 6.3 组件职责一句话
- Location Ingest：吃下高频定位流，先保证不丢。
- Geo Index：把“附近检索”做成毫秒级。
- ETA Service：把“近”转换成“多久到”。
- Dispatch Orchestrator：控制派单状态机和重试节奏。

## 7. API 设计（含请求/响应样例）
### 7.1 司机上报位置
`POST /api/v1/driver/location`

Request:
```json
{
  "driverId": 200145,
  "cityId": 310000,
  "lat": 31.23041,
  "lng": 121.47370,
  "speedKmh": 36.4,
  "heading": 120,
  "clientTs": 1771900000123,
  "idempotencyKey": "loc_200145_1771900000123"
}
```

Response:
```json
{
  "accepted": true,
  "serverTs": 1771900000456
}
```

### 7.2 乘客创建打车请求
`POST /api/v1/dispatch/orders`

Request:
```json
{
  "riderId": 9910231,
  "cityId": 310000,
  "pickupLat": 31.22990,
  "pickupLng": 121.47520,
  "dropoffLat": 31.21010,
  "dropoffLng": 121.43520,
  "clientReqId": "req_abc_1001"
}
```

Response:
```json
{
  "orderId": 88000123,
  "status": "MATCHING",
  "estimatedAssignSec": 8
}
```

### 7.3 查询派单状态
`GET /api/v1/dispatch/orders/{orderId}`

Response:
```json
{
  "orderId": 88000123,
  "status": "ASSIGNED",
  "driverId": 200145,
  "etaSec": 320
}
```

### 7.4 司机响应 offer
`POST /api/v1/dispatch/offers/{offerId}/response`

Request:
```json
{
  "driverId": 200145,
  "action": "ACCEPT"
}
```

### 7.5 错误码语义
- `409_ORDER_STATE_CONFLICT`：订单已被其他司机抢到。
- `422_STALE_LOCATION`：司机位置超时，不参与派单。
- `429_DISPATCH_THROTTLED`：城市级限流生效。

## 8. 数据模型（核心表/索引）
### 8.1 司机在线状态表
```sql
CREATE TABLE driver_presence (
  driver_id BIGINT PRIMARY KEY,
  city_id INT NOT NULL,
  online_status VARCHAR(16) NOT NULL, -- ONLINE/OFFLINE
  availability VARCHAR(16) NOT NULL,  -- IDLE/BUSY
  lat DOUBLE NOT NULL,
  lng DOUBLE NOT NULL,
  geocell VARCHAR(16) NOT NULL,
  last_update_ms BIGINT NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_driver_city_cell ON driver_presence(city_id, geocell);
CREATE INDEX idx_driver_city_avail ON driver_presence(city_id, availability, updated_at DESC);
```

### 8.2 派单订单表
```sql
CREATE TABLE dispatch_order (
  order_id BIGINT PRIMARY KEY,
  rider_id BIGINT NOT NULL,
  city_id INT NOT NULL,
  pickup_lat DOUBLE NOT NULL,
  pickup_lng DOUBLE NOT NULL,
  dropoff_lat DOUBLE,
  dropoff_lng DOUBLE,
  status VARCHAR(16) NOT NULL, -- CREATED/MATCHING/ASSIGNED/CANCELED/TIMEOUT
  assigned_driver_id BIGINT,
  version BIGINT NOT NULL DEFAULT 0,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_dispatch_city_status ON dispatch_order(city_id, status, created_at DESC);
```

### 8.3 Offer 表
```sql
CREATE TABLE dispatch_offer (
  offer_id BIGINT PRIMARY KEY,
  order_id BIGINT NOT NULL,
  driver_id BIGINT NOT NULL,
  eta_sec INT NOT NULL,
  rank_score DOUBLE NOT NULL,
  state VARCHAR(16) NOT NULL, -- PENDING/ACCEPTED/REJECTED/TIMEOUT
  expire_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL,
  UNIQUE(order_id, driver_id)
);
CREATE INDEX idx_offer_order_state ON dispatch_offer(order_id, state, created_at DESC);
```

### 8.4 实时索引（Redis 结构示例）
- `GEO:city:{cityId}`：司机经纬度（GEOADD）。
- `HASH:driver:{driverId}`：司机状态（在线/空闲/最后更新时间）。
- `ZSET:hotzone:{zoneId}`：需求强度评分（用于再平衡）。

## 9. 核心流程（至少 3 条）
### 9.1 正常下单流程
1. 乘客创建订单，状态 `CREATED -> MATCHING`。
2. Candidate Recall 按 geocell 先召回最近一圈司机。
3. ETA + 接单概率 + 司机评分进行排序。
4. Orchestrator 给 TopK 司机按策略发 offer（串行或小批并行）。
5. 某司机接受后 CAS 抢占成功，状态 `ASSIGNED`。

### 9.2 高峰流程（机场雨天）
1. 热区下单 QPS 突增，首轮接单率下降。
2. 系统触发 surge，动态加价提升司机响应意愿。
3. 扩大召回半径，降低最小评分阈值。
4. 再平衡服务把周边空闲司机引导进热区。

### 9.3 故障恢复流程（地图 ETA 服务超时）
1. ETA 外部依赖响应超时率升高。
2. 系统降级到“距离+历史均速”估算 ETA。
3. 关闭复杂特征，优先保障派单时延。
4. 依赖恢复后自动切回精算 ETA。

### 9.4 司机无响应流程
1. offer 超时（例如 6 秒）未接。
2. 标记 `TIMEOUT`，自动选下一候选。
3. 超过最大尝试轮次后状态置 `TIMEOUT` 并通知乘客重试。

## 10. 一致性与事务边界
### 10.1 必须强一致的点
- 一个订单同一时刻只能绑定一个司机。
- 订单状态机不允许逆向跳转（ASSIGNED 不能回 MATCHING）。

### 10.2 可最终一致的点
- 热区统计、司机画像特征、运营报表可分钟级延迟。
- 轨迹分析可离线修正，不阻塞实时派单。

### 10.3 事务设计
- 下单与派单事件投递采用 Outbox，避免“双写不一致”。
- 抢单成功使用 CAS：`WHERE status='MATCHING' AND version=?`。
- offer 去重键：`orderId + driverId`，避免重复推送。

## 11. 可用性与容错
### 11.1 关键失败模式
- 位置流堆积，司机位置不新鲜。
- ETA 依赖超时，派单决策变慢。
- 推送通道抖动，司机收不到 offer。
- 城市级热点把某机房打爆。

### 11.2 容错策略
- 城市分区隔离：`cityId` 级别隔离队列和索引。
- 多级降级：精算 ETA -> 粗算 ETA -> 最近可用司机策略。
- 推送兜底：Push 失败后 SMS/站内 fallback（关键市场）。
- 队列削峰：限流非核心请求，优先保障派单主链路。

### 11.3 RTO / RPO
- 城市级核心服务 RTO：`<= 10 分钟`
- 订单状态 RPO：`<= 30 秒`
- 统计指标 RPO：`<= 5 分钟`

## 12. 可观测性（指标 + 告警阈值）
### 12.1 位置链路指标
- `location_ingest_qps`
- `location_lag_p95_ms`
- `stale_driver_ratio`

阈值示例：
- `stale_driver_ratio > 8%` 持续 5 分钟 -> P1
- `location_lag_p95_ms > 2000` 持续 5 分钟 -> P1

### 12.2 派单链路指标
- `dispatch_latency_p95_ms`
- `first_offer_accept_rate`
- `dispatch_success_rate_5m`
- `offer_timeout_rate`

阈值示例：
- `dispatch_latency_p95_ms > 300` 持续 10 分钟 -> P1
- `dispatch_success_rate_5m < 92%` 持续 5 分钟 -> P1
- `offer_timeout_rate > 35%` 持续 10 分钟 -> P2

### 12.3 ETA 质量指标
- `eta_error_p50/p95`
- `eta_timeout_rate`

阈值示例：
- `eta_timeout_rate > 5%` 持续 5 分钟 -> P1
- `eta_error_p95 > 180s` 持续 30 分钟 -> P2

## 13. 安全与合规
- 位置上报签名：防伪造坐标和重放攻击。
- 轨迹反作弊：瞬移检测、速度异常检测、重复轨迹检测。
- 隐私保护：司机电话、乘客电话全程号段脱敏/中间号。
- 审计日志：关键操作（封禁、人工改派、赔付）落审计系统。
- 合规策略：地域数据本地化存储（按国家/地区政策）。

## 14. 成本与取舍
### 14.1 成本大头
- 地图 ETA API 成本（外部调用按量计费）。
- 实时索引内存成本。
- 推送通道成本（APNs/FCM/SMS）。

### 14.2 降本策略
- ETA 两阶段：先粗算筛 50 -> 再精算前 10。
- 位置上报动态降频：静止司机 3 秒改 8 秒。
- 热区高精度，冷区低精度网格。
- Push 分层：只给高质量候选发送强提醒。

### 14.3 取舍表达
- 更准 ETA 会提升转化，但也增加 API 成本。
- 更大候选池会提升成功率，但拉高计算和时延。
- 早期先保证“派单快”，后续再追“ETA 极准”。

## 15. Java 关键代码（至少 4 段，点位不同）
### 15.1 位置上报幂等 + 过期丢弃
```java
public class LocationIngestService {
    public void ingest(LocationUpdate req) {
        if (idempotencyRepo.exists(req.getIdempotencyKey())) return;

        DriverPresence current = presenceRepo.find(req.getDriverId());
        if (current != null && req.getClientTs() <= current.getLastUpdateMs()) {
            return; // 老数据直接丢弃，避免位置回退
        }

        presenceRepo.upsert(req.getDriverId(), req.getCityId(), req.getLat(), req.getLng(), req.getClientTs());
        geoIndex.update(req.getCityId(), req.getDriverId(), req.getLat(), req.getLng());
        idempotencyRepo.save(req.getIdempotencyKey(), 60); // 60s TTL
    }
}
```

### 15.2 邻域扩圈召回（先近后远）
```java
public class CandidateRecallService {
    public List<Long> recall(long cityId, double lat, double lng, int targetCount) {
        List<Long> result = new ArrayList<>();
        for (int ring = 0; ring <= 3 && result.size() < targetCount; ring++) {
            List<String> cells = geoCellService.expandRings(lat, lng, ring);
            List<Long> drivers = geoIndex.batchGetIdleDrivers(cityId, cells);
            for (Long driverId : drivers) {
                if (isFresh(driverId)) result.add(driverId);
                if (result.size() >= targetCount) break;
            }
        }
        return result;
    }

    private boolean isFresh(Long driverId) {
        return System.currentTimeMillis() - presenceRepo.lastUpdate(driverId) <= 8000;
    }
}
```

### 15.3 ETA + 接单率综合排序
```java
public class DispatchRankingService {
    public double score(int etaSec, double acceptProb, double driverRating, double surgeFactor) {
        // 分值越大越好：ETA 越短越优，接单概率和评分越高越优
        return (-0.55 * etaSec) + (0.30 * acceptProb * 100) + (0.10 * driverRating * 20) + (0.05 * surgeFactor * 10);
    }
}
```

### 15.4 原子指派（防一单多派）
```java
public class AssignService {
    public boolean assign(long orderId, long driverId) {
        DispatchOrder order = orderRepo.get(orderId);
        if (!"MATCHING".equals(order.getStatus())) return false;

        int updated = orderRepo.casAssign(
            orderId,
            "MATCHING",
            order.getVersion(),
            driverId,
            "ASSIGNED",
            order.getVersion() + 1
        );
        return updated == 1;
    }
}
```

### 15.5 Offer 超时补偿重试
```java
public class OfferTimeoutHandler {
    public void onTimeout(long offerId) {
        DispatchOffer offer = offerRepo.get(offerId);
        if (!"PENDING".equals(offer.getState())) return;

        offerRepo.updateState(offerId, "TIMEOUT");
        boolean done = assignFlow.tryNextCandidate(offer.getOrderId());
        if (!done) {
            orderRepo.updateStatus(offer.getOrderId(), "TIMEOUT");
            notificationService.notifyRiderRetry(offer.getOrderId());
        }
    }
}
```

## 16. 测试策略
### 16.1 单元测试
- 位置幂等与时间戳回退校验。
- 召回扩圈策略（ring0/ring1/ring2）正确性。
- 排序分值在边界条件下稳定性。
- 状态机非法跃迁（ASSIGNED -> MATCHING）必须失败。

### 16.2 集成测试
- 下单 -> 召回 -> 发 offer -> 接单 -> 指派成功全链路。
- ETA 依赖超时时降级路径可工作。
- 推送失败时 fallback 通道触发。

### 16.3 压测
- 位置流：120 万写入/秒。
- 派单：6 万单/秒，候选 50，峰值持续 15 分钟。
- 热区场景：单区域请求 20x 尖刺。

### 16.4 故障演练
- 故障注入 ETA 服务 50% 超时。
- 关闭一个 Geo Index 分片节点。
- 人为制造推送失败率 30% 验证止血策略。

## 17. 丰富例子（至少 10 个）
1. 机场大雨，司机都堵在进场高架，直线近但 ETA 很长。  
2. 司机在地下停车场，GPS 漂移，系统用贴路和去抖平滑轨迹。  
3. 某司机 10 秒没上报位置，被判定 stale，不再参与派单。  
4. 司机连续拒单，系统下调其接单概率权重。  
5. 地图服务超时，系统降级到距离+平均速度估算，仍能派单。  
6. 热点演唱会散场，系统提前将周边司机引导至场馆外。  
7. 乘客重复点击下单，通过 `clientReqId` 幂等避免重复订单。  
8. Offer 发送成功但司机网络差未收到，超时后自动补发给下一候选。  
9. 某城市机房故障，按城市隔离只影响本城，不拖垮全国。  
10. 夜间低峰将位置上报从 3 秒改 8 秒，节约计算和网络成本。  
11. 黑产模拟虚假 GPS 抢单，风控检测“瞬移速度”后封禁账号。  
12. 高峰时系统启用小批并行 offer（3 人并发），降低等待时间。  

## 18. 面试追问 + 可复述回答
### Q1：为什么不能按“最近距离”派单？
可复述：  
“最近距离不等于最快到达，真实道路有红绿灯、单行线、拥堵。应以 ETA 为核心排序。”

### Q2：怎么避免一单分给多个司机？
可复述：  
“订单状态更新用 CAS 原子条件，只有一个请求能把 `MATCHING` 改成 `ASSIGNED`。”

### Q3：位置数据不新鲜怎么办？
可复述：  
“设置 stale 阈值（例如 8 秒），过期司机不参与召回；并监控 stale ratio 告警。”

### Q4：高峰时期派单成功率下降如何止血？
可复述：  
“先开 surge 提升接单意愿，再扩大召回半径、并行小批 offer，最后再平衡司机供给。”

### Q5：ETA 服务挂了怎么办？
可复述：  
“降级为距离估算，优先保障派单时延和成功率，依赖恢复后再切回精算 ETA。”

### Q6：如何判断系统是否健康？
可复述：  
“看 dispatch p95、首轮接单率、派单成功率、stale ratio、ETA 误差和超时率。”

## 19. 新手学习路线
### 第 1 周：空间索引和距离计算
- 学 geohash / S2 概念。
- 做一个“给点找附近点”的 demo。

### 第 2 周：派单状态机
- 实现订单 `CREATED -> MATCHING -> ASSIGNED`。
- 实现 offer 超时和重试。

### 第 3 周：ETA 与排序
- 对接地图 ETA（或 mock 服务）。
- 做简单排序模型并记录命中效果。

### 第 4 周：工程化
- 加幂等、CAS、限流、监控告警。
- 做故障演练并写复盘。
- 练习 10 分钟面试讲解稿。

## 20. 上场前 Checklist
- [ ] 我能用一句话解释“召回”和“排序”的区别。  
- [ ] 我能讲清 geocell 扩圈策略为什么快。  
- [ ] 我能说出订单唯一指派如何用 CAS 保证。  
- [ ] 我能说出至少 3 个派单核心告警阈值。  
- [ ] 我能描述 ETA 依赖故障时的降级链路。  
- [ ] 我能给出 2 个高峰治理手段（surge + 再平衡）。  
- [ ] 我能解释一个真实故障演练的止血与恢复。  

## 21. 30 秒总结
Uber 地理位置服务的核心是：  
“用空间索引快速召回，用 ETA 做业务排序，用状态机保证只分配给一个司机，用降级策略在高峰和故障时仍保持派单成功率。”  
如果你能把这句话展开成容量估算、链路时序、阈值告警、代码点位和取舍逻辑，基本就是面试高分答案。  
