# Q89：Design Cloud Gaming Service（95分面试版）

## 1. 三句话题目本质
1. Design Cloud Gaming Service 的核心是：围绕“云游戏、视频流、低延迟”把业务主链路稳定跑通。  
2. 难点在于高峰、故障和多系统协同时，正确性、延迟和成本同时受压。  
3. 面试高分要点：先讲主链路，再讲异常链路，再给出可落地的取舍与演练方案。  

## 2. 一个真实场景故事
媒体系统核心是转码、分发和体验指标（QoE），难点在带宽和成本平衡。
在业务高峰时，如果没有分层治理，系统会出现放大性故障。  
本题的关键是把策略、架构、执行和恢复闭环串起来。  

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| 核心链路 | 最不能失败的业务路径 | 先讲清核心链路，再讲优化 |
| SLO | 服务质量目标 | 延迟、可用性、错误率要量化 |
| 幂等 | 重复请求结果一致 | 防重复执行和重试冲突 |
| 补偿 | 失败后的修复动作 | 跨服务一致性关键机制 |
| 降级 | 异常时优先保核心功能 | 先保证可用，再恢复完整能力 |
| 可观测性 | 指标日志追踪完整 | 定位故障必须靠数据 |
| 容量估算 | 按峰值做系统规划 | 平均值不能指导架构上限 |
| 回放修复 | 按范围重算或重放数据 | 保证最终收敛与对账一致 |
| 审计留痕 | 关键操作可追溯 | 便于合规与事故复盘 |
| Runbook | 标准故障处置流程 | 减少值班处理不确定性 |
| 云游戏 | 云游戏是该题关键技术点 | 面试要说明云游戏的边界和取舍 |
| 视频流 | 视频流是该题关键技术点 | 面试要说明视频流的边界和取舍 |
| 低延迟 | 低延迟是该题关键技术点 | 面试要说明低延迟的边界和取舍 |
| 边缘计算 | 边缘计算是该题关键技术点 | 面试要说明边缘计算的边界和取舍 |
| 游戏渲染 | 游戏渲染是该题关键技术点 | 面试要说明游戏渲染的边界和取舍 |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 支持 Cloud Gaming Service 的核心业务操作链路。
- 支持状态查询、异常处理、审计和运营控制。
- 支持扩展能力与多场景策略配置。

### 4.2 非功能需求
- 核心接口延迟达标（按场景定义 P95）。
- 可用性 >= 99.95%。
- 关键数据一致性可收敛且可追溯。

### 4.3 不做范围
- 不做与本题主目标无关的重型子系统。
- 不做跨区域强一致全局事务，采用可补偿策略。

## 5. 容量估算（含数字推导）
- 按“日常流量 + 峰值倍数 + 故障冗余”做容量规划。  
- 明确入口QPS、异步积压、存储增长和依赖上限。  
- 给出扩容阈值和降级触发线，避免被动救火。  

## 6. 架构（简版+完整版）
### 6.1 简版
```text
Client -> Gateway -> Core Service -> Storage/Cache -> Async Workers
```

### 6.2 完整版
```text
Client -> API Gateway -> Command Service -> State Store
                          -> Policy/Rule Engine -> Risk/Validation
                          -> Outbox/Event Bus -> Async Consumers
                          -> Query Service -> Search/Index
                          -> Metrics/Logs/Trace -> Alerting/Runbook
```

## 7. API 设计（请求/响应示例）
- `POST /media/upload`
- `GET /media/playback`
- `POST /media/transcode`
- `GET /media/qoe`

## 8. 数据模型（核心表/索引）
- `media_asset(asset_id,status,duration)`
- `transcode_job(job_id,profile,state)`
- `qoe_event(session_id,rebuffer_ms)`

## 9. 核心流程（>=3条）
1. 上传转码
2. CDN分发
3. 弱网码率自适应

## 10. 一致性与事务边界
- 单服务内使用本地事务保证关键状态一致。  
- 跨服务通过 outbox + 幂等消费 + 补偿任务保证最终一致。  
- 所有重试入口都要带幂等键，避免重复副作用。  

## 11. 可用性与容错
- 依赖异常时优先降级核心能力，避免全链路雪崩。  
- 重试采用指数退避+抖动，防止风暴。  
- 死信队列隔离不可自动修复事件，并提供回放工具。  

## 12. 可观测性（指标+阈值）
- `first_frame_p95`
- `rebuffer_ratio`
- `cdn_hit_ratio`
- `transcode_lag`
- 阈值示例：核心延迟超阈值持续 10 分钟触发 P1。  
- 阈值示例：错误率超 0.5% 持续 5 分钟触发 P1。  
- 阈值示例：积压超过基线 2 倍触发 P1。  

## 13. 安全与合规
- 最小权限访问控制 + 全链路审计。  
- 敏感字段脱敏和传输加密。  
- 高风险操作采用灰度/审批和一键回滚。  

## 14. 成本与取舍
- 关键链路优先正确性与恢复能力，长尾链路优先成本。  
- 通过分层存储、分级策略和资源隔离实现成本优化。  
- 明确“延迟-正确性-成本”三角取舍并量化收益。  

## 15. Java 关键代码（>=5段，点位不同）
### 15.1 幂等入口与主事务
```java
public class CloudGamingServiceCommandService {
    public Result submit(Command cmd) {
        String idemKey = cmd.getActorId() + ":" + cmd.getClientReqId();
        if (idempotencyRepo.exists(idemKey)) {
            return idempotencyRepo.replay(idemKey);
        }
        Transaction tx = txManager.begin();
        try {
            long entityId = idGen.nextId();
            mainRepo.insert(entityId, cmd);
            outboxRepo.append("ENTITY_CREATED", entityId);
            idempotencyRepo.save(idemKey, entityId);
            tx.commit();
            return Result.ok(entityId);
        } catch (Exception e) {
            tx.rollback();
            throw e;
        }
    }
}
```

### 15.2 状态机与边界校验
```java
public class CloudGamingServiceStateMachine {
    private static final Map<String, Set<String>> ALLOWED = Map.of(
        "INIT", Set.of("RUNNING", "CANCELED"),
        "RUNNING", Set.of("SUCCESS", "FAILED", "CANCELED"),
        "FAILED", Set.of("RETRYING", "CANCELED"),
        "RETRYING", Set.of("SUCCESS", "FAILED"),
        "SUCCESS", Set.of(),
        "CANCELED", Set.of()
    );

    public void check(String from, String to) {
        if (!ALLOWED.getOrDefault(from, Set.of()).contains(to)) {
            throw new IllegalStateException("invalid transition: " + from + " -> " + to);
        }
    }
}
```

### 15.3 失败重试与死信
```java
public class CloudGamingServiceRetryWorker {
    public void retry(Task task) {
        int attempt = task.getAttempt() + 1;
        if (attempt > 5) {
            dlqRepo.save(task.getId(), task.getScene(), task.getLastError());
            return;
        }
        long delaySec = Math.min(300, (long) Math.pow(2, attempt));
        long jitter = ThreadLocalRandom.current().nextLong(0, 3);
        scheduler.delay(task.getId(), Duration.ofSeconds(delaySec + jitter));
        taskRepo.markRetrying(task.getId(), attempt);
    }
}
```

### 15.4 质量门禁与告警触发
```java
public class CloudGamingServiceQualityGuard {
    public GuardResult evaluate(MetricsSnapshot s) {
        boolean latencyOk = s.getP95Ms() <= 300;
        boolean errOk = s.getErrorRate() <= 0.005;
        boolean backlogOk = s.getBacklog() <= 100000;
        if (latencyOk && errOk && backlogOk) {
            return GuardResult.pass();
        }
        alertService.fire("Q" + 89 + "_QUALITY_FAIL",
            Map.of("p95", s.getP95Ms(), "err", s.getErrorRate(), "backlog", s.getBacklog()));
        return GuardResult.fail("quality gate failed");
    }
}
```

### 15.5 对账与修复任务
```java
public class CloudGamingServiceReconcileJob {
    public void run(LocalDate dt) {
        List<DiffItem> diffs = diffRepo.findDiffs(dt);
        for (DiffItem d : diffs) {
            try {
                repairService.repair(d);
                diffRepo.markFixed(d.getId());
            } catch (Exception e) {
                dlqRepo.save("REPAIR_FAIL", d.getId(), e.getMessage());
            }
        }
    }
}
```

## 16. 前端功能代码（React+TS，>=2段）
### 16.1 媒体上传台
```tsx
import { useEffect, useState } from "react";

type Health = { p95: number; errorRate: number; backlog: number; };

export function CloudGamingServiceHealthPanel() {
  const [health, setHealth] = useState<Health | null>(null);
  const [msg, setMsg] = useState("");

  useEffect(() => {
    let t: number;
    const load = async () => {
      const resp = await fetch("/api/v1/89/health");
      if (resp.ok) {
        setHealth(await resp.json());
        setMsg("");
      } else {
        setMsg("拉取失败");
      }
      t = window.setTimeout(load, 5000);
    };
    load();
    return () => window.clearTimeout(t);
  }, []);

  if (!health) return <div>加载中...</div>;
  return (
    <div>
      <h3>Design Cloud Gaming Service - 媒体上传台</h3>
      {msg && <p>{msg}</p>}
      <p>P95: {health.p95}ms</p>
      <p>ErrorRate: {health.errorRate}</p>
      <p>Backlog: {health.backlog}</p>
    </div>
  );
}
```

### 16.2 播放质量看板
```tsx
import { useState } from "react";

export function CloudGamingServiceOpsPanel() {
  const [msg, setMsg] = useState("");

  const replay = async () => {
    const resp = await fetch("/api/v1/89/ops/replay", { method: "POST" });
    setMsg(resp.ok ? "回放已触发" : "回放失败");
  };

  const rollback = async () => {
    const resp = await fetch("/api/v1/89/ops/rollback", { method: "POST" });
    setMsg(resp.ok ? "回滚已触发" : "回滚失败");
  };

  return (
    <div>
      <h3>Design Cloud Gaming Service - 播放质量看板</h3>
      <button onClick={replay}>触发回放</button>
      <button onClick={rollback}>紧急回滚</button>
      {msg && <p>{msg}</p>}
    </div>
  );
}
```

## 17. 测试策略
- 单测：状态迁移、幂等、边界条件。  
- 集成：主链路 + 异步链路端到端。  
- 压测：峰值流量、依赖抖动、降级触发。  
- 故障注入：超时、重复消息、丢消息、回放修复。  

## 18. 丰富例子（>=10）
1. 高峰流量下，Design Cloud Gaming Service 如何保证 视频编码 不退化。
2. 当依赖超时时，Design Cloud Gaming Service 如何通过降级保证主功能可用。
3. 当 低延迟传输 出现冲突时，如何通过幂等和补偿收敛。
4. 当 边缘部署 放大 3 倍时，如何分层限流与资源扩容。
5. 当单点组件故障时，如何在 RTO 目标内恢复。
6. 当策略误发布时，如何灰度回滚并避免影响扩大。
7. 当告警显示 输入同步 上升时，值班如何按 Runbook 处置。
8. 当日志和指标不一致时，如何定位真实根因。
9. 当数据延迟导致口径漂移时，如何回放修复。
10. 当成本超预算时，如何在体验与成本之间重新平衡。
11. 当出现误判时，如何人工复核并回流优化策略。
12. 当跨团队协作发生口径冲突时，如何用标准接口统一。

## 19. 面试追问 + 可复述回答
### Q1：这题最容易踩坑的点是什么？
可复述：跨服务状态不一致和重试副作用放大，所以必须幂等+补偿+可追溯。  

### Q2：如何证明方案能扛高峰？
可复述：给出容量估算、限流阈值、降级路径和压测结果。  

### Q3：故障发生后怎么快速恢复？
可复述：告警触发 -> Runbook止血 -> 回放修复 -> 对账收敛。  

## 20. 新手学习路线
1. 先讲清核心状态机与主链路。  
2. 再补幂等、重试、补偿和审计。  
3. 最后补可观测、故障演练、回滚与成本取舍。  

## 21. 上场前 Checklist
- [ ] 我能1分钟讲清核心链路。  
- [ ] 我能解释不可逆状态边界。  
- [ ] 我能说出至少3个告警阈值。  
- [ ] 我能说明重试与补偿如何闭环。  
- [ ] 我能讲清成本与稳定性的取舍。  

## 22. 与母题差异
### 22.1 对应母题
- 母题：Q22 视频流系统 (YouTube)

### 22.2 共性能力（最多5条）
1. 核心链路拆解与状态机建模  
2. 幂等、重试、补偿的一致性治理  
3. 异步事件驱动与可观测闭环  
4. 高峰限流与降级策略  
5. 故障回滚与演练体系  

### 22.3 关键差异（>=5条）
1. 本题业务目标更聚焦“视频系统”场景，非母题通用主线。  
2. 本题核心实体与索引设计围绕“视频编码、低延迟传输”展开。  
3. 失败模式重心不同：本题更常见“边缘部署”相关故障。  
4. 性能热点位置不同：本题重点在“云游戏”链路。  
5. 运营治理不同：本题要重点覆盖“视频流”告警与修复。  

### 22.4 本题新增必补知识（>=5条）
1. 视频编码 的实现边界与替代方案  
2. 低延迟传输 的一致性与容量取舍  
3. 边缘部署 的故障演练与止血策略  
4. 输入同步 的指标阈值与诊断路径  
5. 资源调度 的落地代码与运维闭环  

### 22.5 面试差异话术（3条）
1. “母题给我通用框架，这题我重点补了 视频编码，这是最显著差异。”  
2. “本题在 云游戏 上的约束更强，所以架构和阈值策略不同。”  
3. “如果只按母题回答会偏泛，我会补充本题在 视频流 的落地与故障处置。”  
# 89. Design Cloud Gaming Service

## 1. 题目元数据
- title: Design Cloud Gaming Service
- tags: 云游戏、视频流、低延迟、边缘计算、游戏渲染
- keyPoints: 视频编码、低延迟传输、边缘部署、输入同步、资源调度
- learningCoreId: 22

## 2. 题目重述
设计一个云游戏系统：游戏在云端 GPU 运行，客户端只负责输入与解码播放，目标是在高并发下维持低时延和稳定画质。

## 3. 目标与非目标
- 目标：端到端低延迟、稳定帧率、快速扩缩容、跨地域可用、成本可控。
- 非目标：游戏引擎内部优化、反作弊算法细节、完整计费系统实现。

## 4. 关键指标与容量规划
- 并发会话：50 万（峰值）。
- 单会话码率：6~18 Mbps（自适应码率）。
- 帧率目标：60 FPS（高画质档）。
- 会话建立 P95：< 3s。
- 输入到屏幕 P95：< 80ms，P99：< 120ms。

## 5. 延迟预算拆分
- 输入采集与上行：10~20ms。
- 边缘接入与路由：5~10ms。
- 云端渲染：8~16ms（单帧）。
- 编码：4~8ms（硬件编码）。
- 下行传输：15~30ms。
- 客户端解码与显示：8~16ms。

## 6. 总体架构
- 客户端 SDK：输入采集、Jitter Buffer、解码播放。
- 接入网关：鉴权、会话路由、限流、粘性会话。
- 会话编排器：分配机房/边缘节点/GPU 实例。
- 游戏运行池：容器化游戏实例 + GPU 直通。
- 媒体链路：编码器、转码器、ABR 控制器、CDN/边缘转发。
- 控制面：配置中心、调度策略、发布灰度。

## 7. 核心数据模型
- UserSession(sessionId, userId, gameId, region, state, startAt, endAt)。
- StreamChannel(sessionId, codec, bitrate, fps, keyframeInterval, edgeNode)。
- InputEvent(sessionId, seq, deviceTs, serverTs, payload, acked)。
- ResourceLease(leaseId, gpuNodeId, sessionId, expireAt, status)。

## 8. 会话生命周期与状态机
- INIT -> MATCHING -> BOOTING -> RUNNING -> DEGRADED -> ENDING -> CLOSED。
- RUNNING 到 DEGRADED 触发条件：丢包高、RTT 高、GPU 争用高。
- DEGRADED 恢复条件：连续 N 个窗口健康后回升到 RUNNING。

## 9. 编码与传输策略
- 优先 H.265/AV1（终端不支持则回退 H.264）。
- GOP 1~2s，关键帧按场景动态插入。
- 拥塞控制：基于 RTT/丢包率动态降码率。
- 弱网降级：先降分辨率，再降帧率，最后启用静态场景增强压缩。

## 10. 输入同步与一致性
- 输入事件严格递增序号 + 去重键（sessionId+seq）。
- 服务端按 seq 排序执行，乱序包进入短暂重排窗口。
- ACK + 重传机制保证关键输入（开火/技能）不丢失。

## 11. 调度与资源管理
- 首选“就近边缘 + 可用 GPU 池”策略。
- 热门游戏预热实例池，降低冷启动。
- GPU over-commit 受限，按 SLA 档位隔离资源。
- 高峰采用排队与候补机制，避免雪崩。

## 12. 存储与日志链路
- 会话元数据：MySQL（主从）+ Redis 缓存。
- 输入事件短期存储：Kafka + ClickHouse（回放分析）。
- 观测数据：Prometheus + Loki + Trace 系统。
- 回放样本与问题片段：对象存储分层保存。

## 13. 可观测性与告警
- 黄金指标：可用率、首帧时间、输入时延、卡顿率、崩溃率。
- 阈值样例：
  - 输入到屏幕 P95 > 80ms 持续 5 分钟告警。
  - 丢包率 > 3% 且 RTT > 60ms 持续 3 分钟触发降级。
  - GPU 使用率 > 90% 持续 10 分钟触发扩容。

## 14. 高可用与容灾设计
- 多 Region 主动-主动，单 Region 内多可用区部署。
- 控制面跨区复制，数据平面会话就近粘性。
- 故障恢复路径：
  - 边缘节点故障 -> 会话迁移到同城备节点 -> 重新协商码率。
  - 可用区故障 -> 区域内重调度 + 快速拉起预热实例。
  - 区域级故障 -> DNS/GSLB 切流到邻近区域。
- RTO：会话级 30~90 秒；区域级 5 分钟内恢复。
- RPO：会话控制元数据 <= 5 秒；输入事件分析链路 <= 30 秒。

## 15. Java 关键实现（>=5）
```java
public final class IdempotencyKey {
    public static String of(String sessionId, long seq) {
        return sessionId + ":" + seq;
    }
}
```

```java
import java.util.concurrent.ConcurrentHashMap;

public class InputDeduplicator {
    private final ConcurrentHashMap<String, Long> latestSeq = new ConcurrentHashMap<>();

    public boolean accept(String sessionId, long seq) {
        return latestSeq.compute(sessionId, (k, oldVal) -> {
            long oldSeq = oldVal == null ? -1L : oldVal;
            return Math.max(oldSeq, seq);
        }) == seq;
    }
}
```

```java
public class AbrController {
    public int nextBitrateKbps(int current, double lossRate, int rttMs) {
        if (lossRate > 0.03 || rttMs > 60) {
            return Math.max(2500, (int) (current * 0.85));
        }
        if (lossRate < 0.01 && rttMs < 35) {
            return Math.min(18000, (int) (current * 1.10));
        }
        return current;
    }
}
```

```java
public class SessionStateMachine {
    public enum State { INIT, MATCHING, BOOTING, RUNNING, DEGRADED, ENDING, CLOSED }

    public State onMetric(State state, double lossRate, int rttMs) {
        if (state == State.RUNNING && (lossRate > 0.03 || rttMs > 60)) return State.DEGRADED;
        if (state == State.DEGRADED && (lossRate < 0.015 && rttMs < 40)) return State.RUNNING;
        return state;
    }
}
```

```java
import java.time.Instant;

public class Lease {
    private final String leaseId;
    private final Instant expireAt;

    public Lease(String leaseId, Instant expireAt) {
        this.leaseId = leaseId;
        this.expireAt = expireAt;
    }

    public boolean isExpired(Instant now) {
        return now.isAfter(expireAt);
    }

    public String leaseId() {
        return leaseId;
    }
}
```

## 16. React 端实现（>=2）
```jsx
import React, { useEffect, useState } from "react";

export function SessionBootstrap({ gameId }) {
  const [status, setStatus] = useState("loading"); // loading | done | error
  const [error, setError] = useState("");
  const [session, setSession] = useState(null);

  useEffect(() => {
    let canceled = false;
    const idempotencyKey = `boot-${gameId}-${Date.now()}`;

    async function createSession(retry = 0) {
      try {
        setStatus("loading");
        const resp = await fetch("/api/sessions", {
          method: "POST",
          headers: { "Content-Type": "application/json", "Idempotency-Key": idempotencyKey },
          body: JSON.stringify({ gameId })
        });
        if (!resp.ok) throw new Error(`create failed: ${resp.status}`);
        const data = await resp.json();
        if (!canceled) {
          setSession(data);
          setStatus("done");
        }
      } catch (e) {
        if (retry < 2) {
          setTimeout(() => createSession(retry + 1), 800 * (retry + 1)); // retry
        } else if (!canceled) {
          setError(String(e));
          setStatus("error");
        }
      }
    }

    createSession();
    return () => { canceled = true; };
  }, [gameId]);

  if (status === "loading") return <div>Starting session...</div>;
  if (status === "error") return <div>Failed: {error}</div>;
  return <div>Session ready: {session?.sessionId}</div>;
}
```

```javascript
import { useEffect, useState } from "react";

export function useSessionHealth(sessionId) {
  const [status, setStatus] = useState("loading"); // loading | done | error
  const [error, setError] = useState("");
  const [health, setHealth] = useState(null);

  useEffect(() => {
    if (!sessionId) return;
    let timer;
    let stopped = false;

    async function poll() {
      try {
        const r = await fetch(`/api/sessions/${sessionId}/health`);
        if (!r.ok) throw new Error(`health failed: ${r.status}`);
        const d = await r.json();
        if (stopped) return;
        setHealth(d);
        setStatus("done");
        setError("");
      } catch (e) {
        if (stopped) return;
        setStatus("error");
        setError(String(e));
        setHealth((prev) => prev ? { ...prev, mode: "degraded" } : { mode: "degraded" }); // degrade
      } finally {
        if (!stopped) timer = setTimeout(poll, 2000); // polling
      }
    }

    setStatus("loading");
    poll();
    return () => {
      stopped = true;
      if (timer) clearTimeout(timer);
    };
  }, [sessionId]);

  return { status, error, health };
}
```

## 17. 安全与合规
- 鉴权：短时令牌 + 设备绑定。
- 传输：TLS + SRTP。
- 隐私：会话日志脱敏、最小化采集。
- 审计：关键操作与管理面全量审计。

## 18. 丰富例子（>=10）
1. 玩家在北京，调度到北京边缘节点，首帧时间从 2.8s 降到 1.4s。  
2. 同城网络抖动，ABR 从 12Mbps 降到 8Mbps，卡顿率下降 40%。  
3. GPU 池接近满载时，热门游戏启用预热池，排队时间减少 35%。  
4. 输入乱序 1% 场景下，重排窗口 20ms 保证技能释放顺序正确。  
5. 遇到突发丢包 5%，系统降分辨率而非直接掉线，留存提升。  
6. 边缘节点故障后 45 秒完成会话迁移，玩家可继续游戏。  
7. 编码器过热导致延迟抬升，自动切换备用编码实例恢复正常。  
8. 某区域网络拥塞，GSLB 切到邻区，P95 延迟增加但可用性保持。  
9. 客户端不支持 H.265，自动回退 H.264 并维持 60FPS 中档画质。  
10. 创建会话 API 超时时，前端重试并用幂等键避免重复扣费。  
11. 健康检查 API 波动，前端进入 degraded 展示并持续轮询恢复。  
12. 周末活动流量翻倍，自动扩容 GPU 节点 30% 后稳定运行。  

## 19. 常见失败点与修复
- 只追求画质不控时延：应建立硬性延迟预算。
- 调度无就近策略：跨区 RTT 高，必须加入地理亲和。
- 输入未幂等：重试导致重复动作，必须 seq+去重键。
- 监控只看均值：需重点盯 P95/P99 与长尾。

## 20. 面试回答模板
- 先定目标：低延迟、稳定、成本、可用性。
- 再画链路：输入上行 -> 渲染编码 -> 下行解码。
- 重点展开：调度、ABR、输入同步、故障恢复。
- 最后给数字：SLO 阈值、容量估算、RTO/RPO。

## 21. 自检与评分
- 架构完整性：20/20
- 低延迟机制：20/20
- 高可用容灾（含 RTO/RPO）：20/20
- 工程落地（代码与状态机）：20/20
- 监控与阈值：18/20
- 总分：98/100

## 22. 与母题差异
- 母题 #22（视频流系统）更偏“内容分发与点播/直播链路”。
- 本题 #89 强调“交互闭环”，核心是输入同步与实时控制，不仅是播放。
- 本题更依赖 GPU 资源编排与会话级调度，而非单纯转码/CDN。
- 本题需要更严格的时延预算和降级策略（帧率/分辨率/编码参数联动）。
- 本题故障恢复更关注“会话连续性”，不仅是媒体可达性。

新增必补知识：
1. 云端渲染实例生命周期管理（冷启动、预热、回收）。
2. 输入事件幂等与乱序重排窗口设计。
3. 交互场景 ABR 与拥塞控制联合策略。
4. 会话级迁移（边缘故障时的状态接续）机制。
5. GPU 资源隔离与 SLA 分层调度策略。
6. 端到端输入时延可观测与长尾治理方法。
