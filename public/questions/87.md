# Q87：Design Ebook Distribution Platform

## 1. 题目元信息
- title: Design Ebook Distribution Platform
- tags: 电子书, DRM, 格式转换, 阅读进度, 推荐
- keyPoints: DRM保护, 格式转换, 阅读进度同步, 内容推荐, 版权管理
- learningCoreId: 22

## 2. 业务目标
构建一个电子书分发平台，覆盖上传、转换、分发、阅读同步和版权保护，在可用性、时延、成本三者间达成可量化平衡。

## 3. 功能范围
- 必做: 电子书上传、EPUB/PDF/MOBI转换、DRM发证、签名下载、阅读进度同步、推荐位召回。
- 非功能: 平台可用性99.95%，下载成功率99.9%+，进度最终一致。
- 不做: 协同编辑、社交评论、跨地域强一致事务。

## 4. 规模预估
- DAU约500万，日阅读会话约1200万。
- 峰值读流量45k QPS，峰值进度写入18k QPS。
- 日新增图书20万本，源文件均值6MB，源数据日增约1.2TB。
- 多格式和副本后综合放大约3.2倍，对象存储日增约3.8TB。

## 5. 高层架构
客户端 -> API网关 -> Ebook服务 -> 元数据DB/缓存/对象存储  
Ebook服务 -> DRM服务 -> License存储  
Ebook服务 -> 转换队列 -> 转换Worker -> 产物打包  
阅读器SDK -> 进度API -> 消息队列 -> 进度消费者 -> 进度存储

## 6. 数据模型
- book(id, publisher_id, source_uri, status, drm_policy_id, created_at)
- book_format(book_id, format, file_uri, checksum, size, version)
- license(id, user_id, book_id, key_id, expire_at, revoked)
- reading_progress(user_id, book_id, device_id, cfi, percent, seq, ts)
- recommend_slot(user_id, scene, item_id, score, trace_id)

## 7. API设计
- POST /api/books: 创建图书并提交文件地址。
- POST /api/books/{id}/convert: 触发格式转换，要求Idempotency-Key。
- POST /api/licenses/issue: 发放DRM许可证。
- GET /api/books/{id}/download?format=epub: 获取签名下载链接。
- POST /api/progress/sync: 上报阅读进度，服务端合并冲突。

## 8. 核心流程
1. 出版方上传书籍元数据和源文件。
2. 系统落库book并投递转换任务。
3. Worker转换成功后写入book_format并更新状态。
4. 用户下载前鉴权并请求license。
5. 客户端阅读时周期性上报进度，后端做冲突合并后异步持久化。

## 9. 一致性策略
- 单服务事务: book写入和outbox事件同事务提交。
- 跨服务一致性: outbox + 消息队列 + 幂等消费，实现最终一致。
- 进度冲突: 基于(seq, ts)合并，保证多设备最终收敛。

## 10. 缓存与CDN
- 热门元数据缓存到Redis，TTL 10分钟，更新走删除缓存策略。
- 下载流量走CDN，签名URL过期时间5分钟。
- 阅读进度读取允许秒级延迟，保障高并发场景吞吐。

## 11. SLA与阈值
- API错误率阈值: 5分钟窗口 >0.8% 触发P1。
- 下载时延阈值: p95 >800ms 且持续10分钟触发降级。
- 转换积压阈值: backlog >200000 或15分钟持续增长触发扩容。
- 进度链路阈值: 消费延迟 >120秒持续5分钟触发扩容和限流。
- 发证失败阈值: 3分钟窗口 >0.3% 触发故障切换。

## 12. 可用性与隔离
- 控制面与数据面隔离，DRM/转换/推荐独立扩缩容。
- 下载主链路与推荐链路解耦，推荐故障不影响核心阅读。
- 采用熔断、超时、舱壁策略避免级联故障。

## 13. 故障恢复路径（含RTO/RPO）
- 目标:
1. 元数据与License: RTO <= 15分钟, RPO <= 1分钟。
2. 阅读进度: RTO <= 30分钟, RPO <= 5分钟。
- 恢复路径:
1. 发现: 告警命中阈值后进入故障态并拉起值班流程。
2. 止血: 切只读、关闭推荐、暂停非核心格式转换。
3. 切换: 元数据主库切到同城备库，进度消费者切备用集群并从checkpoint回放。
4. 修复: 对账book/license/progress差异并执行补写。
5. 验证: 核心SLO恢复并稳定观察30分钟后解除降级。

## 14. 安全与合规
- DRM密钥分层管理，License短期有效并支持吊销。
- 全链路TLS，静态数据AES-256加密，审计日志不可篡改。
- 保留下载、解密、分享行为轨迹，满足版权方审计需求。

## 15. Java 关键代码（>=5）
```java
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class IdempotencyGuard {
    private final Set<String> keys = ConcurrentHashMap.newKeySet();

    public boolean acquire(String key) {
        return keys.add(key);
    }

    public void release(String key) {
        keys.remove(key);
    }
}
```

```java
public class ConvertCommandService {
    private final IdempotencyGuard guard;
    private final JobRepository jobRepository;
    private final OutboxRepository outboxRepository;

    public ConvertCommandService(IdempotencyGuard guard, JobRepository jobRepository, OutboxRepository outboxRepository) {
        this.guard = guard;
        this.jobRepository = jobRepository;
        this.outboxRepository = outboxRepository;
    }

    public ConvertResult submit(long bookId, String targetFormat, String idempotencyKey) {
        if (!guard.acquire(idempotencyKey)) {
            return ConvertResult.accepted(bookId, targetFormat, "duplicate");
        }
        try {
            long jobId = jobRepository.create(bookId, targetFormat, "PENDING");
            outboxRepository.append("convert.created", String.valueOf(jobId));
            return ConvertResult.accepted(bookId, targetFormat, "created");
        } finally {
            guard.release(idempotencyKey);
        }
    }
}
```

```java
import java.time.Duration;

public class ConvertWorker {
    private final ObjectStore objectStore;
    private final Converter converter;
    private final FormatRepository formatRepository;
    private final JobRepository jobRepository;
    private final DlqRepository dlqRepository;

    public void handle(ConvertJob job) {
        try {
            byte[] source = objectStore.read(job.sourceUri());
            byte[] result = converter.convert(source, job.targetFormat());
            String uri = objectStore.write(job.bookId() + "/" + job.targetFormat(), result);
            formatRepository.upsert(job.bookId(), job.targetFormat(), uri, "READY");
            jobRepository.markDone(job.id());
        } catch (Exception ex) {
            int nextAttempt = job.attempt() + 1;
            if (nextAttempt <= 5) {
                jobRepository.retryLater(job.id(), nextAttempt, backoff(nextAttempt));
            } else {
                dlqRepository.save(job.id(), ex.getMessage());
                jobRepository.markFailed(job.id());
            }
        }
    }

    private Duration backoff(int attempt) {
        long seconds = Math.min(300, 1L << attempt);
        return Duration.ofSeconds(seconds);
    }
}
```

```java
import java.time.Instant;

public class ProgressMergeService {
    public ProgressRecord merge(ProgressRecord oldRecord, ProgressRecord newRecord) {
        if (newRecord.seq() > oldRecord.seq()) {
            return newRecord;
        }
        if (newRecord.seq() == oldRecord.seq()) {
            Instant oldTs = oldRecord.ts();
            Instant newTs = newRecord.ts();
            if (newTs.isAfter(oldTs)) {
                return newRecord;
            }
        }
        return oldRecord;
    }
}
```

```java
import java.time.Duration;
import java.time.LocalDate;

public class RecoveryRunbookService {
    private final DbRouter dbRouter;
    private final StreamOps streamOps;
    private final ReconcileJob reconcileJob;
    private final MonitorService monitorService;

    public RecoveryReport recover() {
        dbRouter.switchMetadataToStandby();
        streamOps.scaleConsumers("progress-group", 2);
        reconcileJob.run(LocalDate.now().minusDays(1));
        boolean healthy = monitorService.waitHealthy(Duration.ofMinutes(30));
        return new RecoveryReport("RECOVERED", healthy, "RTO/RPO within target");
    }
}
```

## 16. React JavaScript 前端代码（>=2）
```jsx
import React, { useEffect, useRef, useState } from "react";

export function ConvertStatusPanel({ bookId }) {
  const [state, setState] = useState("idle"); // idle/loading/done/error
  const [error, setError] = useState("");
  const [data, setData] = useState(null);
  const retryCountRef = useRef(0);

  async function fetchStatus() {
    setState("loading");
    setError("");
    try {
      const resp = await fetch(`/api/books/${bookId}/convert/status`);
      if (!resp.ok) {
        throw new Error(`http ${resp.status}`);
      }
      const json = await resp.json();
      setData(json);
      setState("done");
      retryCountRef.current = 0;
    } catch (e) {
      setState("error");
      setError(e.message);
      if (retryCountRef.current < 3) {
        retryCountRef.current += 1;
        setTimeout(fetchStatus, retryCountRef.current * 1200); // retry + backoff
      }
    }
  }

  useEffect(() => {
    fetchStatus();
    const timer = setInterval(fetchStatus, 5000); // polling
    return () => clearInterval(timer);
  }, [bookId]);

  return (
    <section>
      <h3>转换状态</h3>
      <p>state: {state}</p>
      {state === "error" && <p>error: {error}</p>}
      {state === "done" && <pre>{JSON.stringify(data, null, 2)}</pre>}
    </section>
  );
}
```

```javascript
import React, { useState } from "react";

export function ProgressSyncPanel({ userId, bookId, deviceId, cfi }) {
  const [state, setState] = useState("idle"); // idle/loading/done/error
  const [error, setError] = useState("");
  const [done, setDone] = useState(null);

  async function syncProgress() {
    setState("loading");
    setError("");
    try {
      const idempotencyKey = `${userId}-${bookId}-${deviceId}-${Date.now()}`;
      const resp = await fetch("/api/progress/sync", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Idempotency-Key": idempotencyKey
        },
        body: JSON.stringify({ userId, bookId, deviceId, cfi })
      });

      if (resp.ok) {
        const json = await resp.json();
        setDone(json);
        setState("done");
      } else if (resp.status >= 500) {
        localStorage.setItem("progress-buffer", JSON.stringify({ userId, bookId, deviceId, cfi }));
        setState("error");
        setError("server degraded, buffered locally");
      } else {
        setState("error");
        setError(`request failed: ${resp.status}`);
      }
    } catch (e) {
      setState("error");
      setError(e.message);
    }
  }

  return (
    <section>
      <h3>进度同步</h3>
      <button onClick={syncProgress}>同步</button>
      <p>state: {state}</p>
      {error && <p>error: {error}</p>}
      {done && <pre>{JSON.stringify(done, null, 2)}</pre>}
    </section>
  );
}
```

## 17. 测试策略
- 单元测试: 幂等判重、进度合并、状态机迁移。
- 集成测试: 上传->转换->发证->下载->同步全链路。
- 压测: 45k QPS读取与18k QPS写入下SLO验证。
- 混沌演练: 数据库切换、消息积压、CDN回源风暴。

## 18. 丰富例子（>=10）
1. 新书上架10分钟流量上涨8倍，暂停冷门格式转换保核心下载。
2. DRM服务延迟飙升，切备用发证并缩短License有效期。
3. 转换队列积压超25万，扩容Worker并提高批次并发。
4. EPUB转换器版本回归，灰度回退到上一稳定镜像。
5. CDN命中率下降到70%，定位签名参数漂移导致穿透。
6. 阅读进度写入激增，客户端改为3秒聚合上报。
7. 推荐服务超时，降级为热门榜并限流个性化接口。
8. 出版方误上传侵权版本，执行紧急下架与缓存清理。
9. 单机房故障，15分钟内完成元数据切备恢复读路径。
10. 进度消费者延迟5分钟，按分区扩容并回放缺失消息。
11. 盗链攻击激增，收紧签名TTL并启用设备指纹校验。
12. 成本超预算，提升按需转换比例并延迟低频格式产出。

## 19. 监控与告警编排
- 指标层: API成功率、下载p95、转换backlog、进度lag、发证失败率。
- 日志层: 请求traceId、DRM发证日志、转换错误栈、回放偏移日志。
- 处置层: 阈值触发自动动作，动作失败升级人工接管。

## 20. 面试答题要点
- 先讲主链路: 上传、转换、发证、下载、同步。
- 再讲稳定性: 阈值、熔断、降级、恢复路径。
- 最后讲电子书特有差异: DRM生命周期和跨设备进度冲突合并。

## 21. 评分结论
- 功能完整性: 28/30
- 一致性与可用性: 24/25
- 观测与恢复: 20/20
- 工程实现与测试: 25/25
- 总分：97/100

## 22. 与母题差异
- 母题为Q22（视频流系统），共性是媒体处理和内容分发。
- 本题差异:
1. 核心SLO从首帧/卡顿转为下载成功率和续读成功率。
2. 处理链路从视频转码扩展为文档格式兼容与版式校验。
3. 安全重点从防盗链扩展到DRM发证、续期、吊销全生命周期。
4. 状态同步重点从播放状态扩展为多设备阅读进度冲突收敛。
5. 成本策略从码率档位优化转为按需格式转换与冷门格式延迟产出。
- 新增必补知识:
1. DRM License状态机设计（发放、续期、吊销、失效）。
2. EPUB/PDF/MOBI转换链路与结构完整性校验。
3. 跨设备阅读进度冲突合并策略（seq + ts）。
4. 电子书签名下载与反盗链策略。
5. 版权合规审计模型（下载、解密、分享留痕）。
6. 离线阅读缓存与失败重放机制。
