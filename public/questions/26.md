# Q26 PageRank - 网页排名算法系统设计（面试高分版）

## 1. 三句话题目本质
1. 这题核心是“如何在超大链接图上稳定计算网页重要性分数”，不是只背一个公式。  
2. 难点是分布式迭代收敛、增量更新、反作弊、以及版本发布回滚。  
3. 面试高分要讲清：计算模型、工程化调度、故障恢复和质量评估闭环。

## 2. 真实场景故事（问题-方案-结果）
- 问题：全量 PageRank 每天跑一次，耗时 20+ 小时；热点新闻站点变化快，新页面排名更新太慢。  
- 方案：全量计算保底 + 增量子图重算；加 checkpoint、失败分区重跑、版本化发布；引入垃圾链接惩罚。  
- 结果：增量刷新从天级降到小时级，排序质量稳定，且发布失败可在分钟级回滚。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Link Graph | 网页和链接组成的有向图 | 页面是点，超链接是边 |
| In-degree | 入链数量 | 被别人引用越多通常越重要 |
| Out-degree | 出链数量 | 重要性会分摊给出链页面 |
| Damping Factor | 阻尼因子（常见0.85） | 模拟用户偶尔随机跳转 |
| Dangling Node | 无出链节点 | 要集中处理否则分数丢失 |
| Iteration | 一轮迭代计算 | 每轮更新全量rank |
| Residual | 相邻两轮差异 | 用于判断是否收敛 |
| Convergence | 收敛 | 差异足够小可停止 |
| Partition | 图分区 | 分布式并行计算基础 |
| Checkpoint | 中间快照 | 失败后可断点恢复 |
| Incremental PR | 增量PageRank | 只算受影响子图降低成本 |
| Spam Link | 垃圾链接 | 需要惩罚避免刷排名 |

## 4. 需求澄清（功能/非功能/不做/SLO）
### 4.1 功能需求
1. 支持全量 PageRank 计算任务。  
2. 支持增量更新（新增/删除链接影响传播）。  
3. 支持按 URL 或 DocId 查询当前 rank。  
4. 支持版本发布、回滚、质量对比。  
5. 支持反垃圾信号融合（降权）。

### 4.2 非功能需求
1. 能扩展到 10^10 级节点、10^12 级边。  
2. 任务失败可恢复，不重跑全图。  
3. 结果可追溯、可审计。  
4. 资源成本可控。

### 4.3 不做范围
1. 不做爬虫抓取。  
2. 不做完整搜索召回。  
3. 不做深度学习重排序。

### 4.4 SLO/SLA
1. 全量任务完成时间 <= 24h。  
2. 增量任务完成时间 <= 2h。  
3. 任务成功率 >= 99%。  
4. 版本发布回滚 RTO <= 15min。

## 5. 容量估算（含数字推导）
1. 假设节点数 `N=50B`，边数 `E=3T`。  
2. 边压缩后按 10B/edge 估算，边存储约 `30TB`。  
3. 每轮迭代要扫描绝大多数边，20 轮则边扫描量约 `600TB`。  
4. 若日增量边占 1%，子图重算可将计算量压到全量的 5%~15%。  
5. 结果表 `rank_value`（docId + score + version）按 24B/行，50B 规模约 `1.2TB/版本`。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
Graph Storage -> Distributed PR Engine -> Rank Store -> Publish Service
```

### 6.2 完整版
```text
Link Change Stream (crawl updates / link updates)
  -> Graph Ingest + Validation
  -> Graph Store (partitioned adjacency)

PR Scheduler
  -> Full Job / Incremental Job Builder
  -> Iteration Workers
  -> Dangling Mass Aggregator
  -> Residual Evaluator
  -> Checkpoint Store

Rank Store (versioned)
  -> Quality Evaluator (NDCG, ctr_proxy)
  -> Publish Controller (canary + rollback)

Ops
  -> Metrics / Logs / Trace
  -> Alerting + Runbook
```

## 7. API设计（请求/响应/错误码/幂等）
### 7.1 提交全量任务
- `POST /api/v1/pagerank/jobs/full`
- Header: `Idempotency-Key: pr-full-20260224`

### 7.2 提交增量任务
- `POST /api/v1/pagerank/jobs/incremental`
```json
{"changeWindow":"2026-02-24T00:00:00Z/2026-02-24T01:00:00Z"}
```

### 7.3 查询rank
- `GET /api/v1/pagerank/score?docId=123&version=latest`

### 7.4 发布版本
- `POST /api/v1/pagerank/version/publish`
错误码：`JOB_NOT_FINISHED`、`QUALITY_REGRESSION`、`PUBLISH_LOCKED`

## 8. 数据模型（实体/索引/分区）
1. `graph_edge(src_doc_id, dst_doc_id, weight, updated_at)`  
2. `rank_value(doc_id, version, score, updated_at)`  
3. `iter_checkpoint(job_id, iter_no, partition_id, residual)`  
4. `job_meta(job_id, type, status, start_at, end_at)`  
5. `spam_penalty(doc_id, penalty_score, reason)`  
6. 分区策略：按 `src_doc_id hash` 分区，跨分区消息通过 shuffle 传递。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常
构建任务 -> 初始化 rank -> 迭代传播 -> 计算 residual -> 达阈值后产出版本。

### 9.2 高峰（更新风暴）
链接变更激增 -> 聚合变更窗口 -> 仅重算影响子图 -> 同步刷新 rank 子集。

### 9.3 故障恢复
某分区 worker 挂掉 -> 从 checkpoint 恢复该分区 -> 继续迭代 -> 汇总结果发布。

## 10. 一致性与事务边界
1. 单个版本内使用快照一致（同一图快照）。  
2. 发布采用版本指针原子切换。  
3. 增量任务与在线读取隔离，发布前不暴露。  
4. 最终一致，不追求实时强一致。

## 11. 可用性与容错（含RTO/RPO）
1. 任务调度器高可用（多副本+租约选主）。  
2. 分区失败自动重试，超过阈值转人工处理。  
3. 关键阶段写 checkpoint，减少重跑损失。  
4. 发布失败可快速回切旧版本。  
5. RTO 15 分钟，RPO 0（可重算）。

## 12. 可观测性（指标 + 阈值 + 动作）
核心指标：
- `pr_job_runtime_min`
- `pr_iter_residual`
- `pr_failed_partition_ratio`
- `pr_shuffle_bytes`
- `pr_quality_delta`

阈值和动作：
1. `pr_iter_residual` 连续 3 轮不下降 -> P1，触发数据检查和参数回退。  
2. `pr_failed_partition_ratio > 1%` -> P1，自动扩容 worker 并重试。  
3. 任务超 SLA 20% -> P1，降级并发、切低峰资源池。  
4. `pr_quality_delta < -5%` -> 阻断发布并告警。

## 13. 安全与合规
1. 任务与发布接口必须鉴权（RBAC）。  
2. 发布/回滚操作写审计日志。  
3. 反作弊规则有版本管理和审批。  
4. 结果数据按权限控制读取。

## 14. 成本与取舍
1. 全量最准但成本最高；增量便宜但有漂移风险。  
2. 迭代轮数越多质量越高，但时间和资源上涨。  
3. 分区越细并行越高，但 shuffle 和调度开销增加。  
4. 反垃圾惩罚过重会误伤，需离线评估再发布。

## 15. Java关键代码（>=5段）
### 15.1 单轮贡献计算
```java
public class ContributionCalculator {
    public double contribution(double rank, int outDegree) {
        if (outDegree <= 0) return 0.0;
        return rank / outDegree;
    }
}
```

### 15.2 PageRank更新公式
```java
public class RankFormula {
    public double update(double damping, double incomingMass, long totalNodes, double danglingMass) {
        double teleport = (1.0 - damping) / totalNodes;
        double dangling = damping * danglingMass / totalNodes;
        return teleport + dangling + damping * incomingMass;
    }
}
```

### 15.3 收敛判断
```java
public class ConvergenceChecker {
    public boolean converged(double residual, double threshold) {
        return residual >= 0 && residual < threshold;
    }
}
```

### 15.4 增量任务构建
```java
public class IncrementalJobBuilder {
    public Set<Long> buildAffectedSubgraph(List<LinkChange> changes, int hops) {
        Set<Long> affected = new HashSet<>();
        for (LinkChange c : changes) {
            affected.add(c.src());
            affected.add(c.dst());
        }
        return graphRepo.expandNeighborhood(affected, hops);
    }
}
```

### 15.5 版本发布与回滚
```java
public class VersionPublisher {
    public void publish(String version) {
        if (!qualityGate.pass(version)) {
            throw new IllegalStateException("quality gate failed");
        }
        versionRepo.atomicSwitch(version);
    }

    public void rollback(String previousVersion) {
        versionRepo.atomicSwitch(previousVersion);
    }
}
```

## 16. 前端功能代码（React JS >=2段）
### 16.1 任务提交与轮询模块（纯API协作）
```javascript
export async function submitIncrementalJob(changeWindow) {
  const state = { loading: true, error: "", jobId: "", status: "INIT" };
  try {
    const resp = await fetch("/api/v1/pagerank/jobs/incremental", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Idempotency-Key": `pr-inc-${Date.now()}`
      },
      body: JSON.stringify({ changeWindow })
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    state.jobId = data.jobId;
    state.status = "SUBMITTED";
  } catch (e) {
    state.error = `提交失败: ${String(e.message || e)}`;
    state.status = "FAILED";
  } finally {
    state.loading = false;
  }
  return state;
}

export async function pollJobStatus(jobId) {
  try {
    const r = await fetch(`/api/v1/pagerank/jobs/${jobId}`);
    if (!r.ok) throw new Error(`HTTP_${r.status}`);
    const d = await r.json();
    return { ok: true, status: d.status, done: ["SUCCESS", "FAILED"].includes(d.status), error: "" };
  } catch (e) {
    return { ok: false, status: "UNKNOWN", done: false, error: `轮询失败: ${String(e.message || e)}` };
  }
}
```

### 16.2 版本发布/回滚模块（失败重试+状态管理）
```javascript
async function postVersionAction(url, version, retry = 0) {
  try {
    const resp = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ version })
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, error: "" };
  } catch (e) {
    if (retry < 2) return postVersionAction(url, version, retry + 1);
    return { ok: false, error: String(e.message || e) };
  }
}

export async function publishVersion(version) {
  const r = await postVersionAction("/api/v1/pagerank/version/publish", version);
  return r.ok ? { status: "PUBLISHED", error: "" } : { status: "FAILED", error: `发布失败: ${r.error}` };
}

export async function rollbackVersion(version) {
  const r = await postVersionAction("/api/v1/pagerank/version/rollback", version);
  return r.ok ? { status: "ROLLED_BACK", error: "" } : { status: "FAILED", error: `回滚失败: ${r.error}` };
}
```

## 17. 测试策略
1. 单测：公式正确性、dangling处理、收敛阈值判断。  
2. 集成：任务提交->迭代->发布->查询全链路。  
3. 压测：高边数分区下 shuffle 压力。  
4. 故障注入：worker 宕机、网络抖动、checkpoint损坏。  
5. 回归：与上一版本质量对比（离线指标）。

## 18. 丰富例子（>=10）
1. 某新闻站突增入链，增量任务如何快速体现排名变化。  
2. Dangling节点占比升高导致 rank 总量漂移如何修正。  
3. 迭代残差不降反升时如何定位。  
4. 某分区长尾慢任务影响总时长。  
5. 增量结果与全量偏差过大时如何回退。  
6. 垃圾链接农场批量注入如何降权。  
7. 版本发布后质量下降如何自动阻断。  
8. Checkpoint 丢失后最小重跑范围如何确定。  
9. 低峰和高峰资源池如何分配。  
10. 参数从 0.85 改 0.9 对结果和收敛的影响。  
11. 多租户共享计算集群时的隔离策略。  
12. 回滚后如何验证线上排序恢复。

## 19. 面试追问 + 可复述回答
1. 为什么要阻尼因子？  
可复述：防止排名完全被链接结构锁死，模拟用户随机跳转，提高稳定性。  

2. 如何从工程上加速 PageRank？  
可复述：分区并行、checkpoint断点恢复、增量子图重算、慢分区推测执行。  

3. 发布为什么要质量门禁？  
可复述：排序质量回退会直接影响用户体验和收入，必须先评估再切换版本。

## 20. 新手学习路线
1. 手算小图 PageRank 迭代。  
2. 理解收敛与残差。  
3. 学分布式分区与消息传播。  
4. 学增量计算与版本管理。  
5. 学反作弊与质量评估。

## 21. 上场前Checklist
- [ ] 能手写 PageRank 更新公式并解释每一项。  
- [ ] 能讲清 dangling 节点处理。  
- [ ] 能说出增量重算思路和边界。  
- [ ] 能给出3个以上告警阈值和动作。  
- [ ] 能解释发布回滚机制。

## 22. 与母题差异（对应 Q32）
### 22.1 对应母题
- Q32 Design Google Search Engine

### 22.2 共性能力
1. 搜索排序信号构建。  
2. 大规模分布式计算。  
3. 版本化发布与回滚。  
4. 质量评估闭环。  
5. 可观测与故障处理。

### 22.3 关键差异（>=5条）
1. Q26 是“排序算法子系统”，Q32 是“搜索平台全链路”。  
2. Q26 重点在图迭代收敛，Q32 重点在抓取、索引、召回、排序协同。  
3. Q26 以离线/准离线计算为主，Q32 还包含在线检索延迟优化。  
4. Q26 的核心风险是收敛和版本质量退化。  
5. Q32 的核心风险是链路复杂度和在线服务稳定性。

### 22.4 本题新增必补知识（>=5条）
1. 图分区与消息传播。  
2. Dangling mass 处理。  
3. 残差收敛判定。  
4. 增量子图重算策略。  
5. 反垃圾降权融合。

### 22.5 面试差异话术（3条）
1. “Q26 我会重点讲 PageRank 工程化落地，不会停留在公式。”  
2. “Q32 是全栈搜索，Q26 是排序信号计算引擎。”  
3. “Q26 高分关键是收敛、增量、发布回滚三件事讲清楚。”
