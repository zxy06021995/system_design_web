# Q29 数据库事务系统设计（面试高分版）

## 1. 三句话题目本质
1. 事务题核心是：并发和故障下仍然保证数据正确。  
2. 关键不是背 ACID，而是把“隔离级别、锁、MVCC、WAL恢复”讲成可落地方案。  
3. 面试高分回答要同时给出：一致性边界、性能取舍、故障恢复路径。

## 2. 真实场景故事（问题-方案-结果）
- 问题：支付场景出现“资金扣了但订单未更新”，并发高峰时死锁频发。  
- 方案：核心链路统一事务边界；账户更新使用固定顺序加锁；引入重试幂等键；WAL恢复流程标准化。  
- 结果：不一致事故归零，死锁率下降 80%，事务 P95 从 140ms 降到 75ms。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| ACID | 事务四大特性 | 正确性的底座 |
| 原子性 | 要么都成功要么都失败 | 不能半成功 |
| 一致性 | 业务约束不被破坏 | 如余额不能负 |
| 隔离性 | 并发互不干扰到可接受程度 | 由隔离级别控制 |
| 持久性 | 提交后不丢 | 依赖日志刷盘 |
| 脏读 | 读到未提交数据 | 最危险异常之一 |
| 不可重复读 | 同一事务两次读结果不同 | RC 常见 |
| 幻读 | 范围查询新增“幻影行” | 需要更强隔离 |
| MVCC | 多版本并发控制 | 读多写少场景常用 |
| WAL | 预写日志 | 先记日志再落数据 |
| 死锁 | 互相等待锁释放 | 必须检测并回滚 |
| 两阶段提交(单库) | 锁资源->提交 | 常见事务流程 |

## 4. 需求澄清（功能/非功能/不做/SLO）
### 4.1 功能需求
1. 事务 begin/commit/rollback。  
2. 隔离级别控制（RC/RR 等）。  
3. 锁管理与死锁检测。  
4. 崩溃恢复（WAL 重放）。  
5. 事务状态查询与审计。

### 4.2 非功能需求
1. 核心事务正确性优先。  
2. 并发吞吐可接受。  
3. 长事务可治理。  
4. 故障恢复可演练。

### 4.3 不做范围
1. 不做跨地域强一致共识协议。  
2. 不做完整分布式事务框架。  
3. 不做数据库内核全部实现细节。

### 4.4 SLO
1. 核心事务 P95 < 80ms。  
2. 提交成功率 >= 99.99%。  
3. 死锁自动恢复 < 1s。  
4. 崩溃恢复 RTO < 10min。

## 5. 容量估算（数字推导）
1. 峰值事务 `20k TPS`，每事务平均 3 次写。  
2. WAL 日志写入约 `60k events/s`，需低延迟持久化。  
3. 热点账户行冲突占 5%，高峰可上升到 20%。  
4. 若锁等待 P95 > 200ms，整体吞吐会明显塌陷。  
5. 事务元数据保留 7 天用于审计和回放。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
Tx API -> Tx Manager -> Lock Manager + MVCC -> WAL -> Storage
```

### 6.2 完整版
```text
Client
  -> Tx Gateway
  -> Tx Manager (state machine)
  -> Lock Manager (row/key-range)
  -> MVCC Version Store
  -> WAL Writer (sync/async policy)
  -> Data Engine
  -> Recovery Manager
  -> Deadlock Detector
  -> Metrics/Trace/Audit
```

## 7. API设计（请求/响应/错误码/幂等）
1. `POST /api/v1/tx/begin`  
2. `POST /api/v1/tx/{txId}/commit`  
3. `POST /api/v1/tx/{txId}/rollback`  
4. `GET /api/v1/tx/{txId}`  

错误码：`LOCK_TIMEOUT`、`DEADLOCK_ABORTED`、`TX_NOT_FOUND`、`TX_STATE_INVALID`  
幂等：commit/rollback 接口必须支持重复调用不产生二次副作用。

## 8. 数据模型（实体/索引/分片）
1. `tx_meta(tx_id, state, isolation_level, started_at, ended_at)`  
2. `lock_meta(resource_key, owner_tx, mode, wait_queue)`  
3. `mvcc_row(row_id, begin_ts, end_ts, value)`  
4. `wal_entry(lsn, tx_id, op, payload, created_at)`  
5. `deadlock_event(event_id, victim_tx, graph_snapshot)`  
6. 分片数据库下每分片独立事务，跨分片靠业务补偿。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常
begin -> 读快照 -> 加锁写入 -> 预写WAL -> commit -> 释放锁。

### 9.2 高峰
锁冲突上升 -> 限制长事务 -> 热点行拆分/排队 -> 降低锁等待超时。

### 9.3 故障恢复
节点崩溃重启 -> 扫描WAL -> 重做已提交/回滚未提交 -> 恢复一致状态。

## 10. 一致性与事务边界
1. 单库内事务强一致。  
2. 跨服务不做强事务，使用 outbox + 补偿。  
3. 幂等键保证重试不会重复扣款。  
4. 读写分离场景要标注“读到旧值”的一致性边界。

## 11. 可用性与容错（含RTO/RPO）
1. WAL 多副本持久化，防单盘故障。  
2. 死锁检测线程周期扫描 wait-for graph。  
3. 锁超时自动回滚最小代价事务。  
4. 恢复支持 checkpoint + WAL 回放。  
5. RTO 10min，RPO 接近 0（按刷盘策略）。

## 12. 可观测性（指标 + 阈值 + 动作）
指标：
- `tx_commit_p95_ms`
- `lock_wait_p95_ms`
- `deadlock_count`
- `rollback_ratio`
- `wal_flush_p95_ms`

阈值与动作：
1. `deadlock_count > 100/min` -> P1，触发热点排查和事务顺序治理。  
2. `lock_wait_p95_ms > 200` 持续 10min -> P1，限流+拆热点。  
3. `rollback_ratio > 5%` -> P2，定位超时/冲突根因。  
4. `wal_flush_p95_ms > 20` -> P1，检查磁盘和刷盘策略。

## 13. 安全与合规
1. 事务操作审计可追踪。  
2. 高权限事务管理接口 RBAC。  
3. WAL 和审计日志敏感字段脱敏。  
4. 恢复和回滚操作需审批记录。

## 14. 成本与取舍
1. 强隔离级别正确性高但吞吐更低。  
2. MVCC 提升并发读，但版本存储成本增加。  
3. 同步刷盘安全高但延迟增加。  
4. 锁粒度细性能好但管理复杂。

## 15. Java关键代码（>=5段）
### 15.1 事务状态机
```java
public enum TxState { ACTIVE, COMMITTING, COMMITTED, ABORTING, ABORTED }
```

### 15.2 提交流程（先WAL后提交）
```java
public class TxCommitService {
    public void commit(Transaction tx) {
        if (tx.getState() != TxState.ACTIVE) return; // 幂等提交保护
        tx.toCommitting();
        try {
            wal.append(tx.getChanges());
            wal.flush();
            storage.apply(tx.getChanges());
            tx.toCommitted();
        } catch (Exception e) {
            tx.toAborting();
            storage.compensate(tx.getChanges());
            tx.toAborted();
            throw e;
        } finally {
            lockManager.releaseAll(tx.getId());
        }
    }
}
```

### 15.3 锁申请与超时
```java
public class LockService {
    public boolean acquire(String key, long txId, long timeoutMs) {
        long start = System.currentTimeMillis();
        while (System.currentTimeMillis() - start < timeoutMs) {
            if (lockRepo.tryLock(key, txId)) return true;
        }
        return false;
    }
}
```

### 15.4 死锁检测（简化）
```java
public class DeadlockDetector {
    public boolean hasCycle(Map<Long, List<Long>> waitGraph) {
        Set<Long> visiting = new HashSet<>();
        Set<Long> visited = new HashSet<>();
        for (Long node : waitGraph.keySet()) {
            if (dfs(node, waitGraph, visiting, visited)) return true;
        }
        return false;
    }
    private boolean dfs(Long n, Map<Long, List<Long>> g, Set<Long> visiting, Set<Long> visited) {
        if (visited.contains(n)) return false;
        if (!visiting.add(n)) return true;
        for (Long nxt : g.getOrDefault(n, List.of())) {
            if (dfs(nxt, g, visiting, visited)) return true;
        }
        visiting.remove(n);
        visited.add(n);
        return false;
    }
}
```

### 15.5 恢复重放
```java
public class RecoveryService {
    public void recover() {
        Checkpoint cp = checkpointRepo.latest();
        List<WalEntry> entries = wal.readFrom(cp.getLsn());
        for (WalEntry e : entries) {
            if (e.isCommitted()) storage.redo(e);
            else storage.undo(e);
        }
        checkpointRepo.save(new Checkpoint(wal.latestLsn()));
    }
}
```

## 16. 前端功能代码（React JS >=2段，API协作）
### 16.1 事务监控 API 模块（轮询 + 错误分支）
```javascript
export async function fetchTxMetrics() {
  try {
    const r = await fetch("/api/v1/tx/metrics");
    if (!r.ok) throw new Error(`HTTP_${r.status}`);
    const d = await r.json();
    return { ok: true, items: d.items || [], error: "" };
  } catch (e) {
    return { ok: false, items: [], error: `拉取失败: ${String(e.message || e)}` };
  }
}

export function startMetricsPolling(onData, onError, intervalMs = 3000) {
  const timer = setInterval(async () => {
    const res = await fetchTxMetrics();
    if (res.ok) onData(res.items);
    else onError(res.error);
  }, intervalMs);
  return () => clearInterval(timer);
}
```

### 16.2 回滚 API 模块（幂等键 + 重试）
```javascript
export async function rollbackTx(txId, retry = 0) {
  try {
    const r = await fetch(`/api/v1/tx/${encodeURIComponent(txId)}/rollback`, {
      method: "POST",
      headers: { "Idempotency-Key": `rb-${txId}-${Date.now()}` }
    });
    if (!r.ok) throw new Error(`HTTP_${r.status}`);
    return { ok: true, status: "ROLLED_BACK", error: "" };
  } catch (e) {
    if (retry < 2) return rollbackTx(txId, retry + 1);
    return { ok: false, status: "FAILED", error: `回滚失败: ${String(e.message || e)}` };
  }
}
```

## 17. 测试策略
1. 单测：状态机、锁冲突、死锁检测。  
2. 集成：begin->commit->查询一致。  
3. 并发压测：热点行争用。  
4. 故障注入：崩溃恢复、WAL延迟。  
5. 回归：隔离级别异常场景（脏读/幻读）。

## 18. 丰富例子（>=10）
1. RC 下不可重复读如何出现。  
2. RR 下范围查询幻读如何避免。  
3. 两个账户转账死锁案例。  
4. 长事务导致锁队列堆积。  
5. 事务超时后自动回滚。  
6. WAL盘抖动导致提交变慢。  
7. 重试没幂等导致重复扣减。  
8. 恢复后未提交事务回滚验证。  
9. 热点库存行冲突治理。  
10. 业务补偿与数据库事务边界。  
11. 计划变更导致锁放大。  
12. 审计追踪定位问题事务。

## 19. 面试追问 + 可复述回答
1. RC 和 RR 怎么选？  
可复述：先看业务正确性下限，再看吞吐预算；核心资金链路倾向更高隔离。  

2. 为什么要 WAL 先于数据落盘？  
可复述：崩溃后可按日志恢复，保证提交不丢。  

3. 死锁和锁超时区别？  
可复述：死锁是环形等待，锁超时是等待过长；死锁要检测并回滚牺牲者。

## 20. 新手学习路线
1. 先理解 ACID 和并发异常。  
2. 学锁模型和 MVCC。  
3. 学 WAL 与恢复流程。  
4. 学隔离级别与业务取舍。  
5. 学观测与故障演练。

## 21. 上场前Checklist
- [ ] 能解释三种并发异常及示例。  
- [ ] 能讲清 commit 路径（WAL->数据->状态）。  
- [ ] 能给出死锁治理方案。  
- [ ] 能给出3个告警阈值和动作。  
- [ ] 能讲清与支付系统题的边界。

## 22. 与母题差异（对应 Q84）
### 22.1 对应母题
- Q84 Online Payment System

### 22.2 共性能力
1. 一致性保障。  
2. 幂等与重试。  
3. 故障恢复。  
4. 审计可追踪。

### 22.3 关键差异（>=5条）
1. Q29 是数据库内核能力题，Q84 是业务支付链路题。  
2. Q29 重点在锁/MVCC/隔离级别。  
3. Q84 重点在支付状态机、对账、清结算。  
4. Q29 关注事务语义正确，Q84 关注资金业务正确。  
5. Q29 常作为 Q84 的底层前提能力。

### 22.4 本题新增必补知识（>=5条）
1. 隔离级别与并发异常。  
2. 死锁检测与牺牲者策略。  
3. WAL与恢复重放。  
4. 锁等待与超时治理。  
5. MVCC版本管理。

### 22.5 面试差异话术（3条）
1. “Q29 讲数据库如何保证正确，Q84 讲业务如何利用这些能力保证资金正确。”  
2. “Q29 先讲事务边界，Q84 再讲跨服务补偿。”  
3. “Q29 是底层一致性工具箱，Q84 是业务编排方案。”
