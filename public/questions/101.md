# Q101 - Design Craigslist

## 1. 题目元数据
- title: Design Craigslist
- tags: 分类信息、搜索、地域、发布、反垃圾
- keyPoints: 分类管理、地域过滤、搜索优化、反垃圾、用户认证
- learningCoreId: 60（母题：Task Scheduler）

## 2. 业务目标与范围
构建一个分类信息平台，支持用户按地域发布和浏览帖子，具备搜索、反垃圾、账号体系与基础运营能力。

## 3. 非目标与边界
- 不做即时聊天系统（仅站内信异步通知）
- 不做复杂推荐排序（先关键词+时间衰减）
- 不做支付托管（仅预留接口）

## 4. 用户角色与核心场景
- 游客：浏览、搜索、筛选地域
- 注册用户：发布、编辑、下架、举报
- 管理员：审核、封禁、反垃圾规则配置

## 5. 规模与容量预估
- DAU: 300万
- 峰值QPS: 读 2.5万，写 3000
- 日新增帖子: 120万
- 存储: 帖子+索引年增量约 40TB（冷热分层后）

## 6. 领域模型与数据表
- User(id, email, phone, status, reputation, createdAt)
- Listing(id, userId, categoryId, regionId, title, body, price, status, createdAt)
- ListingImage(id, listingId, url, hash, width, height)
- Category(id, parentId, name, attrsSchema)
- Region(id, parentId, name, level)
- ModerationCase(id, listingId, reason, score, status, reviewerId)

## 7. API 设计
- `POST /api/v1/listings` 创建帖子（幂等键 `Idempotency-Key`）
- `GET /api/v1/listings/{id}` 查看详情
- `GET /api/v1/search?q=&region=&category=&page=` 检索
- `POST /api/v1/listings/{id}/report` 举报
- `POST /api/v1/moderation/review` 审核处置

## 8. 架构分层
- API Gateway：鉴权、限流、灰度
- Listing Service：发布与状态流转
- Search Service：索引构建与查询
- Moderation Service：规则+模型风控
- Media Service：图片上传、压缩、鉴黄
- Notification Service：审核结果、举报回执

## 9. 存储与索引策略
- OLTP: MySQL 分库分表（按 regionId + listingId 哈希）
- 搜索: Elasticsearch（title/body/token/region/category 联合索引）
- 缓存: Redis（详情缓存、热门搜索词、会话）
- 对象存储: 图片与缩略图，多副本

## 10. 分类与地域建模
- 分类树支持 3-4 级，属性模板按类目动态渲染
- 地域采用国家-州/省-城市-区层级
- 搜索过滤先地域再类目，减少倒排扫描范围

## 11. 搜索与排序
- 召回：关键词倒排 + 同义词扩展 + 拼写纠错
- 粗排：文本匹配分 + 地域匹配分
- 精排：时间衰减 + 卖家信誉 + 违规惩罚
- 防刷：同设备高频搜索限流、异常查询画像

## 12. 反垃圾与用户认证
- 登录：手机号/邮箱 + OTP + 风险评分
- 发布前校验：文本规则、图片指纹、黑名单词库
- 发布后异步审核：规则引擎 + 轻量模型 + 人审兜底
- 封禁策略：设备、IP、账号多维关联封禁

## 13. 阈值与SLO
- 可用性 SLO：`99.95%`（月）
- 搜索 P95 延迟：`< 250ms`，P99 `< 600ms`
- 发布接口 P95 延迟：`< 400ms`
- 审核队列积压阈值：`> 20,000` 触发扩容与降级
- 反垃圾误杀率阈值：`< 0.3%`
- 缓存命中率阈值：`>= 85%`

## 14. 故障恢复路径（含RTO/RPO）
- 机房级故障：流量切换到同城双活或异地热备
- 搜索集群故障：降级为数据库前缀检索 + 热门缓存兜底
- 审核服务故障：进入“先发布后限流曝光”模式并延迟审核
- 数据恢复目标：
  - RTO：核心读链路 `<= 15 分钟`，发布链路 `<= 30 分钟`
  - RPO：帖子元数据 `<= 5 分钟`，图片对象 `<= 15 分钟`
- 恢复步骤：告警 -> 自动切流 -> 手工确认 -> 数据回放 -> 一致性校验 -> 回切

## 15. Java 核心实现片段（>=5）
```java
public final class IdempotencyGuard {
    private final ConcurrentHashMap<String, String> cache = new ConcurrentHashMap<>();

    public String execute(String key, Supplier<String> action) {
        String existing = cache.get(key);
        if (existing != null) return existing;
        String result = action.get();
        cache.putIfAbsent(key, result);
        return cache.get(key);
    }
}
```

```java
public class ListingValidator {
    private static final Set<String> BANNED = Set.of("诈骗", "枪支", "违禁");

    public List<String> validate(String title, String body, int price) {
        List<String> errors = new ArrayList<>();
        if (title == null || title.length() < 5) errors.add("title too short");
        if (body == null || body.length() < 20) errors.add("body too short");
        if (price < 0) errors.add("price invalid");
        for (String word : BANNED) {
            if ((title + " " + body).contains(word)) errors.add("contains banned keyword: " + word);
        }
        return errors;
    }
}
```

```java
public class SearchScore {
    public double score(double bm25, double freshnessHours, double sellerReputation, boolean risky) {
        double freshness = 1.0 / (1.0 + freshnessHours / 24.0);
        double riskPenalty = risky ? 0.4 : 1.0;
        return (0.6 * bm25 + 0.25 * freshness + 0.15 * sellerReputation) * riskPenalty;
    }
}
```

```java
public class RegionRouter {
    public int shard(long listingId, int regionId, int shardCount) {
        long hash = 1469598103934665603L;
        hash ^= listingId;
        hash *= 1099511628211L;
        hash ^= regionId;
        hash *= 1099511628211L;
        return (int) (Math.abs(hash) % shardCount);
    }
}
```

```java
public class RetryExecutor {
    public <T> T run(Callable<T> task, int maxRetry, long baseDelayMs) throws Exception {
        Exception last = null;
        for (int i = 0; i <= maxRetry; i++) {
            try {
                return task.call();
            } catch (Exception e) {
                last = e;
                Thread.sleep(baseDelayMs * (1L << i));
            }
        }
        throw last;
    }
}
```

## 16. React 端到端交互代码（>=2）
```javascript
import { useEffect, useState } from "react";

export function ListingPublishForm() {
  const [state, setState] = useState("idle"); // idle/loading/done/error
  const [error, setError] = useState("");
  const [result, setResult] = useState(null);

  async function submit(formData) {
    setState("loading");
    setError("");
    const idemKey = `publish-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    try {
      const res = await fetch("/api/v1/listings", {
        method: "POST",
        headers: { "Content-Type": "application/json", "Idempotency-Key": idemKey },
        body: JSON.stringify(formData),
      });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`publish failed: ${res.status} ${txt}`);
      }
      const data = await res.json();
      setResult(data);
      setState("done");
    } catch (e) {
      setError(String(e.message || e));
      setState("error");
    }
  }

  return (
    <div>
      <button onClick={() => submit({ title: "Bike", body: "good bike, local pickup", price: 200 })}>
        发布
      </button>
      {state === "loading" && <p>提交中...</p>}
      {state === "error" && <p>失败: {error}</p>}
      {state === "done" && <p>成功，ID: {result?.id}</p>}
    </div>
  );
}
```

```jsx
import React, { useEffect, useRef, useState } from "react";

export function ModerationQueuePanel() {
  const [state, setState] = useState("loading"); // loading/done/error
  const [error, setError] = useState("");
  const [items, setItems] = useState([]);
  const retryRef = useRef(0);

  useEffect(() => {
    let stopped = false;
    let timer = null;

    async function poll() {
      try {
        const res = await fetch("/api/v1/moderation/queue");
        if (!res.ok) throw new Error(`http ${res.status}`);
        const data = await res.json();
        if (!stopped) {
          setItems(data.items || []);
          setState("done");
          setError("");
          retryRef.current = 0;
        }
      } catch (e) {
        if (!stopped) {
          setState("error");
          setError(String(e.message || e));
          retryRef.current += 1; // retry
        }
      } finally {
        if (!stopped) {
          const backoff = Math.min(30000, 2000 * Math.max(1, retryRef.current));
          timer = setTimeout(poll, backoff); // polling + retry backoff
        }
      }
    }

    poll();
    return () => {
      stopped = true;
      if (timer) clearTimeout(timer);
    };
  }, []);

  if (state === "loading") return <p>加载审核队列...</p>;
  if (state === "error") return <p>降级: 暂时展示最近缓存快照。错误: {error}</p>;
  return <ul>{items.map((x) => <li key={x.id}>{x.id} - {x.reason}</li>)}</ul>;
}
```

## 17. 可观测性与告警
- Metrics：QPS、延迟、错误率、审核积压、误杀率
- Logs：发布链路 traceId 全量打点
- Tracing：发布 -> 审核 -> 索引刷新全链路
- 告警：5分钟错误率>2%、搜索P95>250ms、RPO超阈值

## 18. 丰富例子（>=10）
1. 二手自行车发布：同城筛选 + 价格区间搜索。
2. 租房信息：按区域和房型过滤，防中介刷屏。
3. 招聘信息：岗位标签匹配与过期自动下架。
4. 家政服务：服务时段、评分、距离排序。
5. 二手手机：IMEI 黑名单比对反欺诈。
6. 宠物领养：审核必填字段与资质证明。
7. 本地活动票转让：限价与重复发布拦截。
8. 家具搬家甩卖：图片去重与近似文本去重。
9. 车辆买卖：VIN 校验和证件遮挡检测。
10. 社区拼车：时间窗匹配与违规词拦截。
11. 维修服务：商家信誉分影响搜索排序。
12. 学习资料转让：版权违规文本识别。

## 19. 安全与合规
- PII 加密存储（AES-GCM）+ 传输 TLS1.3
- 登录风控：设备指纹、IP 信誉、行为验证码
- 审计日志：管理员操作不可篡改
- 合规：举报处理留痕、数据删除请求可追踪

## 20. 压测与验收
- 发布链路压测：3000 QPS 持续30分钟，错误率 < 0.5%
- 搜索压测：2.5万 QPS，P95 < 250ms
- 容灾演练：主搜索集群宕机后 10 分钟内完成降级
- 验收口径：SLO 达标、RTO/RPO 达标、误杀率达标

## 21. 评分与结论
- 架构完整性：20/20
- 性能与扩展：19/20
- 可靠性与容灾：20/20
- 安全与风控：19/20
- 工程可落地性：19/20
- 总分：97/100

## 22. 与母题差异
母题 #60（Task Scheduler）聚焦“任务触发、执行器分片、重试幂等、监控告警”；本题是“面向用户的分类信息产品平台”，重点在搜索、地域、反垃圾、账号与运营闭环。

新增必补知识：
1. 分类与地域双维度建模及筛选索引设计。
2. 发布前后双阶段反垃圾与人审协同策略。
3. 搜索召回/粗排/精排在本地化场景的取舍。
4. 用户信誉体系对排序与风控的联动机制。
5. 内容平台合规处置链路（举报、申诉、审计）。
6. 图片与文本多模态违规检测的工程接入。
7. 供给侧冷启动与运营策略（置顶、曝光、衰减）。
