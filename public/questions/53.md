# Q53 Design Conference Room Booking System

> 来源校验（questions.ts）  
> `title`: Design Conference Room Booking System  
> `tags`: 日历集成, 冲突检测, 资源管理, 提醒通知, 会议室  
> `keyPoints`: 时间冲突检测, 日历同步, 资源管理, 提醒通知, 审批流程  
> `learningCoreId`: 11（母题：订票系统）

## 1. 三句话题目本质
1. 这题核心是“在多人并发下正确预订共享资源（会议室）”。
2. 难点是时间冲突检测、并发锁定、日历同步和取消补偿。
3. 高分回答要把预占、确认、释放、通知、审计闭环讲完整。

## 2. 一个真实场景故事
某公司 3 万员工，周一上午会议预订冲突频发，用户看到“可预订”但提交后失败。根因是可用性查询和提交不在同一并发控制路径。改成“短暂 hold + 超时释放 + 最终确认”后，冲突投诉下降 80%，并通过 MQ 异步通知提升整体体验。

## 3. 术语白话表（>=10）
1. Time Slot：时间片（如 30 分钟粒度）。
2. Hold：短时预占，不等于最终预订。
3. Confirm：确认预订，锁定资源。
4. Expire Release：预占超时自动释放。
5. Overbooking：超订。
6. Calendar Sync：和企业日历双向同步。
7. Recurring Booking：周期性预订。
8. Approval Flow：审批流（特殊会议室）。
9. No-show：未到会，用于策略优化。
10. Reminder Job：会前提醒任务。
11. Hot Room：热门会议室（高频预订）。
12. Cold Archive：历史预订冷归档。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 查询可用会议室。
2. 创建 hold、确认预订、取消预订。
3. 支持审批规则和周期性会议。
4. 日历同步和提醒通知。
5. 支持管理员代订和审计。

### 4.2 非功能需求
1. 并发场景不超订。
2. 低延迟可用性查询。
3. 高可用（>=99.95%）。
4. 可追溯和可恢复。

### 4.3 不做范围
1. 不做视频会议系统本身。
2. 不做完整工位预订系统。
3. 不做复杂智能排程算法。

### 4.4 SLO
1. 预订确认成功率 >= 99.9%。
2. 可用性查询 P95 <= 120ms。
3. 超时释放 P95 <= 30s。

## 5. 容量估算（数字推导）
1. 2 万间会议室，工作日预订 200 万次/天。
2. 峰值请求（周一上午）3 万 RPS（查询）+ 3000 RPS（下单）。
3. 每次预订平均 2 小时，按 30 分钟粒度占 4 slots。
4. 每条预订元数据 1KB，日增约 2GB。
5. 提醒通知峰值 1 万条/s，使用 MQ 解耦。
6. 冷热：近 30 天热数据在线，历史归档冷存。

## 6. 架构（简版+完整版）
### 6.1 简版
`Client -> Booking API -> Slot Store -> Calendar + Notify`

### 6.2 完整版
1. Search API：按时间/地点查询可用房间。
2. Booking API：hold/confirm/cancel。
3. Slot Engine：冲突检测与并发锁。
4. Booking DB：预订主数据。
5. Calendar Connector：同步到企业日历。
6. Notification MQ：提醒、变更通知异步发送。
7. Reminder Worker：定时提醒任务。
8. Archive Job：冷热数据分层归档。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 创建预占
`POST /api/room/v1/bookings/hold`

请求：
```json
{
  "requestId": "bk-20260224-001",
  "roomId": "R101",
  "startAt": "2026-02-24T10:00:00Z",
  "endAt": "2026-02-24T11:00:00Z",
  "organizer": "u1001"
}
```

响应：
```json
{
  "holdId": "H9001",
  "expireAt": "2026-02-24T09:59:30Z",
  "status": "HELD"
}
```

### 7.2 确认预订
`POST /api/room/v1/bookings/{holdId}/confirm`

### 7.3 取消预订
`POST /api/room/v1/bookings/{bookingId}/cancel`

错误码：
1. `409_SLOT_CONFLICT`
2. `410_HOLD_EXPIRED`
3. `403_APPROVAL_REQUIRED`
4. `429_BOOKING_RATE_LIMIT`

幂等规则：
1. `requestId` 去重，重复提交返回同 holdId。
2. `confirmId` 去重，防重复确认。

## 8. 数据模型（实体/索引/分片）
1. `booking(booking_id, room_id, start_at, end_at, status, organizer, created_at)`。
2. `booking_hold(hold_id, room_id, start_at, end_at, expire_at, status)`。
3. `room_slot(room_id, slot_ts, booking_id)`（冲突检测核心）。
4. `calendar_sync(booking_id, external_event_id, sync_state)`。
5. `booking_audit(audit_id, actor, action, target_id, ts)`。

索引与分片：
1. `room_id + slot_ts` 唯一索引防超订。
2. 热门楼层房间按 `room_id` 分片缓存可用性。
3. 历史预订按月分区并冷归档。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 用户查询可用房间并发起 hold。
2. hold 成功后在有效期内 confirm。
3. confirm 后写 booking 并推送通知+日历同步。

### 9.2 高峰流程
1. 热门房间启用短期分布式锁和本地缓存。
2. 查询走热点缓存，提交走强一致 slot 检查。
3. 通知与日历同步异步化（MQ），不阻塞确认。

### 9.3 故障恢复流程
1. Calendar 接口故障时记录待同步状态重试。
2. MQ 积压时先保证确认成功，再异步补通知。
3. hold 释放任务重跑，清理过期占用。

## 10. 一致性与事务边界
1. 冲突检测强一致在 `room_slot` 事务内完成。
2. booking 创建与 slot 写入同事务。
3. 日历同步与通知为最终一致（异步补偿）。
4. 取消预订需反向释放 slot 并发送变更事件。
5. 周期会议拆分子事件，单次失败可局部补偿。

## 11. 可用性与容错（含 RTO/RPO）
1. Booking API 多副本。
2. 数据库主从+读写分离。
3. MQ 多副本保障通知任务不丢。
4. RTO：核心预订功能 10 分钟恢复。
5. RPO：预订主数据不丢；通知可分钟级补发。

## 12. 可观测性（指标+阈值+处置动作）
1. `slot_conflict_rate` > 5%：检查热点房间策略。
2. `hold_expire_release_lag_sec` > 30：触发释放任务扩容。
3. `booking_confirm_p95_ms` > 200：排查 DB 锁竞争。
4. `calendar_sync_fail_rate` > 2%：降级异步重试并告警。
5. `notify_mq_lag` > 10 万：扩容通知消费者。
6. `overbook_count > 0`：P0，立即冻结相关房间预订。

## 13. 安全与合规
1. 预订操作按组织权限校验。
2. 审批会议室需审批流。
3. 审计日志保留（谁在何时预订/取消）。
4. 人员信息脱敏展示。
5. 日历同步 token 安全存储。

## 14. 成本与取舍
1. 全量实时同步日历准确但成本高。
2. 异步通知便宜但有延迟。
3. 热点缓存降查询成本但需要失效治理。
4. 取舍：提交链路强一致，外围协作异步补偿。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法：时间冲突检测
```java
public boolean hasConflict(String roomId, Instant start, Instant end) {
    List<Instant> slots = SlotUtil.expand(start, end, Duration.ofMinutes(30));
    for (Instant s : slots) {
        if (slotRepo.exists(roomId, s)) return true;
    }
    return false;
}
```

### 15.2 幂等去重：hold 请求
```java
public HoldResult createHold(HoldReq req) {
    HoldResult existed = idemRepo.find(req.requestId());
    if (existed != null) return existed;
    if (hasConflict(req.roomId(), req.startAt(), req.endAt())) return HoldResult.conflict();
    String holdId = idGen.next();
    holdRepo.insert(holdId, req, Instant.now().plusSeconds(30));
    HoldResult result = HoldResult.ok(holdId);
    idemRepo.save(req.requestId(), result, Duration.ofMinutes(10));
    return result;
}
```

### 15.3 重试退避/失败处理：日历同步
```java
public void syncCalendarWithRetry(String bookingId) {
    long delay = 200;
    for (int i = 0; i < 4; i++) {
        try {
            calendarClient.upsert(bookingId);
            syncRepo.markSuccess(bookingId);
            return;
        } catch (RuntimeException ex) {
            if (i == 3) { syncRepo.markFailed(bookingId, ex.getMessage()); return; }
            sleep(delay);
            delay = Math.min(delay * 2, 2000);
        }
    }
}
```

### 15.4 一致性边界：confirm 事务
```java
@Transactional
public String confirmHold(String holdId, String confirmId) {
    if (confirmRepo.exists(confirmId)) return confirmRepo.getBookingId(confirmId);
    Hold h = holdRepo.getForUpdate(holdId);
    if (h == null || h.isExpired()) throw new IllegalStateException("hold expired");
    String bookingId = idGen.next();
    bookingRepo.insertFromHold(bookingId, h);
    slotRepo.batchInsert(h.roomId(), SlotUtil.expand(h.startAt(), h.endAt(), Duration.ofMinutes(30)), bookingId);
    confirmRepo.save(confirmId, bookingId);
    outboxRepo.insert("BOOKING_CONFIRMED", bookingId);
    return bookingId;
}
```

### 15.5 观测触发/回滚判定
```java
public void guardBookingHealth() {
    long lag = metrics.gauge("hold_expire_release_lag_sec").longValue();
    if (lag > 30) {
        releaseWorker.scaleOut();
        alerting.fire("HOLD_RELEASE_LAG_HIGH", "lag=" + lag);
    }
    long overbook = metrics.gauge("overbook_count").longValue();
    if (overbook > 0) {
        featureSwitch.enable("booking_freeze_hot_rooms");
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 预占+确认调用（loading/error/done）
```javascript
import { useState } from "react";

export function useRoomBooking() {
  const [state, setState] = useState({ phase: "idle", bookingId: "", error: "" });

  async function book(payload) {
    setState({ phase: "loading", bookingId: "", error: "" });
    try {
      const holdReqId = `hold-${Date.now()}-${Math.random().toString(16).slice(2)}`;
      const holdRes = await fetch("/api/room/v1/bookings/hold", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ...payload, requestId: holdReqId })
      });
      if (!holdRes.ok) throw new Error(`HOLD_${holdRes.status}`);
      const hold = await holdRes.json();
      const confirmRes = await fetch(`/api/room/v1/bookings/${hold.holdId}/confirm`, { method: "POST" });
      if (!confirmRes.ok) throw new Error(`CONFIRM_${confirmRes.status}`);
      const booking = await confirmRes.json();
      setState({ phase: "done", bookingId: booking.bookingId, error: "" });
    } catch (e) {
      setState({ phase: "error", bookingId: "", error: String(e.message || e) });
    }
  }

  return { state, book };
}
```

### 16.2 取消预订 API（幂等+重试）
```javascript
export async function cancelBooking(bookingId) {
  const cancelId = `cancel-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 200;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch(`/api/room/v1/bookings/${bookingId}/cancel`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Cancel-Id": cancelId },
        body: JSON.stringify({ cancelId })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 1200);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：冲突检测、hold 过期、确认事务。
2. 集成测试：查询->hold->confirm->日历->通知。
3. 压测：周一高峰并发预订。
4. 故障测试：Calendar 不可用、MQ 积压、DB 锁冲突。
5. 回归测试：审批流、周期会议、取消补偿。

## 18. 丰富例子（>=10）
1. 两人同时抢同一会议室，仅一人成功。
2. hold 超时后自动释放。
3. 确认成功但日历同步失败，稍后补偿成功。
4. 取消后提醒任务自动撤销。
5. 周期会议某次冲突单次失败不影响其它次。
6. 热门房间高峰启用限流。
7. 管理员代订触发审计记录。
8. 通知 MQ 积压时先确认后补通知。
9. 历史会议归档到冷存储。
10. 无人参会策略用于优化资源配置。
11. 冲突率突增触发运维告警。
12. 跨时区会议转换显示正确。

## 19. 面试追问 + 可复述回答
1. 为什么要 hold？
回答：避免用户填表后提交时发现已被占用，先短占再确认更稳。
2. 查询可用与提交为什么不共用同缓存？
回答：查询可用可缓存，提交必须走强一致 slot 事务。
3. 日历同步失败会影响确认吗？
回答：不影响，走异步重试补偿，保证主链路可用。
4. 如何防超订？
回答：`room_id + slot_ts` 唯一约束+事务写入。
5. 与订票母题差异？
回答：本题是时间资源冲突模型，不是座位库存模型。

## 20. 新手学习路线
1. 先做时间片冲突检测。
2. 做 hold+confirm 状态机。
3. 接入日历和通知异步链路。
4. 增加审批与审计。
5. 做高峰压测和故障演练。

## 21. 上场前 Checklist
1. 能解释 hold/confirm 价值。
2. 能讲冲突检测数据结构。
3. 能说出 MQ 在通知链路作用。
4. 能讲冷热数据分层策略。
5. 能和 Q11 清晰区分。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q11 订票系统。

### 22.2 共性能力
1. 都是共享资源预占与确认。
2. 都依赖幂等、超时释放、补偿。
3. 都有高峰并发冲突控制。

### 22.3 关键差异
1. Q11 偏座位库存；Q53 偏时间区间冲突。
2. Q53 更强调日历同步与提醒。
3. Q53 常有审批流程。
4. Q53 热点在时段查询和冲突检测。
5. Q53 对时区处理要求更高。

### 22.4 本题新增知识点（>=5）
1. 时间片冲突检测模型。
2. hold+confirm 事务边界。
3. 日历异步同步补偿。
4. 通知 MQ 解耦与重试。
5. 热点房间与冷归档策略。
6. 周期会议局部失败处理。

### 22.5 面试差异话术
“Q11 是库存型预订题；Q53 是时间冲突型预订题。高分点在时间片模型、日历同步、提醒链路和审批治理。”

---

## 单题自审（Q53）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦会议室预订：通过。
2. API、MQ、冷热分层、补偿代码都有：通过。

### D. 工程落地检查
1. 阈值+动作绑定：通过。
2. RTO/RPO 与恢复路径明确：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端 API 使用与重试幂等体现：通过。

### F. 母题差异检查
1. 与 Q11 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20
总分：96/100（通过）
