# Q19 跳表（Skip List）（中频）

## 1. 三句话题目本质
1. 跳表是“用多层有序链表模拟平衡树性能”的数据结构。  
2. 核心价值是实现简单、范围查询友好、并发改造成本相对可控。  
3. 面试里要讲清：为什么它能做到期望 O(logN)，以及工程上怎么落地。  

## 2. 一个真实场景故事
你维护一个在线排行榜服务，早期用有序数组，每次插入都搬移大量元素，延迟抖动很大。改成跳表后：  
1. 插入/删除/查找平均复杂度降到 O(logN)。  
2. 范围查询仍是顺序链路，遍历效率高。  
3. 结合分片后，服务在高并发写入下更稳定。  

## 3. 术语白话表（新手可懂）
1. Level：层数，越高层节点越少。  
2. Promotion：节点“晋升”到更高层。  
3. Probability p：晋升概率（常用 0.25 或 0.5）。  
4. Head Node：每层的头节点。  
5. Forward Pointer：指向下一节点的指针数组。  
6. Search Path：查找路径。  
7. Span：跨越长度（用于 rank 计算）。  
8. Expected Complexity：期望时间复杂度。  
9. Concurrent Skip List：并发跳表。  
10. CAS：原子比较交换。  
11. Logical Delete：逻辑删除。  
12. Physical Delete：物理摘链。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持按 key 查找。  
2. 支持有序插入、删除。  
3. 支持范围查询（区间扫描）。  
4. 支持按分值排序的 TopK。  
5. 支持并发读写。  

### 4.2 非功能需求
1. 平均低延迟。  
2. 可扩展到百万级节点以上。  
3. 并发下不破坏有序性。  
4. 内存开销可控。  

### 4.3 不做范围
1. 不做磁盘 B+Tree 实现。  
2. 不做事务数据库索引恢复流程。  
3. 不做分布式一致性协议。  

### 4.4 SLO/SLA
1. 查询 P95 < 5ms（内存态）。  
2. 插入 P95 < 8ms。  
3. 范围扫描 1k 项 P95 < 20ms。  

## 5. 容量估算（数字推导）
假设节点数 1000 万，平均层高约 1/(1-p)=2（p=0.5 近似）：  
1. 指针数量约 2000 万级别。  
2. 若每指针 8B，指针内存约 160MB。  
3. 节点元数据+对象开销按 48B，约 480MB。  
4. 总体约 640MB+，还需预留 GC 与碎片空间。  
5. 并发写入 1 万/s 时需控制锁竞争和 GC 抖动。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`API -> SkipList Engine -> 内存管理 -> 监控`

### 6.2 完整版
1. SkipList Core：搜索、插入、删除、范围遍历。  
2. Level Generator：随机层高生成器。  
3. Concurrency Layer：细粒度锁或无锁 CAS。  
4. Snapshot Layer：周期快照与恢复。  
5. Shard Router：多分片时按 key 路由。  
6. Metrics：层高分布、冲突率、延迟。  
7. Integrity Checker：有序性与链路自检。  
8. Rebuild Tool：异常时重建索引。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `PUT /v1/skiplist/node`  
2. `GET /v1/skiplist/node/{key}`  
3. `DELETE /v1/skiplist/node/{key}`  
4. `GET /v1/skiplist/range?start=&end=&limit=`  

请求示例：
```json
{
  "key": "user:1001",
  "score": 9876.5,
  "value": "payload",
  "idempotencyKey": "put-user-1001-20260224"
}
```

错误码：`409_KEY_CONFLICT`、`422_INVALID_SCORE`、`503_ENGINE_BUSY`。  

## 8. 数据模型（实体、索引、分片分区）
1. `skip_node`：`key`、`score`、`value`、`level`、`forward[]`。  
2. `skip_meta`：最大层数、节点数、版本号。  
3. `op_log`：操作日志用于恢复。  
4. `snapshot`：快照文件地址和生成时间。  
5. 分片策略：按 key hash 分片，分片内局部有序。  
6. 索引：分片内按 score+key 有序。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：查找从最高层向下跳，定位插入点后逐层链接。  
2. 高峰：写冲突高时降级为批量写 + 延迟合并。  
3. 故障恢复：加载最近快照 + 回放操作日志。  

## 10. 一致性与事务边界
1. 单分片内保证有序一致。  
2. 跨分片仅最终一致，不保证全局严格排序。  
3. 更新可采用“逻辑删除 + 新节点插入”避免链路破坏。  
4. 崩溃恢复依赖快照+日志重放。  

## 11. 可用性与容错
1. 多副本部署，主从热备。  
2. 节点异常时切换副本。  
3. 自检发现链路断裂时触发局部重建。  
4. 写压力过高时启用回压。  
5. RTO 15 分钟，RPO 1 分钟。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `skiplist_search_p95_ms`  
2. `skiplist_insert_p95_ms`  
3. `level_distribution_entropy`  
4. `lock_conflict_rate`  
5. `integrity_check_fail_count`  

告警阈值：  
1. 插入 P95 > 15ms（10分钟）-> P1。  
2. 锁冲突率 > 20%（10分钟）-> P2。  
3. 自检失败 > 0 立刻 P1。  
4. 层分布异常偏斜持续 30 分钟 -> P2。  

处置：降写入并发 -> 局部重建 -> 切流到备实例。  

## 13. 安全与合规
1. 接口鉴权和访问限流。  
2. 操作日志审计。  
3. 敏感 value 做加密或脱敏。  
4. 管理接口 RBAC。  
5. 快照文件访问控制。  

## 14. 成本与取舍
1. 跳表比平衡树实现简单，但常数因子可能略高。  
2. 指针开销较大，需控制层高与对象分配。  
3. 并发无锁实现复杂，但读写性能更优。  
4. 快照频繁恢复快但资源成本高。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 随机层高生成
```java
public class LevelGenerator {
    private static final int MAX_LEVEL = 16;
    private static final double P = 0.5;

    public int randomLevel() {
        int level = 1;
        while (level < MAX_LEVEL && ThreadLocalRandom.current().nextDouble() < P) {
            level++;
        }
        return level;
    }
}
```

### 15.2 查找路径
```java
public class SkipListSearch {
    public Node find(Node head, double score, String key) {
        Node cur = head;
        for (int lvl = head.level() - 1; lvl >= 0; lvl--) {
            while (cur.forward(lvl) != null && compare(cur.forward(lvl), score, key) < 0) {
                cur = cur.forward(lvl);
            }
        }
        Node n = cur.forward(0);
        return (n != null && n.score() == score && n.key().equals(key)) ? n : null;
    }
}
```

### 15.3 插入节点
```java
public class SkipListInsert {
    public void insert(SkipList sl, Node node) {
        Node[] update = sl.findUpdatePath(node.score(), node.key());
        int lvl = node.level();
        for (int i = 0; i < lvl; i++) {
            node.setForward(i, update[i].forward(i));
            update[i].setForward(i, node);
        }
        sl.incrementSize();
    }
}
```

### 15.4 逻辑删除
```java
public class SkipListDelete {
    public boolean logicalDelete(Node node) {
        return node.deleted().compareAndSet(false, true);
    }
}
```

### 15.5 范围扫描
```java
public class SkipListRangeQuery {
    public List<Node> range(Node start, double maxScore, int limit) {
        List<Node> out = new ArrayList<>();
        Node cur = start;
        while (cur != null && cur.score() <= maxScore && out.size() < limit) {
            if (!cur.deleted().get()) out.add(cur);
            cur = cur.forward(0);
        }
        return out;
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 跳表性能看板（React + TS）
```tsx
type SkipMetrics = { searchP95: number; insertP95: number; lockConflictRate: number };

export function SkipListDashboard() {
  const [m, setM] = useState<SkipMetrics | null>(null);
  useEffect(() => { fetch("/api/skiplist/metrics").then(r => r.json()).then(setM); }, []);
  if (!m) return <div>loading...</div>;
  return <div>查找P95:{m.searchP95}ms 插入P95:{m.insertP95}ms 锁冲突:{m.lockConflictRate}%</div>;
}
```

### 16.2 范围查询调试页（React + TS）
```tsx
export function SkipListRangeDebugPage() {
  const [start, setStart] = useState("0");
  const [end, setEnd] = useState("100");
  const [rows, setRows] = useState<any[]>([]);
  async function run() {
    const r = await fetch(`/api/skiplist/range?start=${start}&end=${end}&limit=50`);
    setRows((await r.json()).items);
  }
  return (
    <div>
      <input value={start} onChange={e => setStart(e.target.value)} />
      <input value={end} onChange={e => setEnd(e.target.value)} />
      <button onClick={run}>查询</button>
      <pre>{JSON.stringify(rows, null, 2)}</pre>
    </div>
  );
}
```

## 17. 测试策略
1. 单测：层高生成、查找/插入/删除正确性。  
2. 集成：并发写入+范围查询一致性。  
3. 压测：百万节点下读写性能。  
4. 故障演练：恢复流程（快照+日志）。  
5. 自检：有序性、无环、层级一致。  

## 18. 丰富例子（面试可复述）
1. 为什么 Redis ZSet 选跳表。  
2. 层高概率如何影响性能。  
3. 并发删除如何避免脏读。  
4. 为什么范围查询跳表比哈希好。  
5. 数据量翻 10 倍如何扩展。  
6. 分片后全局排序怎么做。  
7. 快照间隔如何设置。  
8. 层分布异常如何处理。  
9. 锁冲突高如何降级。  
10. 日志回放过慢怎么优化。  
11. 内存不足如何做冷数据下沉。  
12. 自检失败后如何快速恢复。  

## 19. 面试追问+回答模板
1. 问：跳表和红黑树怎么选？  
答：跳表实现更简单，范围扫描友好，并发改造更灵活；红黑树最坏界更稳。  
2. 问：为什么复杂度是 O(logN)？  
答：每层按概率稀疏，查找路径期望长度与层数成正比，层数约 logN。  
3. 问：并发场景最难点是什么？  
答：节点删除和链路更新的原子性，需要逻辑删除+CAS/锁策略。  

## 20. 新手学习路线
1. 先实现单线程跳表。  
2. 再做范围查询和删除。  
3. 学概率层高与复杂度分析。  
4. 学并发安全改造。  
5. 学快照恢复和监控。  

## 21. 上场前Checklist
1. 能手画跳表查找路径。  
2. 能解释层高概率意义。  
3. 能说明并发删除策略。  
4. 能给出监控阈值。  
5. 能讲出与母题差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q34 Design Redis`。  

### 22.2 共性能力
1. 都涉及内存结构与性能优化。  
2. 都强调高并发读写。  
3. 都要考虑持久化与恢复。  
4. 都有监控和运维需求。  

### 22.3 关键差异
1. Q34 是完整内存数据库设计；Q19 聚焦一个核心数据结构。  
2. Q19 会深讲算法细节，Q34 更讲系统组件协作。  
3. Q19 不展开复制/哨兵/集群治理。  
4. Q34 关注多数据类型，Q19 仅关注有序索引结构。  
5. Q19 常作为面试“底层原理深挖点”。  

### 22.4 本题新增必补知识
1. 概率层高机制。  
2. 跳表复杂度推导。  
3. 并发跳表实现要点。  
4. 范围查询优化。  
5. 完整性自检方法。  

### 22.5 面试差异话术
1. “Q34 是系统题，Q19 是底层结构题。”  
2. “答 Q19 要落到节点、层高、指针和并发更新细节。”  
3. “Q19 讲透后，能支撑你解释 Redis ZSet 的设计取舍。”  
