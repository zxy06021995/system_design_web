# Q50 Design API Rate Limiter

> 来源校验（questions.ts）  
> `title`: Design API Rate Limiter  
> `tags`: 令牌桶, 漏桶, 滑动窗口, 分布式限流, API保护  
> `keyPoints`: 令牌桶算法, 滑动窗口, 分布式限流, 限流策略, 降级处理  
> `learningCoreId`: 16（母题：RateLimiter + Grafana）

## 1. 三句话题目本质
1. 这题本质是“在网关入口控制流量，保护后端不被打垮”。
2. 难点在多维度限流（用户/IP/API/租户）和分布式一致性。
3. 高分回答要同时讲算法、工程接入、监控阈值和降级策略。

## 2. 一个真实场景故事
某开放平台一次营销活动把 `/api/pay` 打到平时 6 倍流量，数据库连接池耗尽。上线分层限流后：网关做全局令牌桶，业务服务做租户滑窗，热点 IP 黑名单快速封禁，后端错误率从 18% 降到 1.2%。

## 3. 术语白话表（>=10）
1. Token Bucket：按速率补充令牌，允许突发。
2. Leaky Bucket：固定速率出水，平滑流量。
3. Sliding Window：滑动窗口计数，控制更精细。
4. Fixed Window：固定时间窗计数，简单但边界抖动。
5. Burst：突发流量容量。
6. Quota：配额限制（按天/小时）。
7. Global Limit：全局限流。
8. Per-Key Limit：按用户或 API 的限流。
9. Fail Open：限流服务异常时放行。
10. Fail Closed：限流异常时拒绝。
11. Shadow Rule：影子规则，只观测不生效。
12. Warm/Cold Key：热门限流 key 与冷门 key。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持全局、API、用户、IP 多维限流。
2. 支持令牌桶和滑窗策略。
3. 支持规则动态下发与灰度生效。
4. 支持超限响应与重试提示。
5. 支持限流日志和审计。

### 4.2 非功能需求
1. 决策延迟 P95 <= 2ms。
2. 网关可用性 >= 99.99%。
3. 规则变更可秒级生效。
4. 高峰下不拖慢主请求链路。

### 4.3 不做范围
1. 不做完整 WAF 攻击防护体系。
2. 不做复杂计费系统。
3. 不做跨云全局强一致限流。

### 4.4 SLO
1. `rate_limit_decision_p95_ms <= 2`
2. `protected_api_5xx_rate <= 1%`
3. `rule_publish_delay_p95 <= 3s`

## 5. 容量估算（数字推导）
1. 网关峰值 150 万 RPS。
2. 每请求至少 1 次限流决策，决策吞吐同量级。
3. 热门 key 1 万 QPS，冷 key 百万级稀疏分布。
4. 若每个 key 状态 64B，热 key 100 万约 64MB，适合内存。
5. 分布式模式下 Redis 操作约 30 万 ops/s（仅热点同步）。
6. 结论：本地缓存+分层限流是必须，全部远程判定会超时。

## 6. 架构（简版+完整版）
### 6.1 简版
`Client -> API Gateway(Limiter) -> Service`

### 6.2 完整版
1. Gateway Limiter：本地令牌桶（纳秒级判定）。
2. Distributed Counter：Redis/内存集群维护热点全局配额。
3. Rule Control Plane：规则管理、灰度发布、版本控制。
4. Sync Channel：规则推送（SSE）+ 拉取兜底。
5. Audit/Metrics MQ：限流命中异步写日志（MQ 解耦）。
6. Hot Key Cache：热点 key 快路径。
7. Cold Key Store：冷 key 延迟初始化，TTL 回收。
8. Dashboard：可视化阈值和告警。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 规则发布
`POST /api/limiter/v1/rules/publish`

请求：
```json
{
  "ruleId": "r-pay-user",
  "scope": "user:/api/pay",
  "algo": "TOKEN_BUCKET",
  "ratePerSec": 50,
  "burst": 100,
  "changeId": "rl-20260224-001"
}
```

### 7.2 限流判定（网关内部）
`POST /internal/limiter/v1/decide`

响应：
```json
{
  "allow": false,
  "reason": "TOKEN_EXHAUSTED",
  "retryAfterMs": 200
}
```

错误码：
1. `429_RATE_LIMITED`
2. `422_INVALID_RULE`
3. `409_RULE_VERSION_CONFLICT`
4. `503_LIMITER_DEGRADED`

幂等规则：
1. 规则发布用 `changeId` 防重复。
2. 判定接口纯读写状态，不依赖请求幂等。

## 8. 数据模型（实体/索引/分片）
1. `limit_rule(rule_id, scope, algo, rate, burst, status, version)`。
2. `hot_bucket(rule_id, key_hash, tokens, last_refill_ts)`。
3. `window_counter(rule_id, key_hash, bucket_ts, count)`。
4. `limit_event(event_id, rule_id, key_hash, action, ts)`。
5. `rule_audit(audit_id, actor, change_id, detail, ts)`。

分片与冷热：
1. 热 key 放本地 LRU + Redis 热分片。
2. 冷 key 只在首次访问时创建状态并设置短 TTL。
3. `window_counter` 按时间桶分区，过期自动清理。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 网关拿请求 key（userId/api/ip）。
2. 先走本地令牌桶判定，命中热 key 再校验全局配额。
3. 放行请求并异步记录限流事件到 MQ。

### 9.2 高峰流程
1. 开启分层限流（全局->租户->用户->IP）。
2. 热 key 进入专用隔离桶，避免拖慢普通流量。
3. 对低优先级 API 执行更严格阈值，保护核心接口。

### 9.3 故障恢复流程
1. Redis 异常时切本地兜底（fail-open/fail-closed 按 API 配置）。
2. 规则同步中断时继续用最后稳定版本。
3. 恢复后回放 MQ 审计事件，补齐报表。

## 10. 一致性与事务边界
1. 限流是近实时控制，允许轻微最终一致。
2. 规则发布强一致（版本号+CAS）。
3. 判定状态与审计日志分离，日志失败不影响判定。
4. 分布式计数可有短暂误差，核心 API 可加严（强同步模式）。
5. 关键阈值变更必须审批，防误配。

## 11. 可用性与容错（含 RTO/RPO）
1. 网关本地限流确保 Redis 故障时仍可运行。
2. 规则中心多副本部署。
3. MQ 异步日志防止主链路阻塞。
4. RTO：限流控制平面 10 分钟恢复。
5. RPO：审计日志分钟级补偿；限流状态可重建。

## 12. 可观测性（指标+阈值+处置动作）
1. `rate_limit_decision_p95_ms > 2`：启用本地快路径并排查远程调用。
2. `limited_request_ratio` 突增 > 3 倍：排查恶意流量或误配置。
3. `protected_api_5xx_rate > 1%`：收紧上游限流。
4. `rule_sync_lag_sec > 3`：切换拉取模式并告警。
5. `redis_limiter_error_rate > 1%`：触发降级策略。
6. `hot_key_top1_ratio > 30%`：启用 key 分流与专桶策略。

## 13. 安全与合规
1. 规则修改权限最小化，操作留痕。
2. 限流事件脱敏（哈希化用户标识）。
3. 管理接口签名与 mTLS。
4. 防刷策略与封禁策略联动。
5. 高风险规则需双审批与回滚预案。

## 14. 成本与取舍
1. 全远程判定最准确但延迟高。
2. 全本地判定最快但跨节点误差大。
3. 取舍：本地快判 + 热 key 远程校准 + 冷 key TTL 回收。
4. MQ 全量日志成本高，可对低风险 API 采样。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法：本地令牌桶
```java
public boolean allow(TokenBucket b, long nowMs) {
    long delta = nowMs - b.lastRefillMs();
    long refill = (delta * b.ratePerSec()) / 1000;
    long tokens = Math.min(b.capacity(), b.tokens() + refill);
    if (tokens <= 0) return false;
    b.setTokens(tokens - 1);
    b.setLastRefillMs(nowMs);
    return true;
}
```

### 15.2 幂等去重：规则发布 changeId
```java
public PublishResult publishRule(RulePublishReq req) {
    if (publishRepo.existsChange(req.changeId())) return PublishResult.duplicate();
    ruleRepo.casUpdate(req.ruleId(), req.version(), req.toRule());
    publishRepo.save(req.changeId(), req.ruleId(), req.version());
    return PublishResult.ok();
}
```

### 15.3 重试退避/失败处理：远程限流校准
```java
public boolean checkGlobalQuota(String key) {
    long backoff = 5;
    for (int i = 0; i < 3; i++) {
      try { return redisLimiter.allow(key); }
      catch (RuntimeException ex) {
        if (i == 2) return fallbackPolicy.allowOnError(key);
        sleep(backoff);
        backoff *= 2;
      }
    }
    return true;
}
```

### 15.4 一致性边界：热点 key 同步窗口
```java
@Transactional
public void syncHotKeyWindow(String ruleId, String keyHash, long bucketTs, long delta) {
    windowRepo.upsert(ruleId, keyHash, bucketTs, delta);
    outboxRepo.insert("LIMIT_WINDOW_SYNC", ruleId + ":" + keyHash + ":" + bucketTs);
}
```

### 15.5 观测触发/回滚判定
```java
public void guardLimiter() {
    double err = metrics.gauge("redis_limiter_error_rate").value();
    if (err > 0.01) {
        switcher.enable("local_only_mode");
        alerting.fire("LIMITER_DEGRADED", "redisErr=" + err);
    }
    double p95 = metrics.gauge("rate_limit_decision_p95_ms").value();
    if (p95 > 2.0) {
        ruleManager.applyPreset("high_perf_profile");
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 规则发布页面调用（loading/error/done）
```javascript
import { useState } from "react";

export function usePublishLimiterRule() {
  const [state, setState] = useState({ phase: "idle", error: "", result: null });
  async function publish(payload) {
    setState({ phase: "loading", error: "", result: null });
    try {
      const res = await fetch("/api/limiter/v1/rules/publish", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      setState({ phase: "done", error: "", result: await res.json() });
    } catch (e) {
      setState({ phase: "error", error: String(e.message || e), result: null });
    }
  }
  return { state, publish };
}
```

### 16.2 限流指标轮询（高峰退避）
```javascript
export async function pollLimiterMetrics(onData) {
  let wait = 2000;
  for (let i = 0; i < 30; i++) {
    try {
      const res = await fetch("/api/limiter/v1/metrics");
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      onData(await res.json());
      wait = 2000;
    } catch {
      wait = Math.min(wait * 2, 15000);
    }
    await new Promise((r) => setTimeout(r, wait));
  }
}
```

## 17. 测试策略
1. 单元测试：令牌桶、滑窗边界与时钟误差。
2. 集成测试：网关接入、规则下发、生效时延。
3. 压测：150 万 RPS 下判定延迟。
4. 故障测试：Redis 不可用、规则中心故障、MQ 积压。
5. 回归测试：误限流率、漏限流率、保护效果。

## 18. 丰富例子（>=10）
1. `/api/login` 每 IP 每分钟 30 次。
2. `/api/pay` 每用户每秒 20 次。
3. 租户 A 峰值活动临时放宽配额。
4. 热 key 隔离桶防止拖垮全局。
5. Redis 异常时核心 API fail-closed。
6. 公共查询 API fail-open 保持可用。
7. 规则影子发布先观测后生效。
8. 网关扩容后自动同步规则快照。
9. 审计发现误配后一键回滚。
10. 冷 key 自动过期降低内存占用。
11. MQ 积压时降采样日志事件。
12. 恶意 IP 激增触发黑名单联动。

## 19. 面试追问 + 可复述回答
1. 令牌桶和滑窗怎么选？
回答：令牌桶控突发更好，滑窗控制边界更精细，常组合使用。
2. 分布式限流为什么会不准？
回答：多节点并发与同步延迟会有误差，核心接口需强校准。
3. 限流服务挂了怎么办？
回答：按 API 风险级别选 fail-open 或 fail-closed，并可快速切换。
4. 为什么要 MQ 记录限流事件？
回答：避免同步写日志拖慢请求，同时保留可追溯审计。
5. 怎么处理冷热 key？
回答：热 key 常驻并远程校准，冷 key 按需创建并 TTL 回收。

## 20. 新手学习路线
1. 先实现单机令牌桶。
2. 再实现滑动窗口计数。
3. 接入网关与规则管理。
4. 增加分布式校准、降级策略。
5. 最后补监控与压测。

## 21. 上场前 Checklist
1. 能画出网关限流链路。
2. 能解释 fail-open/fail-closed 取舍。
3. 能给出高峰阈值和处置动作。
4. 能说明 MQ 与审计的关系。
5. 能解释热/冷 key 管理。
6. 能和母题 Q16 区分。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q16 RateLimiter + Grafana。

### 22.2 共性能力
1. 都关注限流算法与保护后端。
2. 都依赖监控告警。
3. 都要处理高峰冲击。

### 22.3 关键差异
1. Q16 偏算法+监控教学；Q50 偏网关实战接入。
2. Q50 更强调多维限流和分布式策略。
3. Q50 更强调规则灰度发布与审计。
4. Q50 包含 fail-open/fail-closed 的业务决策。
5. Q50 更强调冷热 key 与成本治理。

### 22.4 本题新增知识点（>=5）
1. 网关分层限流策略。
2. 热 key 专桶与远程校准。
3. 规则动态发布与版本控制。
4. 审计 MQ 异步化设计。
5. fail-open/fail-closed 业务分级。
6. 冷 key TTL 回收机制。

### 22.5 面试差异话术
“Q16 让我掌握限流算法；Q50 要把算法落地到网关生产环境，重点是多维规则、降级策略和观测闭环。”

---

## 单题自审（Q50）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦 API 限流实战：通过。
2. 算法+网关+降级+观测链路完整：通过。

### D. 工程落地检查
1. 阈值+动作绑定：通过。
2. 含高峰、MQ、冷热 key 策略：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端 API 使用与高峰轮询体现：通过。

### F. 母题差异检查
1. 与 Q16 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20
总分：96/100（通过）
