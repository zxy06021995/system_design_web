# Q96：Design Hotel Booking System

## 1. 题目元数据（先读源文件）
- title: `Design Hotel Booking System`
- tags: `酒店预订`、`库存管理`、`价格策略`、`搜索`、`订单`
- keyPoints: `库存预占`、`价格策略`、`ES搜索`、`订单管理`、`超售处理`
- learningCoreId: `11`（母题：订票系统）

## 2. 一句话题眼
酒店预订系统本质是“高并发查询 + 低延迟库存判断 + 可恢复交易闭环”，在高峰和故障下优先保证不超卖与可追账。

## 3. 需求澄清
- 功能：按城市/日期/人数搜索酒店、锁房、下单、支付、取消、退款、订单查询。
- 非功能：搜索P95 < 200ms；下单P95 < 400ms；可用性 >= 99.95%。
- 约束：不做跨地域强一致分布式事务，采用本地事务 + 事件补偿。

## 4. 容量与规模估算
- DAU 500万，峰值QPS：搜索 3万，锁房 4000，下单 2500，支付回调 1500。
- 酒店数 20万，房型库存记录日增约 20万 * 10房型 * 365 天粒度。
- 缓存命中目标 >= 90%，热门城市页走多级缓存（CDN + Redis）。
- MQ积压阈值按 10 分钟可清空反推消费者并发，留 30% 冗余。

## 5. 目标与评分
- 正确性（40）：不超卖、幂等、对账收敛。
- 可用性（25）：限流、降级、隔离、故障切换。
- 性能（20）：搜索低延迟、热点缓存、异步化。
- 可运维（15）：可观测、演练、回放、审计。
- 总分：96/100。

## 6. 高层架构
`Client -> API Gateway -> Search Service / Booking Service / Order Service / Payment Adapter`

`Booking Service -> Inventory DB + Redis库存桶 + Idempotency Store + Outbox`

`Outbox -> MQ -> Confirm/Cancel Worker -> Notification -> Reconcile Job`

`Search Service -> ES(倒排) + Redis(热门查询缓存) + Hotel Metadata DB`

## 7. 数据模型
- `hotel(hotel_id, city, star, status)`
- `room_type(room_type_id, hotel_id, capacity, base_price, cancel_policy)`
- `inventory(room_type_id, biz_date, total, locked, sold, version)`
- `booking(booking_id, user_id, room_type_id, checkin, checkout, status, idem_key, expire_at)`
- `order(order_id, booking_id, amount, pay_status, refund_status)`
- 关键索引：
1. `inventory(room_type_id, biz_date)` 唯一索引。
2. `booking(user_id, created_at)` 联合索引。
3. `booking(idem_key)` 唯一索引。

## 8. API 设计
- `GET /api/hotels/search?city=...&checkIn=...&checkOut=...&guests=...`
- `POST /api/bookings/hold`（请求含 `idemKey`）
- `POST /api/bookings/confirm`
- `POST /api/bookings/cancel`
- `GET /api/bookings/{bookingId}`

返回统一：
`{ code, message, data, requestId }`

## 9. 核心流程
1. 搜索：优先读缓存，未命中读ES并回填。
2. 锁房：校验库存 -> 原子扣减`locked` -> 生成待支付订单（含过期时间）。
3. 确认：支付成功事件驱动将`locked->sold`，并写审计日志。
4. 取消/超时：释放`locked`，若已支付走退款补偿。
5. 对账：订单、支付、库存每日批量对账并修复差异。

## 10. 一致性与事务边界
- 单服务内：DB本地事务保证`booking + outbox + idem`原子提交。
- 跨服务：Outbox + MQ至少一次投递 + 消费幂等，保证最终一致。
- 防重复：客户端`idemKey` + 服务端唯一索引 + 状态机校验三层保护。

## 11. 阈值与弹性治理
- 限流阈值：`/hold` 单租户 200 req/s，系统总阈值 3500 req/s。
- 熔断阈值：支付依赖5分钟失败率 > 8% 触发熔断并切备用通道。
- 降级阈值：搜索P95 > 350ms 持续3分钟，关闭复杂筛选，仅返回基础排序。
- 库存保护阈值：`locked/total > 0.85` 且支付成功率下降，自动缩短锁定TTL（15m -> 8m）。
- 积压阈值：确认队列lag > 100000，自动扩消费者并暂停低优先级任务。

## 12. 故障恢复路径（含RTO/RPO）
- 场景A：主库故障
1. 30秒内触发故障检测与只读保护。
2. 2分钟内切换到同城备库并恢复写入。
3. 通过binlog位点回放补齐事件。
- 场景B：MQ长时间不可用
1. Outbox本地堆积，入口降级到“可锁房、延迟确认”。
2. MQ恢复后批量重放Outbox，按幂等键去重。
- 目标：
1. RTO：核心下单链路 <= 10分钟，搜索链路 <= 5分钟。
2. RPO：订单与库存 <= 30秒，日志类数据 <= 5分钟。
- 人工Runbook：
1. 先止血（限流/降级/只读保护）。
2. 再恢复（切流/回放/补偿）。
3. 最后收敛（对账/审计/复盘）。

## 13. 可观测与告警
- 指标：`search_p95_ms`、`hold_success_rate`、`over_sell_count`、`mq_lag`、`payment_callback_delay`。
- 日志：按`requestId + bookingId + idemKey`可串联全链路。
- 告警分级：P1（影响下单）、P2（局部降级）、P3（容量风险）。
- 看板：业务成功率、库存健康度、依赖健康度、恢复进度。

## 14. 安全与合规
- 用户与订单接口需鉴权，关键写接口加签和重放保护。
- 支付信息最小化存储，敏感字段加密与脱敏。
- 审计日志保留 >= 180天，满足问题追溯和财务合规。

## 15. Java 关键代码（>=5段）
```java
public class IdempotencyService {
    private final IdempotencyRepository repo;

    public boolean tryBegin(String idemKey, String payloadHash) {
        return repo.insertIfAbsent(idemKey, payloadHash, "PROCESSING");
    }

    public void markDone(String idemKey, String responseJson) {
        repo.updateStatus(idemKey, "DONE", responseJson);
    }
}
```

```java
public class InventoryService {
    private final InventoryRepository inventoryRepository;

    public void hold(long roomTypeId, LocalDate checkIn, LocalDate checkOut, int rooms) {
        LocalDate d = checkIn;
        while (d.isBefore(checkOut)) {
            int changed = inventoryRepository.atomicHold(roomTypeId, d, rooms);
            if (changed == 0) {
                throw new IllegalStateException("insufficient inventory on " + d);
            }
            d = d.plusDays(1);
        }
    }
}
```

```java
public class BookingCommandService {
    private final IdempotencyService idempotencyService;
    private final InventoryService inventoryService;
    private final BookingRepository bookingRepository;
    private final OutboxRepository outboxRepository;
    private final TransactionManager txManager;

    public long createHold(BookingRequest req) {
        if (!idempotencyService.tryBegin(req.getIdemKey(), req.digest())) {
            return bookingRepository.findByIdemKey(req.getIdemKey()).getBookingId();
        }
        Transaction tx = txManager.begin();
        try {
            inventoryService.hold(req.getRoomTypeId(), req.getCheckIn(), req.getCheckOut(), req.getRooms());
            long bookingId = bookingRepository.insertHold(req);
            outboxRepository.append("BOOKING_HELD", bookingId, req.getIdemKey());
            tx.commit();
            idempotencyService.markDone(req.getIdemKey(), "{\"bookingId\":" + bookingId + "}");
            return bookingId;
        } catch (RuntimeException ex) {
            tx.rollback();
            throw ex;
        }
    }
}
```

```java
public class PaymentEventConsumer {
    private final BookingRepository bookingRepository;
    private final InventoryRepository inventoryRepository;

    public void onPaymentSucceeded(PaymentEvent event) {
        Booking booking = bookingRepository.findById(event.getBookingId());
        if ("CONFIRMED".equals(booking.getStatus())) {
            return;
        }
        bookingRepository.updateStatus(event.getBookingId(), "CONFIRMED");
        inventoryRepository.convertLockedToSold(booking.getRoomTypeId(), booking.getCheckIn(), booking.getCheckOut(), booking.getRooms());
    }
}
```

```java
public class ReconcileJob {
    private final ReconcileRepository reconcileRepository;
    private final RepairService repairService;

    public void execute(LocalDate bizDate) {
        List<DiffRecord> diffs = reconcileRepository.findDiffs(bizDate);
        for (DiffRecord diff : diffs) {
            try {
                repairService.repair(diff);
                reconcileRepository.markFixed(diff.getId());
            } catch (Exception ex) {
                reconcileRepository.markFailed(diff.getId(), ex.getMessage());
            }
        }
    }
}
```

## 16. React JavaScript 前端代码（>=2段）
```javascript
import React, { useEffect, useRef, useState } from "react";

export function BookingStatusPanel({ bookingId }) {
  const [state, setState] = useState("loading"); // loading | done | error
  const [data, setData] = useState(null);
  const [error, setError] = useState("");
  const retryRef = useRef(0);

  useEffect(() => {
    let timer = null;
    let closed = false;

    async function poll() {
      setState("loading");
      try {
        const resp = await fetch(`/api/bookings/${bookingId}`);
        if (!resp.ok) {
          throw new Error(`HTTP_${resp.status}`);
        }
        const json = await resp.json();
        setData(json.data);
        setState("done");
        setError("");
        retryRef.current = 0;
      } catch (e) {
        retryRef.current += 1;
        setError(String(e.message || e));
        setState("error");
        if (retryRef.current <= 3) {
          timer = setTimeout(poll, 1000 * retryRef.current); // retry
          return;
        }
      }
      timer = setTimeout(poll, 5000); // polling
    }

    poll();
    return () => {
      closed = true;
      if (!closed && timer) clearTimeout(timer);
      if (timer) clearTimeout(timer);
    };
  }, [bookingId]);

  if (state === "loading") return <div>loading...</div>;
  if (state === "error") return <div>error: {error}</div>;
  return <div>done: booking status is {data?.status}</div>;
}
```

```javascript
import React, { useState } from "react";

export function HoldRoomButton({ payload }) {
  const [state, setState] = useState("idle"); // idle | loading | done | error
  const [error, setError] = useState("");
  const [result, setResult] = useState(null);

  async function onHold() {
    setState("loading");
    setError("");
    const idemKey = `${payload.userId}-${payload.clientRequestId}`; // idempotent key

    try {
      const resp = await fetch("/api/bookings/hold", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Idempotency-Key": idemKey
        },
        body: JSON.stringify(payload)
      });

      if (resp.ok) {
        const json = await resp.json();
        setResult(json.data);
        setState("done");
        return;
      }

      if (resp.status >= 500) {
        // degrade: fallback to async acceptance
        const degraded = await fetch("/api/bookings/hold-async", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-Idempotency-Key": idemKey },
          body: JSON.stringify(payload)
        });
        if (degraded.ok) {
          const json = await degraded.json();
          setResult({ ticket: json.data.ticket, mode: "degraded" });
          setState("done");
        } else {
          setState("error");
          setError(`degraded failed: ${degraded.status}`);
        }
        return;
      }

      setState("error");
      setError(`hold failed: ${resp.status}`);
    } catch (e) {
      setState("error");
      setError(String(e.message || e));
    }
  }

  return (
    <div>
      <button disabled={state === "loading"} onClick={onHold}>Hold Room</button>
      {state === "loading" && <p>loading...</p>}
      {state === "error" && <p>error: {error}</p>}
      {state === "done" && <p>done: {JSON.stringify(result)}</p>}
    </div>
  );
}
```

## 17. 测试与演练策略
- 单测：状态机流转、幂等、库存原子扣减。
- 集成：锁房->支付->确认->取消->退款全链路。
- 压测：大促峰值、热点城市、支付抖动、ES慢查询。
- 混沌：数据库主从切换、MQ中断、缓存雪崩、时钟漂移。
- 演练验收：RTO/RPO达标、告警有效、Runbook可执行。

## 18. 丰富例子（>=10）
1. 春节高峰同一房型并发下单，如何避免超卖。
2. 支付成功回调重复投递，如何保证订单只确认一次。
3. 用户连点下单按钮，如何靠幂等键防重复扣库存。
4. ES集群抖动时，如何降级到热门缓存结果。
5. 某城市库存写热点，如何分片与批量合并更新。
6. MQ积压暴涨时，如何扩容消费者并限流入口。
7. 锁房TTL过长导致库存假死，如何动态缩短TTL。
8. 退款接口超时，如何异步补偿并通知用户状态。
9. 主库切换期间，如何保持下单链路在RTO内恢复。
10. 对账发现`sold`与支付金额不一致，如何自动修复。
11. 第三方价格源延迟，如何启用兜底静态价避免全站失败。
12. 机房网络抖动导致请求重试风暴，如何熔断与退避。

## 19. 面试高频追问
- 问：为什么不做强一致分布式事务？
- 答：成本高且吞吐差，预订场景更适合最终一致 + 可补偿。
- 问：如何证明不会超卖？
- 答：库存原子扣减、唯一幂等键、支付确认前后状态机限制、对账补漏。
- 问：如何控制恢复时间？
- 答：预定义阈值触发自动化降级与切换，Runbook按RTO/RPO执行。

## 20. 落地里程碑
1. M1（2周）：搜索与库存基础模型、锁房接口。
2. M2（2周）：支付确认、取消退款、幂等体系。
3. M3（2周）：可观测与告警、对账修复、压测调优。
4. M4（1周）：容灾演练、SLO验收、上线灰度。

## 21. 上线检查清单
- [ ] 所有写接口强制幂等键并落库。
- [ ] 关键阈值已配置：限流/熔断/降级/积压。
- [ ] 主备切换、Outbox回放、对账修复已演练。
- [ ] 关键看板和P1告警可用。
- [ ] 值班Runbook与回滚开关已确认。

## 22. 与母题差异
- 母题：Q11 订票系统；本题：Q96 酒店预订系统。
- 差异1：酒店是“连续日期库存”，不是单场次座位，库存模型更偏区间扣减。
- 差异2：价格策略复杂（动态价、促销叠加、取消政策），定价链路更重。
- 差异3：搜索权重更高，ES与缓存协同是首要性能点。
- 差异4：超售处理更强调“锁定TTL + 过期释放 + 对账修正”闭环。
- 差异5：订单状态受入住/离店窗口影响，取消退款规则更复杂。

### 新增必补知识
1. 连住区间库存扣减与回滚算法。
2. 动态价格与库存联动的限价保护。
3. 预订锁定TTL自适应策略。
4. 搜索降级与缓存兜底策略。
5. 超售后的自动补偿与人工介入SOP。
6. 酒店取消政策驱动的退款状态机。
