# Q96：Design Hotel Booking System（95分面试版）

## 1. 三句话题目本质
1. Design Hotel Booking System 的核心是：围绕“酒店预订、库存管理、价格策略”把业务主链路稳定跑通。  
2. 难点在于高峰、故障和多系统协同时，正确性、延迟和成本同时受压。  
3. 面试高分要点：先讲主链路，再讲异常链路，再给出可落地的取舍与演练方案。  

## 2. 一个真实场景故事
预订票务题核心是资源预占与超售控制，难点在并发锁座和超时释放。
在业务高峰时，如果没有分层治理，系统会出现放大性故障。  
本题的关键是把策略、架构、执行和恢复闭环串起来。  

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| 核心链路 | 最不能失败的业务路径 | 先讲清核心链路，再讲优化 |
| SLO | 服务质量目标 | 延迟、可用性、错误率要量化 |
| 幂等 | 重复请求结果一致 | 防重复执行和重试冲突 |
| 补偿 | 失败后的修复动作 | 跨服务一致性关键机制 |
| 降级 | 异常时优先保核心功能 | 先保证可用，再恢复完整能力 |
| 可观测性 | 指标日志追踪完整 | 定位故障必须靠数据 |
| 容量估算 | 按峰值做系统规划 | 平均值不能指导架构上限 |
| 回放修复 | 按范围重算或重放数据 | 保证最终收敛与对账一致 |
| 审计留痕 | 关键操作可追溯 | 便于合规与事故复盘 |
| Runbook | 标准故障处置流程 | 减少值班处理不确定性 |
| 酒店预订 | 酒店预订是该题关键技术点 | 面试要说明酒店预订的边界和取舍 |
| 库存管理 | 库存管理是该题关键技术点 | 面试要说明库存管理的边界和取舍 |
| 价格策略 | 价格策略是该题关键技术点 | 面试要说明价格策略的边界和取舍 |
| 搜索 | 搜索是该题关键技术点 | 面试要说明搜索的边界和取舍 |
| 订单 | 订单是该题关键技术点 | 面试要说明订单的边界和取舍 |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 支持 Hotel Booking System 的核心业务操作链路。
- 支持状态查询、异常处理、审计和运营控制。
- 支持扩展能力与多场景策略配置。

### 4.2 非功能需求
- 核心接口延迟达标（按场景定义 P95）。
- 可用性 >= 99.95%。
- 关键数据一致性可收敛且可追溯。

### 4.3 不做范围
- 不做与本题主目标无关的重型子系统。
- 不做跨区域强一致全局事务，采用可补偿策略。

## 5. 容量估算（含数字推导）
- 按“日常流量 + 峰值倍数 + 故障冗余”做容量规划。  
- 明确入口QPS、异步积压、存储增长和依赖上限。  
- 给出扩容阈值和降级触发线，避免被动救火。  

## 6. 架构（简版+完整版）
### 6.1 简版
```text
Client -> Gateway -> Core Service -> Storage/Cache -> Async Workers
```

### 6.2 完整版
```text
Client -> API Gateway -> Command Service -> State Store
                          -> Policy/Rule Engine -> Risk/Validation
                          -> Outbox/Event Bus -> Async Consumers
                          -> Query Service -> Search/Index
                          -> Metrics/Logs/Trace -> Alerting/Runbook
```

## 7. API 设计（请求/响应示例）
- `POST /booking/hold`
- `POST /booking/confirm`
- `POST /booking/cancel`
- `GET /booking/{id}`

## 8. 数据模型（核心表/索引）
- `booking(order_id,status,expire_at)`
- `seat_hold(seat_id,order_id,state)`
- `inventory_slot(slot_id,remain)`

## 9. 核心流程（>=3条）
1. 资源锁定
2. 支付确认
3. 超时释放和补位

## 10. 一致性与事务边界
- 单服务内使用本地事务保证关键状态一致。  
- 跨服务通过 outbox + 幂等消费 + 补偿任务保证最终一致。  
- 所有重试入口都要带幂等键，避免重复副作用。  

## 11. 可用性与容错
- 依赖异常时优先降级核心能力，避免全链路雪崩。  
- 重试采用指数退避+抖动，防止风暴。  
- 死信队列隔离不可自动修复事件，并提供回放工具。  

## 12. 可观测性（指标+阈值）
- `hold_success_rate`
- `overbook_count`
- `hold_expire_release_lag`
- `confirm_p95_ms`
- 阈值示例：核心延迟超阈值持续 10 分钟触发 P1。  
- 阈值示例：错误率超 0.5% 持续 5 分钟触发 P1。  
- 阈值示例：积压超过基线 2 倍触发 P1。  

## 13. 安全与合规
- 最小权限访问控制 + 全链路审计。  
- 敏感字段脱敏和传输加密。  
- 高风险操作采用灰度/审批和一键回滚。  

## 14. 成本与取舍
- 关键链路优先正确性与恢复能力，长尾链路优先成本。  
- 通过分层存储、分级策略和资源隔离实现成本优化。  
- 明确“延迟-正确性-成本”三角取舍并量化收益。  

## 15. Java 关键代码（>=5段，点位不同）
### 15.1 幂等入口与主事务
```java
public class HotelBookingSystemCommandService {
    public Result submit(Command cmd) {
        String idemKey = cmd.getActorId() + ":" + cmd.getClientReqId();
        if (idempotencyRepo.exists(idemKey)) {
            return idempotencyRepo.replay(idemKey);
        }
        Transaction tx = txManager.begin();
        try {
            long entityId = idGen.nextId();
            mainRepo.insert(entityId, cmd);
            outboxRepo.append("ENTITY_CREATED", entityId);
            idempotencyRepo.save(idemKey, entityId);
            tx.commit();
            return Result.ok(entityId);
        } catch (Exception e) {
            tx.rollback();
            throw e;
        }
    }
}
```

### 15.2 状态机与边界校验
```java
public class HotelBookingSystemStateMachine {
    private static final Map<String, Set<String>> ALLOWED = Map.of(
        "INIT", Set.of("RUNNING", "CANCELED"),
        "RUNNING", Set.of("SUCCESS", "FAILED", "CANCELED"),
        "FAILED", Set.of("RETRYING", "CANCELED"),
        "RETRYING", Set.of("SUCCESS", "FAILED"),
        "SUCCESS", Set.of(),
        "CANCELED", Set.of()
    );

    public void check(String from, String to) {
        if (!ALLOWED.getOrDefault(from, Set.of()).contains(to)) {
            throw new IllegalStateException("invalid transition: " + from + " -> " + to);
        }
    }
}
```

### 15.3 失败重试与死信
```java
public class HotelBookingSystemRetryWorker {
    public void retry(Task task) {
        int attempt = task.getAttempt() + 1;
        if (attempt > 5) {
            dlqRepo.save(task.getId(), task.getScene(), task.getLastError());
            return;
        }
        long delaySec = Math.min(300, (long) Math.pow(2, attempt));
        long jitter = ThreadLocalRandom.current().nextLong(0, 3);
        scheduler.delay(task.getId(), Duration.ofSeconds(delaySec + jitter));
        taskRepo.markRetrying(task.getId(), attempt);
    }
}
```

### 15.4 质量门禁与告警触发
```java
public class HotelBookingSystemQualityGuard {
    public GuardResult evaluate(MetricsSnapshot s) {
        boolean latencyOk = s.getP95Ms() <= 300;
        boolean errOk = s.getErrorRate() <= 0.005;
        boolean backlogOk = s.getBacklog() <= 100000;
        if (latencyOk && errOk && backlogOk) {
            return GuardResult.pass();
        }
        alertService.fire("Q" + 96 + "_QUALITY_FAIL",
            Map.of("p95", s.getP95Ms(), "err", s.getErrorRate(), "backlog", s.getBacklog()));
        return GuardResult.fail("quality gate failed");
    }
}
```

### 15.5 对账与修复任务
```java
public class HotelBookingSystemReconcileJob {
    public void run(LocalDate dt) {
        List<DiffItem> diffs = diffRepo.findDiffs(dt);
        for (DiffItem d : diffs) {
            try {
                repairService.repair(d);
                diffRepo.markFixed(d.getId());
            } catch (Exception e) {
                dlqRepo.save("REPAIR_FAIL", d.getId(), e.getMessage());
            }
        }
    }
}
```

## 16. 前端功能代码（React+TS，>=2段）
### 16.1 选座页
```tsx
import { useEffect, useState } from "react";

type Health = { p95: number; errorRate: number; backlog: number; };

export function HotelBookingSystemHealthPanel() {
  const [health, setHealth] = useState<Health | null>(null);
  const [msg, setMsg] = useState("");

  useEffect(() => {
    let t: number;
    const load = async () => {
      const resp = await fetch("/api/v1/96/health");
      if (resp.ok) {
        setHealth(await resp.json());
        setMsg("");
      } else {
        setMsg("拉取失败");
      }
      t = window.setTimeout(load, 5000);
    };
    load();
    return () => window.clearTimeout(t);
  }, []);

  if (!health) return <div>加载中...</div>;
  return (
    <div>
      <h3>Design Hotel Booking System - 选座页</h3>
      {msg && <p>{msg}</p>}
      <p>P95: {health.p95}ms</p>
      <p>ErrorRate: {health.errorRate}</p>
      <p>Backlog: {health.backlog}</p>
    </div>
  );
}
```

### 16.2 预订详情页
```tsx
import { useState } from "react";

export function HotelBookingSystemOpsPanel() {
  const [msg, setMsg] = useState("");

  const replay = async () => {
    const resp = await fetch("/api/v1/96/ops/replay", { method: "POST" });
    setMsg(resp.ok ? "回放已触发" : "回放失败");
  };

  const rollback = async () => {
    const resp = await fetch("/api/v1/96/ops/rollback", { method: "POST" });
    setMsg(resp.ok ? "回滚已触发" : "回滚失败");
  };

  return (
    <div>
      <h3>Design Hotel Booking System - 预订详情页</h3>
      <button onClick={replay}>触发回放</button>
      <button onClick={rollback}>紧急回滚</button>
      {msg && <p>{msg}</p>}
    </div>
  );
}
```

## 17. 测试策略
- 单测：状态迁移、幂等、边界条件。  
- 集成：主链路 + 异步链路端到端。  
- 压测：峰值流量、依赖抖动、降级触发。  
- 故障注入：超时、重复消息、丢消息、回放修复。  

## 18. 丰富例子（>=10）
1. 高峰流量下，Design Hotel Booking System 如何保证 库存预占 不退化。
2. 当依赖超时时，Design Hotel Booking System 如何通过降级保证主功能可用。
3. 当 价格策略 出现冲突时，如何通过幂等和补偿收敛。
4. 当 ES搜索 放大 3 倍时，如何分层限流与资源扩容。
5. 当单点组件故障时，如何在 RTO 目标内恢复。
6. 当策略误发布时，如何灰度回滚并避免影响扩大。
7. 当告警显示 订单管理 上升时，值班如何按 Runbook 处置。
8. 当日志和指标不一致时，如何定位真实根因。
9. 当数据延迟导致口径漂移时，如何回放修复。
10. 当成本超预算时，如何在体验与成本之间重新平衡。
11. 当出现误判时，如何人工复核并回流优化策略。
12. 当跨团队协作发生口径冲突时，如何用标准接口统一。

## 19. 面试追问 + 可复述回答
### Q1：这题最容易踩坑的点是什么？
可复述：跨服务状态不一致和重试副作用放大，所以必须幂等+补偿+可追溯。  

### Q2：如何证明方案能扛高峰？
可复述：给出容量估算、限流阈值、降级路径和压测结果。  

### Q3：故障发生后怎么快速恢复？
可复述：告警触发 -> Runbook止血 -> 回放修复 -> 对账收敛。  

## 20. 新手学习路线
1. 先讲清核心状态机与主链路。  
2. 再补幂等、重试、补偿和审计。  
3. 最后补可观测、故障演练、回滚与成本取舍。  

## 21. 上场前 Checklist
- [ ] 我能1分钟讲清核心链路。  
- [ ] 我能解释不可逆状态边界。  
- [ ] 我能说出至少3个告警阈值。  
- [ ] 我能说明重试与补偿如何闭环。  
- [ ] 我能讲清成本与稳定性的取舍。  

## 22. 与母题差异
### 22.1 对应母题
- 母题：Q11 订票系统

### 22.2 共性能力（最多5条）
1. 核心链路拆解与状态机建模  
2. 幂等、重试、补偿的一致性治理  
3. 异步事件驱动与可观测闭环  
4. 高峰限流与降级策略  
5. 故障回滚与演练体系  

### 22.3 关键差异（>=5条）
1. 本题业务目标更聚焦“预订/票务系统”场景，非母题通用主线。  
2. 本题核心实体与索引设计围绕“库存预占、价格策略”展开。  
3. 失败模式重心不同：本题更常见“ES搜索”相关故障。  
4. 性能热点位置不同：本题重点在“酒店预订”链路。  
5. 运营治理不同：本题要重点覆盖“库存管理”告警与修复。  

### 22.4 本题新增必补知识（>=5条）
1. 库存预占 的实现边界与替代方案  
2. 价格策略 的一致性与容量取舍  
3. ES搜索 的故障演练与止血策略  
4. 订单管理 的指标阈值与诊断路径  
5. 超售处理 的落地代码与运维闭环  

### 22.5 面试差异话术（3条）
1. “母题给我通用框架，这题我重点补了 库存预占，这是最显著差异。”  
2. “本题在 酒店预订 上的约束更强，所以架构和阈值策略不同。”  
3. “如果只按母题回答会偏泛，我会补充本题在 库存管理 的落地与故障处置。”  
