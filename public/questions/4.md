# Q4 Mint.com - 个人财务管理（超高频）

## 1. 三句话题目本质
1. 这是一个“多银行账户聚合 + 交易分类 + 预算预警”的金融数据平台。  
2. 难点不在页面，而在外部银行接口不稳定、账务口径不一致、隐私合规要求高。  
3. 面试要讲清：如何保证同步稳定、分类可解释、预算和报表数据可信。  

## 2. 一个真实场景故事
用户在平台绑定了 6 家银行和 2 张信用卡。某天银行 A 接口超时、银行 B 返回重复流水，导致用户账单翻倍、预算告警失真。你用“幂等流水入库 + 对账回补 + 可解释分类规则”修复后：  
1. 重复流水率从 3.2% 降到 0.1%。  
2. 同步失败重试成功率提升到 99%+。  
3. 用户投诉量一周下降 70%。  

## 3. 术语白话表（新手可懂）
1. Account Aggregation：把多银行账户聚到一个界面。  
2. Transaction：一条交易流水。  
3. Pending Transaction：还没最终入账的流水。  
4. Reconciliation：对账，核对“平台账”和“银行账”是否一致。  
5. Idempotency：同一流水重复推送只入库一次。  
6. Categorization：把“星巴克消费”归类到“餐饮”。  
7. Budget Envelope：预算桶，比如“本月餐饮 2000 元”。  
8. Webhook：银行主动推送变更事件。  
9. Polling：平台定时主动拉取银行数据。  
10. PII：敏感个人信息（手机号、证件号等）。  
11. Token Vault：安全存储银行访问令牌的服务。  
12. Ledger Snapshot：某时点账户余额快照。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持多银行账号绑定与断连。  
2. 支持流水同步、分类、搜索、统计。  
3. 支持预算设置、超额预警、月报导出。  
4. 支持分类规则手动修正并持续学习。  
5. 支持对账修复和错误申诉。  

### 4.2 非功能需求
1. 同步稳定：高峰时仍可按计划刷新。  
2. 数据可信：重复/遗漏可检测、可修复。  
3. 安全合规：敏感信息最小化存储与审计。  
4. 可解释：分类结果可追溯规则来源。  

### 4.3 不做范围
1. 不做放贷、投资交易撮合。  
2. 不做复杂税务筹划引擎。  
3. 不做实时支付清算系统。  

### 4.4 SLO/SLA
1. 账户同步任务成功率 >= 99.5%。  
2. 流水入库去重准确率 >= 99.99%。  
3. 预算告警延迟 P95 < 2 分钟。  

## 5. 容量估算（数字推导）
假设 500 万 MAU，人均绑定 3 个账户，人均日增 18 条流水：  
1. 日新增流水：500 万 * 18 = 9000 万条。  
2. 平均写入 TPS：9000 万 / 86400 ≈ 1042/s。  
3. 峰值按 6 倍：约 6250/s。  
4. 单条流水存储按 1.2KB：日增约 103GB。  
5. 保留 3 年：约 113TB（冷热分层后可降本）。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`银行连接器 -> 同步编排 -> 幂等入库 -> 分类引擎 -> 预算/报表 -> 告警`

### 6.2 完整版
1. Connector Gateway：统一各银行 API 协议。  
2. Sync Orchestrator：按账户调度拉取/接收 webhook。  
3. Dedup & Ledger Service：幂等写入与余额快照。  
4. Categorization Service：规则 + 模型混合分类。  
5. Budget Service：预算桶计算、超额检测。  
6. Reconciliation Service：日终对账与差异回补。  
7. Notification Service：App Push / Email / SMS。  
8. Compliance & Audit：加密、脱敏、审计追踪。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `POST /v1/accounts/link`：绑定银行账户。  
2. `POST /v1/sync/jobs`：触发账户同步。  
3. `GET /v1/transactions`：分页查询流水。  
4. `POST /v1/budgets`：创建预算桶。  
5. `POST /v1/transactions/{id}/reclassify`：手动改分类。  

请求示例：
```json
{
  "accountId": "acc_1024",
  "fromDate": "2026-02-01",
  "toDate": "2026-02-24",
  "idempotencyKey": "sync-acc_1024-20260224"
}
```

响应示例：
```json
{
  "jobId": "sync_job_7788",
  "status": "QUEUED",
  "estimatedFinishSec": 45
}
```

常见错误码：`401_TOKEN_EXPIRED`、`409_DUPLICATE_TRANSACTION`、`422_INVALID_ACCOUNT_STATE`、`503_BANK_CONNECTOR_TIMEOUT`。  

## 8. 数据模型（实体、索引、分片分区）
1. `user_account`：`account_id`、`user_id`、`provider`、`status`、`encrypted_token_ref`。  
2. `transaction_ledger`：`txn_uid(pk)`、`account_id`、`posted_at`、`amount`、`currency`、`category`。  
3. `balance_snapshot`：`account_id + snapshot_date`、`balance`。  
4. `budget_bucket`：`bucket_id`、`user_id`、`category`、`limit_amount`、`period`。  
5. `recon_diff`：`diff_id`、`account_id`、`diff_type`、`status`、`resolved_at`。  
6. 索引：`idx_user_posted(user_id,posted_at desc)`、`idx_account_posted(account_id,posted_at)`。  
7. 分区：`transaction_ledger` 按月份分区，便于冷热分层。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：同步任务触发 -> 拉取流水 -> 幂等入库 -> 分类 -> 预算计算 -> 通知。  
2. 高峰：银行限流 -> 账户分级队列 -> 高价值账户优先 -> 延迟低优先同步。  
3. 故障恢复：连接器故障 -> 任务重排 + 指数退避 -> 超阈值入 DLQ -> 人工回补。  

## 10. 一致性与事务边界
1. 单账户流水保证“同一银行流水号 + 金额 + 入账时间”幂等唯一。  
2. 分类是可重算的，账务原始流水不可覆盖，只能追加更正记录。  
3. 预算结果允许分钟级最终一致，但账本本身必须可追溯。  
4. 对账差异采用补偿任务，不阻塞主链路。  

## 11. 可用性与容错
1. Connector 按银行隔离，单银行故障不影响全局。  
2. 熔断：某银行 5xx > 20% 持续 3 分钟，进入保护模式。  
3. 降级：分类服务异常时先入“未分类”，后续异步补分类。  
4. 任务超时自动回收，最多重试 7 次后入 DLQ。  
5. RTO 30 分钟，RPO 5 分钟。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `sync_success_rate`  
2. `connector_error_rate{bank}`  
3. `dedup_conflict_rate`  
4. `uncategorized_ratio`  
5. `budget_alert_delay_ms`  

告警阈值：  
1. 同步成功率 < 98%（10分钟）-> P1。  
2. 单银行错误率 > 25%（5分钟）-> P1。  
3. 未分类占比 > 15%（30分钟）-> P2。  
4. 预算告警延迟 P95 > 120s（10分钟）-> P2。  

处置：限流保护 -> 切备用连接器 -> 回补重放 -> 对账核验。  

## 13. 安全与合规
1. 银行 Token 不落业务库，存 Vault，业务侧仅持引用。  
2. 传输和存储全链路加密，敏感字段列级脱敏。  
3. 全量审计：谁看过哪条流水、何时导出。  
4. 风控策略：异常登录、异常导出频率实时拦截。  
5. 满足 PCI-DSS / 本地隐私法规要求（按地区部署）。  

## 14. 成本与取舍
1. 高频同步体验好但成本高，需账户分级策略。  
2. 纯模型分类灵活但不可解释，需规则兜底。  
3. 全量实时对账成本过高，采用“日终全量 + 实时抽样”混合策略。  
4. 冷数据分层到低频存储，降低长期存储成本。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 银行流水幂等入库
```java
public class LedgerIngestService {
    private final TransactionRepo repo;

    public void ingest(BankTxn txn) {
        String uid = Hashing.sha256(
            txn.bankTxnId() + "|" + txn.accountId() + "|" + txn.amount() + "|" + txn.postedAt()
        );
        if (repo.exists(uid)) return;
        repo.insert(new LedgerRecord(uid, txn.accountId(), txn.amount(), txn.postedAt(), "UNCATEGORIZED"));
    }
}
```

### 15.2 同步任务重试编排
```java
public class SyncRetryPolicy {
    public Duration backoff(int retryCount) {
        long base = 2_000L;
        long delay = Math.min(120_000L, base * (1L << Math.min(retryCount, 8)));
        long jitter = ThreadLocalRandom.current().nextLong(200, 1200);
        return Duration.ofMillis(delay + jitter);
    }

    public boolean shouldDeadLetter(int retryCount, int httpCode) {
        return retryCount >= 7 || httpCode == 401 || httpCode == 403;
    }
}
```

### 15.3 分类引擎（规则优先 + 模型回退）
```java
public class CategoryEngine {
    private final RuleMatcher ruleMatcher;
    private final MlModelClient mlModelClient;

    public CategoryResult classify(LedgerRecord record) {
        Optional<String> byRule = ruleMatcher.match(record.merchant(), record.memo());
        if (byRule.isPresent()) {
            return new CategoryResult(byRule.get(), "RULE", 1.0);
        }
        MlPrediction pred = mlModelClient.predict(record);
        return new CategoryResult(pred.label(), "ML", pred.probability());
    }
}
```

### 15.4 预算超额检测
```java
public class BudgetChecker {
    public Optional<BudgetAlert> check(BudgetBucket bucket, BigDecimal spent) {
        BigDecimal ratio = spent.divide(bucket.limitAmount(), 4, RoundingMode.HALF_UP);
        if (ratio.compareTo(new BigDecimal("1.00")) >= 0) {
            return Optional.of(new BudgetAlert(bucket.userId(), bucket.category(), spent, bucket.limitAmount(), "EXCEEDED"));
        }
        if (ratio.compareTo(new BigDecimal("0.80")) >= 0) {
            return Optional.of(new BudgetAlert(bucket.userId(), bucket.category(), spent, bucket.limitAmount(), "NEAR_LIMIT"));
        }
        return Optional.empty();
    }
}
```

### 15.5 日终对账与补偿任务
```java
public class ReconciliationJob {
    public List<ReconDiff> compare(List<BankTxn> bank, List<LedgerRecord> local) {
        Map<String, LedgerRecord> localMap = local.stream()
            .collect(Collectors.toMap(LedgerRecord::txnUid, x -> x, (a, b) -> a));
        List<ReconDiff> diffs = new ArrayList<>();
        for (BankTxn b : bank) {
            String uid = Hashing.sha256(b.bankTxnId() + "|" + b.accountId() + "|" + b.amount() + "|" + b.postedAt());
            if (!localMap.containsKey(uid)) {
                diffs.add(ReconDiff.missing(uid, b.accountId()));
            }
        }
        return diffs;
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 账户同步状态页（React + TS）
```tsx
type SyncRow = { accountId: string; bank: string; status: string; lastSuccessAt: string; retryCount: number };

export function SyncStatusPage() {
  const [rows, setRows] = useState<SyncRow[]>([]);
  useEffect(() => {
    fetch("/api/finance/sync-status").then(r => r.json()).then(setRows);
  }, []);
  return (
    <table>
      <thead><tr><th>账户</th><th>银行</th><th>状态</th><th>最后成功</th><th>重试次数</th></tr></thead>
      <tbody>{rows.map(r => <tr key={r.accountId}><td>{r.accountId}</td><td>{r.bank}</td><td>{r.status}</td><td>{r.lastSuccessAt}</td><td>{r.retryCount}</td></tr>)}</tbody>
    </table>
  );
}
```

### 16.2 分类修正与预算面板（React + TS）
```tsx
export function ReclassifyPanel({ txnId }: { txnId: string }) {
  const [category, setCategory] = useState("FOOD");
  const [note, setNote] = useState("");
  async function submit() {
    await fetch(`/api/finance/transactions/${txnId}/reclassify`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ category, note })
    });
    alert("分类已更新");
  }
  return (
    <div>
      <select value={category} onChange={e => setCategory(e.target.value)}>
        <option value="FOOD">餐饮</option><option value="TRAVEL">出行</option><option value="SHOPPING">购物</option>
      </select>
      <input value={note} onChange={e => setNote(e.target.value)} placeholder="修正原因" />
      <button onClick={submit}>提交</button>
    </div>
  );
}
```

## 17. 测试策略
1. 单测：幂等键生成、分类规则匹配、预算阈值判断。  
2. 集成：连接器模拟超时/重复数据，验证重试与去重。  
3. 压测：峰值 6000 TPS 流水写入与查询。  
4. 故障演练：银行接口全量 5xx、Token 过期、分类模型不可用。  
5. 对账回归：每日抽样核对“银行账 vs 平台账”。  

## 18. 丰富例子（面试可复述）
1. 银行返回重复流水，如何防止账单翻倍。  
2. 银行接口限流，如何保证关键账户优先同步。  
3. 一笔流水从 Pending 到 Posted，如何避免重复记账。  
4. 用户手动改分类后，如何反哺分类模型。  
5. 预算告警延迟高，如何定位瓶颈在计算还是通知。  
6. 用户投诉余额不对，如何做对账定位。  
7. 新银行接入字段缺失，如何灰度上线。  
8. 大促期间流水激增，如何保护写入主链路。  
9. 合规审计要求导出访问记录，如何快速提供。  
10. 误杀风控导致正常同步被拦截，如何回放补偿。  
11. 多币种账户如何统一展示和换汇计算。  
12. 预算口径变更如何保证历史报表可追溯。  

## 19. 面试追问+回答模板
1. 问：为什么分类要“规则+模型”？  
答：规则稳定且可解释，模型覆盖长尾。两者结合能兼顾准确率和可审计性。  
2. 问：同步和对账如何分层？  
答：同步走实时链路保证体验，对账走离线校验保证正确性，差异走补偿任务。  
3. 问：系统最关键的防线是什么？  
答：幂等入库 + 对账修复 + 审计追踪，这三层保证“错了能发现、能回滚、能解释”。  

## 20. 新手学习路线
1. 先学账户与流水数据模型。  
2. 再学幂等、重试、对账三件套。  
3. 学会预算与报表口径定义。  
4. 补安全合规（PII、审计、加密）。  
5. 最后练一遍“故障演练+复盘话术”。  

## 21. 上场前Checklist
1. 能解释银行接口不稳定时的降级策略。  
2. 能写出流水幂等键设计。  
3. 能讲清“同步成功不等于账务正确”。  
4. 能给出至少 3 个监控指标和阈值。  
5. 能讲出与支付母题在交易状态机上的差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q84 Online Payment System`。  

### 22.2 共性能力
1. 都需要高可靠交易数据链路。  
2. 都强调幂等、重试、补偿。  
3. 都有风控与审计要求。  
4. 都依赖对账来闭环。  

### 22.3 关键差异
1. Q4 是“财务聚合与分析”，Q84 是“支付交易执行”。  
2. Q4 更关注多源同步和分类准确性，Q84 更关注支付状态机和清结算。  
3. Q4 面向个人财务洞察，Q84 面向资金流转成功率。  
4. Q4 可接受分钟级最终一致，Q84 在扣款链路时效要求更强。  
5. Q4 重点指标是同步成功率/重复率，Q84 重点是支付成功率/资金一致性。  

### 22.4 本题新增必补知识
1. 多银行连接器协议适配。  
2. 个人财务分类可解释性。  
3. 预算桶与报表口径治理。  
4. Pending/Posted 双态流水处理。  
5. 用户申诉与对账回补流程。  

### 22.5 面试差异话术
1. “Q4 不是支付网关，它更像用户侧财务数据中台。”  
2. “Q4 的核心风险是数据不可信；Q84 的核心风险是资金不一致。”  
3. “讲 Q4 要重点说多源同步、去重、分类和预算闭环，而不是支付路由。”  
