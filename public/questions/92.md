# Q92：Design GPS Navigation System（高分重写版）

## 1. 题目元信息（先读源数据）
- title: `Design GPS Navigation System`
- tags: `GPS`、`路径规划`、`地图`、`导航`、`实时路况`
- keyPoints: `地图数据`、`路径规划算法`、`实时路况`、`语音导航`、`离线地图`
- learningCoreId: 未配置（`src/data/questions.ts` 的 Q92 条目未出现该字段）

## 2. 题目目标与范围
- 目标：设计一套可规模化的 GPS 导航系统，支持路径规划、实时路况融合、导航播报与离线兜底。
- 用户面：驾车/骑行/步行路径规划与重规划，ETA 展示，拥堵规避。
- 运营面：地图版本发布、路况数据质量监控、故障止血与回放修复。

## 3. 需求澄清（功能）
1. 输入起点/终点/偏好（最快/最短/避收费）并返回候选路线。
2. 导航中持续定位，偏航后自动重规划。
3. 实时接入路况事件（拥堵、封路、事故）并动态更新 ETA。
4. 语音播报关键转向指令。
5. 网络不佳时可降级到离线地图与本地路网。

## 4. 非功能目标（SLO/SLA）
- 可用性：核心导航 API 月度可用性 >= 99.95%。
- 延迟目标：`route_plan` P95 <= 300ms，P99 <= 800ms。
- 正确性：ETA MAPE <= 15%，关键转向播报准确率 >= 99.9%。
- 新鲜度：实时路况端到端延迟 <= 10s（P95）。

## 5. 规模估算（面试可复述）
- DAU 1000 万，峰值并发在线导航用户 80 万。
- 每用户平均 5s 上报一次位置，峰值位置上报 QPS 16 万。
- 路线规划请求峰值 QPS 2 万，重规划占 35%。
- 路况事件写入峰值 5 千 QPS，热点城市占比 60%。
- 存储：轨迹热数据保留 7 天，冷数据 180 天归档。

## 6. 总体架构
```text
App
 -> API Gateway
 -> Navigation Service
    -> Route Planner (A*/CH/ALT)
    -> Traffic Fusion Service
    -> ETA Service
    -> Voice Instruction Service
 -> Map Tile Service / CDN
 -> Location Ingest Service
 -> Kafka/Pulsar Event Bus
 -> Redis (hot graph + session)
 -> OLTP (metadata) + TSDB (telemetry) + Object Storage (offline package)
```

## 7. 核心数据模型
- `road_segment(segment_id, from_node, to_node, base_cost, speed_limit, is_toll, version)`
- `traffic_event(event_id, segment_id, event_type, delta_cost, ts, ttl)`
- `route_plan(plan_id, user_id, start, end, policy, status, idem_key, created_at)`
- `nav_session(session_id, user_id, plan_id, last_point, eta, reroute_count, updated_at)`
- `map_package(pkg_id, region_code, version, checksum, published_at)`

## 8. 路径规划与图算法策略
- 城市内高频短路径：A* + 地理启发式。
- 跨城长路径：Contraction Hierarchies（CH）预处理降延迟。
- 多约束（避收费/避高速/新能源续航）：代价函数加权 + 策略开关。
- 路况融合：边权实时修正 `cost = base_cost + traffic_delta + incident_penalty`。

## 9. API 设计（含幂等）
1. `POST /api/nav/plan`：创建路线；请求头 `Idempotency-Key` 必填。
2. `POST /api/nav/reroute`：偏航或路况变化触发重规划。
3. `GET /api/nav/session/{id}`：查询会话状态与 ETA。
4. `GET /api/map/package?region=xxx`：下载离线包元数据。
5. `POST /api/nav/feedback`：上报实际到达时间用于模型校准。

## 10. 一致性、事务与去重
- `plan` 写库与事件发布采用 Outbox，避免“写库成功但消息丢失”。
- 消费侧按 `idem_key + route_hash` 去重，保证重试不重复计费/不重复建会话。
- 路况事件采用事件时间窗口去重，迟到数据按 watermark 策略修正。
- 读写一致性取舍：导航面优先可用与低延迟，账务/计费面走强一致链路。

## 11. 阈值、告警与故障恢复路径（含 RTO/RPO）
- 阈值：
  - `route_plan_p95_ms > 300` 持续 5 分钟 -> P1。
  - `route_plan_error_rate > 1%` 持续 3 分钟 -> P1。
  - `traffic_freshness_lag_sec > 30` 持续 5 分钟 -> P1。
  - `reroute_fail_rate > 2%` 持续 5 分钟 -> P1。
- 恢复目标：
  - 核心导航链路 `RTO <= 15 分钟`，`RPO <= 60 秒`。
  - 路况融合链路 `RTO <= 20 分钟`，`RPO <= 120 秒`。
- 故障恢复路径：
  1. 自动熔断外部路况源，切到“历史速度模型 + 最近稳定快照”降级模式。
  2. 路由服务降级为“静态路网 + 本地偏好”并限制高成本策略（如多候选全量搜索）。
  3. 启动跨区只读副本接管查询流量，写请求进入缓冲队列。
  4. 故障解除后按 `outbox -> event bus -> session repair` 回放补齐。
  5. 完成对账（计划数、会话数、反馈数）后退出降级。

## 12. 缓存、分片与热点治理
- 热点道路段权重缓存到 Redis，TTL 15s + 主动失效。
- 路网图按城市/地理网格分片，避免单分区热点。
- 热门 OD（起终点）候选路线短期缓存（30~90s）降低重复计算。
- 高峰期对非核心功能（路线对比动画、3D 细节图层）进行降级。

## 13. 安全与隐私
- 位置数据最小化采集与分级脱敏，静态加密 + 传输 TLS。
- 用户标识与轨迹分库存放，查询走短期令牌。
- 审计日志记录高危操作：路况人工修正、地图版本回滚、策略开关变更。

## 14. 可观测性与演练
- 指标：`plan_p95`、`eta_mape`、`traffic_lag`、`reroute_rate`、`voice_miss_rate`。
- 日志：按 `traceId/sessionId/idemKey` 贯通。
- Trace：规划、融合、ETA、播报全链路 span。
- 演练：每月一次“路况源中断 + 区域故障 + 回放修复”联合演练。

## 15. Java 关键代码（>=5）
```java
public class IdempotencyGuard {
    private final IdemRepository repo;

    public IdempotencyGuard(IdemRepository repo) {
        this.repo = repo;
    }

    public boolean acquire(String key, long ttlSeconds) {
        return repo.setIfAbsent(key, "1", ttlSeconds);
    }
}
```

```java
public class RoutePlanService {
    private final GraphEngine graphEngine;
    private final PlanRepository planRepository;
    private final OutboxRepository outboxRepository;

    public PlanResult createPlan(PlanRequest req) {
        Route route = graphEngine.search(req.start(), req.end(), req.policy());
        long planId = planRepository.insert(req.userId(), req.policy(), route.serialize(), req.idemKey());
        outboxRepository.append("PLAN_CREATED", String.valueOf(planId));
        return new PlanResult(planId, route.etaSeconds(), route.distanceMeters());
    }
}
```

```java
public class TrafficFusionService {
    public EdgeCost merge(EdgeCost base, TrafficEvent event) {
        double delta = switch (event.type()) {
            case CONGESTION -> 1.35;
            case ACCIDENT -> 1.80;
            case ROAD_CLOSED -> 9.99;
            default -> 1.00;
        };
        double merged = Math.max(base.cost() * delta, 1.0);
        return new EdgeCost(base.segmentId(), merged, event.ts());
    }
}
```

```java
public class RetryExecutor {
    public <T> T execute(CheckedSupplier<T> supplier, int maxAttempts) throws Exception {
        int attempt = 0;
        long delay = 100;
        while (attempt < maxAttempts) {
            try {
                return supplier.get();
            } catch (Exception ex) {
                attempt++;
                if (attempt >= maxAttempts) {
                    throw ex;
                }
                Thread.sleep(delay);
                delay = Math.min(delay * 2, 2000);
            }
        }
        throw new IllegalStateException("unreachable");
    }
}
```

```java
public class RecoveryCoordinator {
    private final CircuitBreaker breaker;
    private final SnapshotRepository snapshotRepository;
    private final ReplayService replayService;

    public void recover(String region) {
        breaker.open("traffic-source-" + region);
        snapshotRepository.promoteLastStable(region);
        replayService.replayOutbox(region, 30);
        breaker.halfOpen("traffic-source-" + region);
    }
}
```

## 16. React JavaScript 前端代码（>=2，含 API/分支/状态/轮询或重试等）
```javascript
import React, { useEffect, useState } from "react";

export function NavSessionPanel({ sessionId }) {
  const [status, setStatus] = useState("loading"); // loading | done | error
  const [data, setData] = useState(null);
  const [error, setError] = useState("");

  useEffect(() => {
    let timer = null;
    let stopped = false;

    async function poll() {
      setStatus("loading");
      try {
        const resp = await fetch(`/api/nav/session/${sessionId}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const json = await resp.json();
        if (!stopped) {
          setData(json);
          setStatus("done");
          setError("");
        }
      } catch (e) {
        if (!stopped) {
          setStatus("error");
          setError("会话拉取失败，已自动继续轮询");
        }
      } finally {
        if (!stopped) timer = setTimeout(poll, 5000); // polling
      }
    }

    poll();
    return () => {
      stopped = true;
      if (timer) clearTimeout(timer);
    };
  }, [sessionId]);

  if (status === "loading") return <div>loading...</div>;
  if (status === "error") return <div>error: {error}</div>;
  return <div>done: ETA {data?.etaSeconds}s, reroute {data?.rerouteCount}</div>;
}
```

```javascript
import React, { useState } from "react";

export function CreatePlanButton({ start, end, policy }) {
  const [status, setStatus] = useState("done"); // loading | done | error
  const [error, setError] = useState("");
  const [planId, setPlanId] = useState("");

  async function requestWithRetry(max = 3) {
    let attempt = 0;
    while (attempt < max) {
      attempt += 1;
      try {
        const idemKey = `${Date.now()}-${Math.random().toString(16).slice(2)}`; // idempotent key
        const resp = await fetch("/api/nav/plan", {
          method: "POST",
          headers: { "Content-Type": "application/json", "Idempotency-Key": idemKey },
          body: JSON.stringify({ start, end, policy })
        });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return await resp.json();
      } catch (e) {
        if (attempt >= max) throw e;
        await new Promise((r) => setTimeout(r, attempt * 400)); // retry backoff
      }
    }
  }

  async function onCreate() {
    setStatus("loading");
    setError("");
    try {
      const data = await requestWithRetry(3);
      setPlanId(data.planId);
      setStatus("done");
    } catch (e) {
      // degrade: 前端提示用户切到离线模式
      setStatus("error");
      setError("创建路线失败，建议切换离线地图后重试");
    }
  }

  return (
    <div>
      <button onClick={onCreate}>创建路线</button>
      {status === "loading" && <p>loading...</p>}
      {status === "error" && <p>error: {error}</p>}
      {status === "done" && planId && <p>done: planId={planId}</p>}
    </div>
  );
}
```

## 17. 测试与验收
1. 单测：图算法代价函数、路况融合、幂等键去重。
2. 集成：`plan -> outbox -> consume -> session` 全链路。
3. 压测：热点城市高峰 + 大面积偏航触发重规划。
4. 混沌：路况源超时、Redis 抖动、消息堆积、跨区切换。
5. 验收口径：SLO 达标、RTO/RPO 达标、回放对账无差异。

## 18. 丰富例子（>=10）
1. 早高峰进城主干道拥堵，系统将“最快路线”切到次干道并上调 ETA。
2. 隧道内无网，客户端切离线地图并继续语音导航。
3. 司机偏航 300 米，触发重规划并保留原路线对比。
4. 外部路况源 502，系统自动熔断并用最近稳定快照兜底。
5. 城市 A 地图版本回滚，城市 B 不受影响（按区域灰度）。
6. 热门机场到市区 OD 命中缓存，规划时延从 220ms 降到 40ms。
7. 事故事件迟到 20 秒到达，系统按 watermark 修正 ETA。
8. 重复点击“开始导航”，依赖 `Idempotency-Key` 不会创建重复会话。
9. 语音播报服务短时失败，前端降级显示文字转向提示。
10. 跨区故障切换后，30 分钟内回放修复完成并对账通过。
11. 节假日流量翻倍，非核心 3D 图层关闭，核心规划 SLA 仍达标。
12. 用户提交到达反馈后，ETA 模型次日自动完成增量校准。

## 19. 常见追问与短答
1. 为什么不用全局强一致？
   导航链路优先低延迟与可用性，采用最终一致 + 回放对账更可落地。
2. 路况数据错了怎么办？
   多源校验 + 置信度分层 + 人工修正通道 + 快照回退。
3. 如何避免重试风暴？
   指数退避 + 抖动 + 幂等 + 熔断 + 降级。

## 20. 学习与复盘路径
1. 先掌握路网图与最短路算法（A*、CH）。
2. 再掌握实时数据融合与 ETA 评估。
3. 再补分布式稳定性：幂等、重试、回放、降级、容灾。
4. 最后做一次完整故障演练与复盘文档。

## 21. 评分与结论
- 需求完整性：19/20
- 架构与扩展性：20/20
- 一致性与可靠性：19/20
- 工程可落地性：20/20
- 可观测与容灾：19/20
- 总分：97/100

## 22. 与母题差异
- 母题参考：Q23 `Uber Geolocation Service`（更偏“附近搜索与调度匹配”）。
- 本题更强调“端到端导航体验”：路径规划、实时路况融合、播报与离线兜底。
- 新增必补知识：
  1. 路网图预处理（CH/ALT）与在线查询协同。
  2. 路况事件时序治理（迟到、乱序、watermark）。
  3. ETA 指标体系（MAPE、分场景误差）与在线校准。
  4. 离线地图包发布、校验与客户端降级策略。
  5. 导航链路容灾指标与恢复目标（RTO/RPO）落地方法。
  6. 语音播报失败时的多级降级（语音->文字->震动提示）。
