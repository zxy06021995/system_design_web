# Q54 Design Real-Time Notification System

> 来源校验（questions.ts）  
> `title`: Design Real-Time Notification System  
> `tags`: 推送通知, WebSocket, 消息队列, 多通道, 实时性  
> `keyPoints`: WebSocket推送, 消息队列, 多通道通知, 推送策略, 消息存储  
> `learningCoreId`: 21（母题：Chat System）

## 1. 三句话题目本质
1. 实时通知系统的核心是“事件发生后，尽快把通知送到正确的人和设备”。
2. 难点在多通道投递、到达率、去重、顺序和高峰抗压。
3. 高分回答要把接入、路由、投递、回执、重试、降级讲成闭环。

## 2. 一个真实场景故事
某电商在大促期间每秒产生 20 万条通知事件（支付成功、发货、营销消息）。因为同步调用短信/推送渠道，主业务接口超时飙升。改为“主流程只写事件 + MQ 异步投递 + 多通道策略路由”后，业务链路稳定，通知送达率提升到 99.2%。

## 3. 术语白话表（>=10）
1. Fanout：将一条事件分发到多个终端/渠道。
2. Channel：通知渠道（站内信、Push、短信、邮件）。
3. Template：通知模板。
4. Preference：用户通知偏好。
5. Delivery Receipt：投递回执。
6. Retry Policy：重试策略。
7. DLQ：死信队列，存放失败通知。
8. Dedup Key：去重键。
9. WebSocket Session：在线连接会话。
10. Offline Inbox：离线消息箱。
11. Hot Notification：高频实时消息。
12. Cold Archive：历史通知归档。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 接收业务通知事件。
2. 按用户偏好选择渠道并投递。
3. 支持在线实时推送和离线补拉。
4. 支持通知状态查询（已发送/失败/已读）。
5. 支持模板管理和审计。

### 4.2 非功能需求
1. 低延迟：在线通知 P95 <= 2s。
2. 高可用：>=99.95%。
3. 可扩展：百万级用户并发在线。
4. 高可靠：失败可重试、可回溯。

### 4.3 不做范围
1. 不做 IM 聊天双向实时会话。
2. 不做营销策略平台全能力。
3. 不做运营内容编辑系统细节。

### 4.4 SLO
1. `notification_delivery_success_rate >= 99%`
2. `online_push_p95_ms <= 2000`
3. `dlq_ratio <= 0.5%`

## 5. 容量估算（数字推导）
1. 峰值通知事件 20 万/s。
2. 每条事件平均 600B，入口约 120MB/s。
3. 实时在线用户 500 万，WebSocket 并发连接级别。
4. 通道分布：站内信 60%，Push 30%，短信 8%，邮件 2%。
5. MQ 需要至少 30 万 msg/s 处理能力（含重试）。
6. 冷热：近 7 天通知热存，历史冷归档（对象存储）。

## 6. 架构（简版+完整版）
### 6.1 简版
`Event API -> MQ -> Notification Router -> Channel Workers`

### 6.2 完整版
1. Ingress API：接收通知事件。
2. Dedup Layer：按 `eventId+userId` 去重。
3. MQ（Kafka/Rabbit）：削峰解耦。
4. Router：根据偏好/优先级选渠道。
5. Online Push Service：WebSocket 推送在线用户。
6. Offline Inbox：离线存储，客户端拉取。
7. Channel Workers：短信/邮件/Push 提供商适配器。
8. Receipt Collector：收集回执并更新状态。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 发送通知
`POST /api/notify/v1/events`

请求：
```json
{
  "eventId": "evt-20260224-001",
  "userId": "u1001",
  "type": "ORDER_PAID",
  "payload": {"orderId":"o1","amount":199},
  "priority": "HIGH"
}
```

响应：
```json
{
  "accepted": true,
  "traceId": "n-trace-001"
}
```

### 7.2 查询通知状态
`GET /api/notify/v1/events/{eventId}`

### 7.3 拉取离线通知
`GET /api/notify/v1/inbox?cursor=...&limit=50`

错误码：
1. `409_DUPLICATE_EVENT`
2. `422_INVALID_TEMPLATE`
3. `429_CHANNEL_THROTTLED`
4. `503_NOTIFY_DEGRADED`

幂等规则：
1. `eventId` 全局唯一，同事件重复提交只受理一次。
2. 渠道重试不重复入库，通过 dedup key 保护。

## 8. 数据模型（实体/索引/分片）
1. `notify_event(event_id, user_id, type, payload, status, ts)`。
2. `notify_delivery(event_id, channel, attempt, state, provider_msg_id)`。
3. `notify_inbox(user_id, seq, event_id, read_state, ts)`。
4. `notify_pref(user_id, type, channel_enabled)`。
5. `notify_audit(actor, action, target, ts)`。

分片与冷热：
1. `notify_inbox` 按 `user_id` 分片。
2. 最近 7 天热数据在 OLTP 库，历史转冷存。
3. 热门用户 inbox 放 Redis 缓存，冷用户按需加载。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 业务方提交事件到 Ingress API。
2. 去重后写 MQ。
3. Router 按偏好路由到在线推送或离线通道。
4. 回执写状态并更新用户 inbox。

### 9.2 高峰流程
1. 高优先级通知单独 topic。
2. 渠道 worker 限流，低优先级延迟发送。
3. 在线推送失败自动落离线 inbox。

### 9.3 故障恢复流程
1. 第三方短信故障时切备用通道。
2. MQ 积压时优先处理高优通知。
3. DLQ 回放任务定时重试失败事件。

## 10. 一致性与事务边界
1. 事件接收与入队强一致（本地事务+outbox）。
2. 多通道投递最终一致。
3. 收到回执后更新状态幂等。
4. “已读状态”以客户端回传为准。
5. 通知可重复投递但不可重复显示（inbox 去重）。

## 11. 可用性与容错（含 RTO/RPO）
1. API/MQ/Worker 多副本。
2. 通道降级策略（Push->站内信->短信）。
3. 在线服务异常不影响离线 inbox。
4. RTO：核心通知能力 10 分钟内恢复。
5. RPO：通知事件不丢（MQ+outbox），状态可补偿。

## 12. 可观测性（指标+阈值+处置动作）
1. `delivery_success_rate < 99%`：排查失败通道并切备。
2. `notify_mq_lag > 200000`：扩容消费者并降级低优通知。
3. `online_push_p95_ms > 2000`：扩容 WebSocket 集群。
4. `channel_error_rate_sms > 3%`：熔断短信通道。
5. `dlq_size > 50000`：触发 DLQ 回放任务。
6. `duplicate_display_count > 0`：排查去重逻辑。

## 13. 安全与合规
1. 事件接口鉴权签名。
2. 敏感内容模板脱敏。
3. 审计记录运营修改和人工重发。
4. 用户偏好遵守退订规则。
5. 通知内容传输加密。

## 14. 成本与取舍
1. 短信送达率高但成本高。
2. Push 成本低但受系统权限影响。
3. 全渠道同时发最稳但过贵。
4. 取舍：按优先级策略路由，多通道兜底而非全发。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法：渠道路由
```java
public List<Channel> route(NotificationEvent e, Preference p, boolean online) {
    List<Channel> result = new ArrayList<>();
    if (online && p.allow(Channel.WEBSOCKET)) result.add(Channel.WEBSOCKET);
    if (p.allow(Channel.PUSH)) result.add(Channel.PUSH);
    if (e.priority().isHigh() && p.allow(Channel.SMS)) result.add(Channel.SMS);
    if (result.isEmpty()) result.add(Channel.INBOX);
    return result;
}
```

### 15.2 幂等去重
```java
public boolean acceptEvent(NotificationEvent e) {
    String key = e.eventId() + ":" + e.userId();
    if (dedupRepo.exists(key)) return false;
    dedupRepo.save(key, Duration.ofDays(1));
    eventRepo.insert(e);
    return true;
}
```

### 15.3 重试退避/失败处理
```java
public void deliverWithRetry(DeliveryTask t) {
    long backoff = 200;
    for (int i = 0; i < 4; i++) {
        try {
            channelClient.send(t.channel(), t.payload());
            deliveryRepo.markSent(t.id());
            return;
        } catch (RuntimeException ex) {
            if (i == 3) { dlqRepo.save(t.id(), ex.getMessage()); return; }
            sleep(backoff);
            backoff = Math.min(backoff * 2, 2000);
        }
    }
}
```

### 15.4 一致性边界：outbox
```java
@Transactional
public void saveEventAndOutbox(NotificationEvent e) {
    eventRepo.insert(e);
    outboxRepo.insert("NOTIFY_EVENT_CREATED", e.eventId());
}
```

### 15.5 观测触发/回滚判定
```java
public void guardNotifyChannel() {
    double smsErr = metrics.gauge("channel_error_rate_sms").value();
    if (smsErr > 0.03) {
        channelSwitch.disable(Channel.SMS);
        alerting.fire("SMS_CHANNEL_DISABLED", "err=" + smsErr);
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 拉取离线通知（loading/error/done）
```javascript
import { useEffect, useState } from "react";

export function useInbox() {
  const [state, setState] = useState({ phase: "idle", items: [], error: "" });
  useEffect(() => {
    let cancelled = false;
    const load = async () => {
      setState((s) => ({ ...s, phase: "loading" }));
      try {
        const res = await fetch("/api/notify/v1/inbox?limit=50");
        if (!res.ok) throw new Error(`HTTP_${res.status}`);
        const data = await res.json();
        if (!cancelled) setState({ phase: "done", items: data.items || [], error: "" });
      } catch (e) {
        if (!cancelled) setState({ phase: "error", items: [], error: String(e.message || e) });
      }
    };
    load();
    return () => { cancelled = true; };
  }, []);
  return state;
}
```

### 16.2 已读回执 API（幂等+重试）
```javascript
export async function ackNotification(eventId) {
  const ackId = `ack-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 100;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch("/api/notify/v1/ack", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Ack-Id": ackId },
        body: JSON.stringify({ eventId, ackId })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 800);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：路由规则、去重、回执状态。
2. 集成测试：事件->MQ->投递->回执。
3. 压测：20 万/s 高峰入队与消费。
4. 故障测试：通道不可用、MQ 积压、WebSocket 断连。
5. 回归测试：多通道降级和 DLQ 回放。

## 18. 丰富例子（>=10）
1. 支付成功优先 WebSocket+Push。
2. 未在线用户落离线 inbox。
3. 高优告警失败后短信兜底。
4. 推送服务故障自动切站内信。
5. 重复事件不重复发送。
6. MQ 积压时低优通知延迟。
7. 用户关闭营销通知不再推送。
8. 已读回执更新消息状态。
9. DLQ 定时回放恢复失败通知。
10. 历史通知归档后仍可查。
11. 高峰期间限流营销通道。
12. 运维手动重发并写审计。

## 19. 面试追问 + 可复述回答
1. 为什么必须用 MQ？
回答：削峰解耦，避免通知链路拖慢主业务。
2. 在线推送失败怎么办？
回答：降级写离线 inbox，客户端补拉。
3. 如何避免重复通知？
回答：事件去重键+inbox 去重展示。
4. 多通道如何选？
回答：按优先级、用户偏好、成本和实时性综合决策。
5. 与聊天系统母题区别？
回答：通知是单向多通道分发，聊天是双向会话同步。

## 20. 新手学习路线
1. 先实现单通道通知（站内信）。
2. 增加 MQ 和多通道路由。
3. 接入 WebSocket 在线推送。
4. 加回执、重试和 DLQ。
5. 补监控告警和降级策略。

## 21. 上场前 Checklist
1. 能讲清多通道路由逻辑。
2. 能解释 MQ、DLQ 的作用。
3. 能说明在线/离线统一体验方案。
4. 能给出高峰阈值与处置动作。
5. 能区分本题与母题 Q21。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q21 Chat System。

### 22.2 共性能力
1. 都有实时消息投递与状态同步。
2. 都需要去重与重试。
3. 都要求高并发连接治理。

### 22.3 关键差异
1. Q21 是双向聊天；Q54 是事件驱动通知。
2. Q54 多通道（Push/SMS/Email）更重。
3. Q54 更强调用户偏好与模板。
4. Q54 更强调成本路由策略。
5. Q54 离线 inbox 是核心能力。

### 22.4 本题新增知识点（>=5）
1. 多通道路由与优先级策略。
2. 通知偏好管理。
3. 渠道回执统一收敛。
4. DLQ 回放补偿机制。
5. 在线推送+离线补拉统一模型。
6. 冷热通知分层存储。

### 22.5 面试差异话术
“Q21 讲会话消息系统，Q54 讲事件通知系统。通知题高分点在多通道路由、回执收敛、成本与时效平衡。”

---

## 单题自审（Q54）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦实时通知场景：通过。
2. API、MQ、多通道和冷热策略完整：通过。

### D. 工程落地检查
1. 阈值+处置动作齐全：通过。
2. RTO/RPO 和降级路径明确：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端 API 调用与重试幂等体现：通过。

### F. 母题差异检查
1. 与 Q21 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20
总分：96/100（通过）
