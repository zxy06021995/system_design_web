# Q10 秒杀系统（超高频）

## 1. 三句话题目本质
1. 秒杀系统核心是“在极端高并发下保证库存正确并尽可能多成交”。  
2. 难点不在下单页面，而在限流、预扣库存、异步下单、防刷和补偿。  
3. 面试高分关键：把“流量治理 + 一致性 + 故障兜底 + 用户体验”讲成闭环。  

## 2. 一个真实场景故事
某品牌手机开售 5 万台，活动开始 10 秒内冲进 300 万请求。早期系统直接打数据库，瞬间打挂且超卖 1200 单。改造后采用“网关限流 + Redis 预扣 + MQ 异步下单 + 订单超时回补”，活动期间成功率提升，超卖归零，用户等待时也能看到排队状态。  

## 3. 术语白话表（新手可懂）
1. Burst Traffic：瞬时突发流量。  
2. Pre-deduct：预扣库存，先占坑再异步落单。  
3. Token Gate：令牌闸门，没令牌不能进核心链路。  
4. Queueing：排队机制，平滑突发流量。  
5. Oversell：超卖，卖出数量超过库存。  
6. Idempotency：幂等，重复请求只处理一次。  
7. Backpressure：回压，系统满载时主动拒绝部分请求。  
8. Dead Letter Queue：死信队列，失败任务后续处理。  
9. Order Timeout：订单超时，未支付自动释放库存。  
10. Anti-bot：反机器人刷单。  
11. Warm-up：活动前预热缓存和连接池。  
12. Kill Switch：紧急熔断开关。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 活动开始后支持秒杀抢购。  
2. 支持库存预扣与下单异步确认。  
3. 支持订单超时释放库存。  
4. 支持防刷和风控拦截。  
5. 支持活动运营看板。  

### 4.2 非功能需求
1. 高并发承载（百万级瞬时请求）。  
2. 库存一致性（不能超卖）。  
3. 低延迟反馈（排队/成功/失败可见）。  
4. 高可用（单节点故障不影响活动进行）。  

### 4.3 不做范围
1. 不做完整支付网关内部实现。  
2. 不做复杂推荐系统。  
3. 不做物流履约调度。  

### 4.4 SLO/SLA
1. 核心抢购接口 P95 < 100ms（排队反馈）。  
2. 超卖率 = 0。  
3. 活动期间可用性 >= 99.95%。  

## 5. 容量估算（数字推导）
假设活动库存 5 万，峰值请求 30 万 QPS，活动前 5 分钟最猛：  
1. 网关必须先挡掉至少 95% 无效流量。  
2. 进入核心链路目标 QPS 控制在 1 万以内。  
3. 订单创建能力按 5000 TPS 设计，剩余请求排队或拒绝。  
4. MQ 峰值消息 60 万/分钟，保留 2 小时缓冲。  
5. 状态查询接口可能比下单接口高 3 倍，需要独立扩容。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`CDN/WAF -> 网关限流 -> Redis令牌+库存 -> MQ -> 订单服务 -> 支付 -> 库存回补`

### 6.2 完整版
1. Edge 层：CDN + WAF + 防刷验证码。  
2. Gate 层：活动资格校验、令牌发放、分层限流。  
3. Inventory 层：Redis 原子预扣库存。  
4. Queue 层：MQ 异步下单，削峰填谷。  
5. Order 层：订单状态机、幂等下单。  
6. Payment 层：支付回调触发最终确认。  
7. Timeout 层：超时关单与库存释放。  
8. Ops 层：活动监控、熔断开关、灰度策略。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `POST /v1/seckill/token`：领取秒杀令牌。  
2. `POST /v1/seckill/order`：提交秒杀请求。  
3. `GET /v1/seckill/order/{requestId}`：查询排队/下单状态。  
4. `POST /v1/seckill/admin/kill-switch`：紧急熔断（运维）。  

请求示例：
```json
{
  "activityId": 20260224,
  "skuId": 90001,
  "userId": 10086,
  "token": "tk_xxx",
  "idempotencyKey": "sec-20260224-10086-90001"
}
```

响应示例：
```json
{
  "requestId": "req_8899",
  "status": "QUEUED",
  "message": "排队中，请稍后刷新"
}
```

错误码：`429_TOO_MANY_REQUESTS`、`410_SOLD_OUT`、`403_RISK_REJECTED`、`409_DUPLICATE_REQUEST`。  

## 8. 数据模型（实体、索引、分片分区）
1. `seckill_activity`：活动配置、时间窗、库存。  
2. `stock_reservation`：`reservation_id`、`user_id`、`sku_id`、`status`、`expire_at`。  
3. `seckill_order`：`order_id`、`request_id`、`user_id`、`status`、`pay_deadline`。  
4. `risk_event`：风险分、设备指纹、拦截原因。  
5. `compensation_task`：失败补偿与库存回补任务。  
6. 索引：`idx_user_activity(user_id,activity_id)` 防重复参与。  
7. 分片：按 `activity_id + user_id hash` 分片写入。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：拿令牌 -> 预扣库存 -> 入队 -> 异步建单 -> 支付成功 -> 完成。  
2. 高峰：网关限流 + 令牌桶 + 用户排队页，核心链路只处理可成交流量。  
3. 故障恢复：订单服务故障 -> 消息堆积 -> 恢复后重放 -> 对账补偿库存。  

## 10. 一致性与事务边界
1. 预扣库存和下单异步拆分，依赖幂等与补偿保证最终一致。  
2. 支付回调是最终成交依据。  
3. 超时关单必须回补库存并可重试。  
4. 对账任务每天校验“库存变更总和 = 成交 + 回补”。  

## 11. 可用性与容错
1. 活动开关可秒级关闭，防全站雪崩。  
2. MQ 持久化防消息丢失。  
3. 下游慢时快速失败并返回排队状态。  
4. Redis 故障时进入“只读活动页 + 暂停下单”降级。  
5. RTO 10 分钟，RPO 1 分钟。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `seckill_accept_qps`  
2. `queue_wait_p95_ms`  
3. `stock_residual`  
4. `order_create_success_rate`  
5. `oversell_count`  

告警阈值：  
1. 排队等待 P95 > 5000ms（5分钟）-> P1。  
2. 建单成功率 < 97%（5分钟）-> P1。  
3. Redis 命中率 < 90%（10分钟）-> P2。  
4. `oversell_count > 0` 立刻 P0。  

处置：限流加严 -> 暂停低优先级流量 -> 扩容消费者 -> 对账回补。  

## 13. 安全与合规
1. 设备指纹 + 行为风控识别脚本和机器流量。  
2. 令牌绑定用户与商品，防转卖令牌。  
3. 管理端操作审计，防误操作。  
4. 敏感数据加密存储。  
5. 异常抢购行为实时封禁。  

## 14. 成本与取舍
1. 强实时一致会拖慢吞吐，秒杀更常用“最终一致 + 补偿”。  
2. 防刷过严会误杀真实用户，需灰度策略。  
3. 高峰预留资源贵，但能保障活动口碑。  
4. 过多状态轮询增加成本，可改为长轮询/推送。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 Redis 原子预扣库存
```java
public class StockPreDeductService {
    private final JedisPool pool;

    public boolean tryReserve(long activityId, long skuId, long userId) {
        String stockKey = "sec:stock:" + activityId + ":" + skuId;
        String userKey = "sec:user:" + activityId + ":" + skuId + ":" + userId;
        String lua = """
            if redis.call('exists', KEYS[2]) == 1 then return -2 end
            local stock = tonumber(redis.call('get', KEYS[1]) or '0')
            if stock <= 0 then return -1 end
            redis.call('decr', KEYS[1]); redis.call('setex', KEYS[2], 600, '1'); return 1
        """;
        try (Jedis jedis = pool.getResource()) {
            Object ret = jedis.eval(lua, List.of(stockKey, userKey), List.of());
            return Long.valueOf(1L).equals(ret);
        }
    }
}
```

### 15.2 幂等下单
```java
public class SeckillOrderService {
    private final OrderRepo repo;

    public String createOrder(SeckillRequest req) {
        if (repo.existsByIdempotencyKey(req.idempotencyKey())) {
            return repo.findOrderIdByIdempotencyKey(req.idempotencyKey());
        }
        String orderId = Ids.next();
        repo.insert(orderId, req.userId(), req.skuId(), "PENDING_PAY", req.idempotencyKey());
        return orderId;
    }
}
```

### 15.3 订单超时回补库存
```java
public class OrderTimeoutReleaseJob {
    public void release(Order order, StockGateway stockGateway, OrderRepo repo) {
        if (!"PENDING_PAY".equals(order.status())) return;
        if (order.payDeadline().isAfter(Instant.now())) return;
        stockGateway.restore(order.activityId(), order.skuId(), 1);
        repo.updateStatus(order.orderId(), "CANCELLED_TIMEOUT");
    }
}
```

### 15.4 消费者重试与死信
```java
public class OrderConsumer {
    public void consume(Message msg, int retryCount) {
        try {
            // build order
        } catch (Exception ex) {
            if (retryCount >= 5) {
                sendToDlq(msg);
            } else {
                requeueWithBackoff(msg, retryCount);
            }
        }
    }
}
```

### 15.5 对账修复
```java
public class SeckillReconcileService {
    public boolean check(long initialStock, long sold, long released, long currentStock) {
        return initialStock - sold + released == currentStock;
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 秒杀排队状态页（React + TS）
```tsx
type ReqStatus = { requestId: string; status: "QUEUED" | "SUCCESS" | "FAILED"; message: string };

export function SeckillQueuePage({ requestId }: { requestId: string }) {
  const [s, setS] = useState<ReqStatus | null>(null);
  useEffect(() => {
    const timer = setInterval(async () => {
      const r = await fetch(`/api/seckill/order/${requestId}`);
      setS(await r.json());
    }, 1500);
    return () => clearInterval(timer);
  }, [requestId]);
  return <div>{s ? `${s.status} - ${s.message}` : "查询中..."}</div>;
}
```

### 16.2 活动运维看板（React + TS）
```tsx
export function SeckillOpsPanel() {
  const [metrics, setMetrics] = useState<any>(null);
  async function refresh() {
    const r = await fetch("/api/seckill/ops/metrics");
    setMetrics(await r.json());
  }
  useEffect(() => { refresh(); }, []);
  return (
    <div>
      <button onClick={refresh}>刷新</button>
      <pre>{JSON.stringify(metrics, null, 2)}</pre>
    </div>
  );
}
```

## 17. 测试策略
1. 单测：预扣 Lua 原子性、幂等逻辑、超时回补。  
2. 集成：抢购 -> 排队 -> 下单 -> 支付 -> 回补全链路。  
3. 压测：30 万 QPS 突发与长尾轮询。  
4. 故障演练：Redis 故障、MQ 堆积、支付回调延迟。  
5. 对账回归：活动后库存一致性核验。  

## 18. 丰富例子（面试可复述）
1. 如何防止一个用户抢多单。  
2. 为什么先预扣再下单。  
3. 活动开始瞬间如何保护数据库。  
4. 支付超时后库存如何自动释放。  
5. 消息重复消费如何避免重复建单。  
6. 大量机器人流量如何拦截。  
7. MQ 堆积时用户体验怎么兜底。  
8. 误扣库存如何补偿。  
9. 活动结束后如何对账。  
10. 秒杀页高并发状态查询如何优化。  
11. 熔断开关何时触发。  
12. 活动前预热清单怎么做。  

## 19. 面试追问+回答模板
1. 问：如何保证不超卖？  
答：Redis 原子预扣 + 幂等建单 + 超时回补 + 对账修复，四层闭环保证。  
2. 问：为什么不用同步下单？  
答：同步会把流量打到数据库，异步队列可削峰并保护核心写链路。  
3. 问：用户体验如何保障？  
答：快速返回排队状态、可查询进度、失败原因可解释。  

## 20. 新手学习路线
1. 先学限流与令牌桶。  
2. 学 Redis 原子操作和 Lua。  
3. 学 MQ 异步削峰。  
4. 学订单状态机与超时回补。  
5. 学故障演练和对账闭环。  

## 21. 上场前Checklist
1. 能讲清“先限流再预扣再异步”的顺序。  
2. 能讲清超卖防线。  
3. 能给出告警阈值和应急动作。  
4. 能讲出幂等和补偿边界。  
5. 能讲出与母题差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q83 E-commerce Website`。  

### 22.2 共性能力
1. 都有订单、库存、支付链路。  
2. 都要求高可用和一致性。  
3. 都要处理高峰流量。  
4. 都要风控与审计。  

### 22.3 关键差异
1. Q83 是全链路电商平台，Q10 是极端高并发子场景。  
2. Q10 更强调瞬时流量治理和防超卖。  
3. Q10 接受排队与异步确认，Q83 更多常规同步交互。  
4. Q10 重点是活动时段策略，Q83 是长期稳定运营。  
5. Q10 核心指标是超卖率、排队时延、建单成功率。  

### 22.4 本题新增必补知识
1. 令牌闸门与资格校验。  
2. Redis 预扣库存原子策略。  
3. 异步下单与排队可视化。  
4. 订单超时回补库存。  
5. 活动后对账修复机制。  

### 22.5 面试差异话术
1. “Q10 是 Q83 的高压极限场景，目标从功能完整变成极端稳定。”  
2. “讲秒杀必须围绕削峰、限流、预扣、异步、补偿五件套。”  
3. “Q83 更像日常运营，Q10 更像大促战时架构。”  
