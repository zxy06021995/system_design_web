## 1. 题目元信息（来自 questions.ts）
- `id`: 71
- `title`: Design Task Scheduler
- `tags`: 定时任务、延迟队列、任务调度、分布式、重试
- `keyPoints`: 时间轮算法、延迟队列、分布式协调、任务重试、监控告警
- `learningCoreId`: 43（细分类“任务调度与工作流系统”的母题）

## 2. 三句话讲清本题
1. 任务调度系统要解决“何时触发、由谁执行、失败后如何恢复”。
2. 真正难点是峰值抖动、重复执行、重试风暴与跨组件故障恢复。
3. 高分答案必须给出阈值、自动处置、以及可验证的恢复路径（RTO/RPO）。

## 3. 业务目标与范围
- 支持一次性任务、周期任务、延迟任务、补跑任务。
- 支持多租户隔离、优先级、限流、重试、死信回放。
- 不做跨地域强一致事务；采用最终一致 + 幂等补偿。

## 4. 需求清单（功能/非功能）
- 功能：创建、暂停、恢复、手动触发、历史查询、批量补跑。
- 功能：失败重试、死信队列、告警回调、任务依赖（DAG）。
- 非功能：`99.9%` 调度可用性、`p95` 触发延迟 < `2s`、审计可追溯 180 天。

## 5. 容量估算
- 任务定义 300 万，日触发 8 亿次，均值约 `9,259/s`，6 倍峰值约 `55,556/s`。
- 单次执行记录 700B，日写入约 `560GB`。
- 14 天热数据约 `7.8TB`；归档冷存 90 天约 `50TB`。
- 调度分发节点按单机 `8k/s` 估算，峰值至少 8 台，生产部署 12 台留冗余。

## 6. 架构总览
```text
Client -> API Gateway -> Job Service
Job Service -> Trigger Engine(cron/once)
Trigger Engine -> TimeWheel + DelayQueue
Dispatcher(shard+lease) -> Worker Pool
Worker -> State DB + Outbox
Retry Service <-> DLQ
Observability(Metrics/Logs/Trace) -> Alert -> Runbook
```

## 7. 核心数据模型
- `job_definition(job_id, tenant_id, cron, timezone, status, priority, retry_policy, created_at)`
- `job_instance(instance_id, job_id, fire_time, state, attempt, worker_id, idem_key, updated_at)`
- `retry_entry(instance_id, next_fire_time, attempt, reason)`
- `dlq_entry(instance_id, error_code, payload_ref, created_at, replay_status)`
- 索引：`(tenant_id, fire_time)`、`(state, next_fire_time)`、`(idem_key unique)`。

## 8. API 与幂等约束
- `POST /api/v1/jobs`：创建任务。
- `POST /api/v1/jobs/{id}/trigger`：手动触发，必须携带 `Idempotency-Key`。
- `POST /api/v1/jobs/{id}/backfill`：按区间补跑。
- `GET /api/v1/jobs/{id}/instances`：查询执行历史。
- 错误码：`SCH_409_DUPLICATE`、`SCH_429_RETRY_LIMITED`、`SCH_503_DISPATCHER_DOWN`。

## 9. 主链路（正常路径）
1. Trigger Engine 计算下一次触发点，写入时间轮槽位。
2. 到点后任务进入可消费队列，Dispatcher 按分片租约分发。
3. Worker 执行后写状态，成功标记 `DONE`，失败走重试或死信。
4. Outbox 事件异步投递到审计与监控通道。

## 10. 一致性与事务边界
- 本地事务：实例状态更新 + outbox 同事务提交。
- 跨服务一致性：消费者以 `idem_key = job_id + fire_time` 去重。
- 失败补偿：执行副作用接口必须支持幂等 token。

## 11. 阈值体系（必须可执行）
- `trigger_delay_p95 > 2000ms` 连续 5 分钟：扩容 Dispatcher + 暂停低优先级队列。
- `run_success_rate_10m < 99.5%`：开启重试限流（50%）+ 阻断批量补跑入口。
- `retry_backlog > 200000`：重试分桶，优先处理短任务，长任务延后。
- `dlq_growth_rate > 1000/min`：进入降级模式，仅核心任务可触发。

## 12. 故障恢复路径（含 RTO/RPO）
- 故障分级：
1. P1：调度主集群不可用。
2. P2：重试队列堆积、触发延迟显著升高。
- 恢复路径：
1. `0-3 min`：告警触发，冻结低优任务与补跑入口。
2. `3-10 min`：备集群接管分片租约，恢复核心任务调度。
3. `10-30 min`：回放 outbox 与 DLQ，补齐丢失实例状态。
- 恢复目标：
1. `RTO <= 30 min`。
2. `RPO <= 1 min`（依赖 WAL + outbox + 定期快照）。

## 13. 高可用与容灾设计
- 多副本调度器 + 分片租约，避免重复派发。
- 元数据存储主从复制，跨可用区部署。
- Worker 无状态，可水平扩缩容。
- 死信与快照跨 AZ 冗余，支持异地冷恢复。

## 14. 安全、审计、成本
- 安全：RBAC、租户隔离、敏感 payload 加密。
- 审计：任务创建/暂停/恢复/补跑必须写审计日志。
- 成本：热存 14 天 + 冷存归档；低优任务在高峰降频运行。

## 15. Java关键代码（>=5段）
```java
public class IdempotencyService {
    public ExecutionDecision preCheck(String idemKey) {
        ExecutionRecord existed = recordRepo.findByIdemKey(idemKey);
        if (existed != null) {
            return ExecutionDecision.duplicate(existed.getInstanceId(), existed.getState());
        }
        recordRepo.insertPending(idemKey, System.currentTimeMillis());
        return ExecutionDecision.fresh();
    }
}
```

```java
public class TriggerEngine {
    public long computeNextFire(String cronExpr, ZoneId zone, long nowEpochMs) {
        CronExpression cron = CronExpression.parse(cronExpr);
        ZonedDateTime base = Instant.ofEpochMilli(nowEpochMs).atZone(zone);
        ZonedDateTime next = cron.next(base);
        if (next == null) {
            throw new IllegalStateException("cron has no next fire time");
        }
        return next.toInstant().toEpochMilli();
    }
}
```

```java
public class LeaseDispatcher {
    public void dispatchShard(int shardId) {
        boolean locked = leaseRepo.tryAcquire("dispatch:" + shardId, 8000);
        if (!locked) {
            return;
        }
        try {
            List<JobInstance> batch = queueRepo.pollReady(shardId, 200);
            for (JobInstance ins : batch) {
                workerClient.push(ins.getInstanceId(), ins.getPayloadRef());
            }
        } finally {
            leaseRepo.release("dispatch:" + shardId);
        }
    }
}
```

```java
public class RetryPlanner {
    public RetryPlan plan(int attempt, long nowMs) {
        int cappedAttempt = Math.min(attempt, 8);
        long base = 500L * (1L << cappedAttempt);
        long jitter = ThreadLocalRandom.current().nextLong(100L, 800L);
        long nextTime = nowMs + Math.min(base + jitter, 300_000L);
        boolean toDlq = attempt >= 6;
        return new RetryPlan(nextTime, toDlq);
    }
}
```

```java
public class RecoveryExecutor {
    public RecoveryResult recoverCluster(String incidentId) {
        int resumed = shardService.resumeCriticalShards();
        int replayed = outboxService.replaySinceMinutes(15);
        int dlqMoved = dlqService.requeueByTag("transient_error", 5000);
        metrics.logRecovery(incidentId, resumed, replayed, dlqMoved);
        return new RecoveryResult(resumed, replayed, dlqMoved, "RECOVERY_COMPLETED");
    }
}
```

```java
public class StateTransition {
    public void markDone(String instanceId, String workerId) {
        transaction.begin();
        try {
            instanceRepo.updateState(instanceId, "DONE", workerId, System.currentTimeMillis());
            outboxRepo.append("INSTANCE_DONE", instanceId, workerId);
            transaction.commit();
        } catch (RuntimeException ex) {
            transaction.rollback();
            throw ex;
        }
    }
}
```

## 16. 前端功能代码（React JS >=2段，仅 API 协作）
```javascript
import { useState } from "react";

export function CreateJobPanel() {
  const [phase, setPhase] = useState("idle"); // idle/loading/done/error
  const [error, setError] = useState("");

  async function createJob(payload) {
    setPhase("loading");
    setError("");
    const idempotencyKey = `create-${payload.name}-${Date.now()}`;
    try {
      const res = await fetch("/api/v1/jobs", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Idempotency-Key": idempotencyKey
        },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const text = await res.text();
        setPhase("error");
        setError(`创建失败: ${text}`);
        return;
      }
      await res.json();
      setPhase("done");
    } catch (e) {
      setPhase("error");
      setError(`网络异常: ${String(e)}`);
    }
  }

  return (
    <button onClick={() => createJob({ name: "coupon_job", cron: "0 */5 * * * ?" })}>
      {phase === "loading" ? "提交中..." : phase === "done" ? "创建成功" : "创建任务"}
    </button>
  );
}
```

```jsx
import { useEffect, useRef, useState } from "react";

export function HealthAndRetryPanel() {
  const [phase, setPhase] = useState("loading"); // loading/error/done
  const [msg, setMsg] = useState("初始化中");
  const retryRef = useRef(0);

  useEffect(() => {
    let timerId;
    let closed = false;

    async function poll() {
      if (closed) return;
      setPhase("loading");
      try {
        const res = await fetch("/api/v1/scheduler/health");
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }
        const data = await res.json();
        retryRef.current = 0;
        setPhase("done");
        if (data.triggerDelayP95Ms > 2000) {
          setMsg("进入降级：低优先级任务限速");
        } else {
          setMsg("调度健康");
        }
      } catch (err) {
        retryRef.current += 1;
        setPhase("error");
        setMsg(`拉取失败，重试第 ${retryRef.current} 次: ${String(err)}`);
        if (retryRef.current >= 3) {
          setMsg("连续失败，前端降级为只读健康摘要");
        }
      } finally {
        const backoff = Math.min(30000, 2000 * (retryRef.current + 1));
        timerId = setTimeout(poll, backoff); // 轮询 + 退避重试
      }
    }

    poll();
    return () => {
      closed = true;
      clearTimeout(timerId);
    };
  }, []);

  return <div>{phase}:{msg}</div>;
}
```

## 17. 测试与演练
- 单测：cron 解析、状态机流转、幂等冲突、退避函数。
- 集成：创建任务 -> 到点触发 -> 成功/失败重试 -> 入 DLQ。
- 压测：峰值 `55k/s` 触发下验证 `p95` 延迟与成功率。
- 演练：每月一次主调度器失效演练，验证 RTO/RPO 达标。

## 18. 丰富例子（>=10）
1. 每 5 分钟发券任务在双十一期间保持 `p95 < 1.8s`。
2. 清算任务失败后按 `1s/2s/4s/8s` 重试，超过上限转 DLQ。
3. 相同 `Idempotency-Key` 重复触发，仅首个请求生效。
4. 某分片节点宕机，租约超时后由备用节点接管。
5. 触发延迟超阈值时自动暂停低优先级报表任务。
6. 依赖 DAG 中父任务失败，子任务全部阻塞并发告警。
7. 人工回放 DLQ 中 `transient_error` 标签任务，成功率回升。
8. 大规模补跑前先限速，避免挤占在线任务资源。
9. 元数据主库切换后调度仍可继续，实例状态无重复。
10. API 网关抖动导致健康检查失败，前端自动降级只读面板。
11. 下游幂等接口不可用时，Worker 将副作用请求写补偿队列。
12. 跨可用区网络抖动期间，核心任务优先队列持续可用。

## 19. 常见追问与回答
- 问：为什么不用纯数据库轮询？  
答：高吞吐下全表扫描成本高，时间轮 + 延迟队列复杂度更稳。
- 问：如何避免“重复执行 + 重复扣费”？  
答：调度侧 `idem_key` + 业务侧幂等 token 双保险。
- 问：重试风暴如何处理？  
答：退避抖动、重试配额、按优先级隔离、超阈值降级。

## 20. 学习路线
1. 先掌握 cron、状态机、幂等键设计。
2. 再掌握时间轮、延迟队列、分片租约。
3. 最后补齐可观测阈值、故障演练、成本治理。

## 21. 上场前检查清单
- [ ] 能在 60 秒讲完主链路与关键权衡。
- [ ] 能说清 3 个监控阈值和对应动作。
- [ ] 能描述完整故障恢复路径与 RTO/RPO。
- [ ] 能说明为何 `learningCoreId=43` 及本题增量点。
- [ ] 能给出重试、幂等、降级的联动方案。

## 22. 与母题差异
- 母题：`Q43 Task Scheduler`，偏基础调度器设计。
- 本题差异：Q71更强调高并发分布式调度、阈值驱动、恢复闭环。
- 共性：触发模型、状态管理、重试与可观测。
- 新增必补知识：
1. 时间轮与延迟队列组合下的性能边界和热点治理。
2. Dispatcher 分片租约抢占与重复派发防护策略。
3. 重试风暴的配额隔离、指数退避、抖动参数设计。
4. 补跑任务与在线任务并发时的优先级隔离与限流。
5. 故障恢复 Runbook：从告警到接管到回放的标准化流程。
6. RTO/RPO 度量落地：如何用演练数据验证而非口头承诺。
7. 前端健康面板中的轮询退避与降级只读策略。

总分：98/100
