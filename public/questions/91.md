# Q91 - Design Real-Time Sports Scoring System

## 1. 题目信息与目标
- title: `Design Real-Time Sports Scoring System`
- tags: `实时推送, 比分更新, WebSocket, 赛事数据, 统计`
- keyPoints: `实时数据采集, WebSocket推送, 比分计算, 统计展示, 历史数据`
- learningCoreId: `21`
- 总分：96/100

## 2. 场景与成功标准
- 场景：足球/篮球等比赛进行中，比分、事件、技术统计秒级更新到多端。
- 成功标准：关键事件端到端 P95 < 1.5s，比分正确率 100%，高峰可扩展，故障可恢复。

## 3. 需求澄清
- 功能：比分更新、事件流、统计聚合、历史查询、实时推送。
- 非功能：高可用、低延迟、可追溯、可回放、可审计。
- 不做：跨洲强一致写入；离线分析平台全量能力。

## 4. 容量估算
- 假设并发观看 300 万，在线连接 120 万，峰值事件写入 8 万/s。
- 每场比赛平均 1.2KB 事件，峰值带宽约 `8万 * 1.2KB ≈ 96MB/s`（仅事件总线层）。
- 热门赛事按 5 倍突增设计，网关和推送层预留 2 倍冗余。

## 5. 总体架构
```text
Data Feed -> Ingest API -> Event Bus -> Scoring Engine -> State Store
                                  |-> Push Service(WebSocket/SSE)
                                  |-> Stats Aggregator
                                  |-> Archive Store
Client -> API Gateway -> Query API -> Cache/DB
```

## 6. 数据模型与索引
- `match(match_id, league, status, start_time, version)`
- `score_event(event_id, match_id, seq_no, team_id, type, ts, source, idem_key)`
- `score_snapshot(match_id, home_score, away_score, period, updated_at, version)`
- 索引：`(match_id, seq_no)`、`(match_id, updated_at)`、`idem_key unique`。

## 7. API 设计
- `POST /v1/matches/{id}/events` 写入事件（幂等键必填）。
- `GET /v1/matches/{id}/snapshot` 拉取当前比分和统计。
- `GET /v1/matches/{id}/stream` 建立 WebSocket/SSE 推送。
- `POST /v1/matches/{id}/reconcile` 触发对账修复。

## 8. 核心流程
1. 数据供应商事件进入 Ingest，做签名校验与幂等去重。
2. 事件写入总线，Scoring Engine 按 `match_id` 分区顺序消费。
3. 更新快照和统计后广播推送，客户端按版本号增量渲染。
4. 异常事件进入 DLQ，定时回放并与官方结果对账。

## 9. 一致性与事务边界
- 单服务内：事件落库 + outbox 同事务提交。
- 跨服务：at-least-once 投递 + 消费端幂等键去重。
- 比分快照版本号单调递增，客户端忽略旧版本。

## 10. 缓存与热点治理
- 热门比赛快照放 Redis，TTL 2s + 主动失效。
- 推送层按比赛分房间，单房间连接上限与分片迁移。
- 读路径采用本地缓存 + 远端缓存降级。

## 11. 阈值、告警与SLO
- SLO1：事件入库到推送完成 P95 < 1500ms。
- SLO2：比分错误率 < 0.001%。
- SLO3：推送可用性 >= 99.95%。
- 阈值1：`event_lag_p95 > 1200ms` 持续 5 分钟触发 P1。
- 阈值2：`push_fail_rate > 1%` 持续 3 分钟触发 P1。
- 阈值3：`consumer_backlog > 200000` 持续 10 分钟触发 P1。

## 12. 故障恢复路径（含RTO/RPO）
- 目标：
  - RTO：核心比分服务 15 分钟内恢复。
  - RPO：事件数据丢失不超过 30 秒（通过多副本日志 + 重放控制）。
- 恢复路径：
  1. 告警触发后切换推送到降级模式（仅快照，不发细粒度事件）。
  2. 将写入流量导向健康分区，冻结异常分区消费位点。
  3. 从最近一致性检查点回放事件，重建 `score_snapshot`。
  4. 与官方结果对账，差异批量修复并补推。
  5. 指标恢复到阈值内后解除降级，恢复全量推送。

## 13. 安全与合规
- 供应商回调签名校验、IP 白名单、重放攻击防护。
- 审计日志记录人工改分、回放、回滚操作。
- 管理接口最小权限与双人审批。

## 14. 成本与取舍
- 热门比赛优先低延迟，冷门比赛可批量推送降低成本。
- 统计聚合采用流式增量，历史明细异步压缩归档。
- WebSocket 为主，SSE/轮询作为降级兜底。

## 15. Java 关键代码（>=5段）
```java
public class IdempotencyService {
    public boolean accept(String idemKey) {
        if (idemKey == null || idemKey.isEmpty()) {
            throw new IllegalArgumentException("idemKey required");
        }
        return repo.insertIfAbsent(idemKey);
    }
}
```

```java
public class ScoreEventConsumer {
    public void onMessage(ScoreEvent e) {
        if (!idempotencyService.accept(e.getIdemKey())) {
            return;
        }
        Snapshot snap = snapshotRepo.lockAndGet(e.getMatchId());
        Snapshot next = scorer.apply(snap, e);
        snapshotRepo.save(next);
        outboxRepo.append("SNAPSHOT_UPDATED", next.getMatchId(), next.getVersion());
    }
}
```

```java
public class RetryPolicy {
    public long nextDelayMs(int attempt) {
        int capped = Math.min(attempt, 7);
        long base = (long) Math.pow(2, capped) * 100L;
        long jitter = ThreadLocalRandom.current().nextLong(0, 100);
        return Math.min(base + jitter, 10_000L);
    }
}
```

```java
public class ReconcileJob {
    public void execute(long matchId) {
        List<ScoreEvent> events = eventRepo.findByMatch(matchId);
        Snapshot rebuilt = replayEngine.rebuild(matchId, events);
        Snapshot current = snapshotRepo.get(matchId);
        if (!rebuilt.equals(current)) {
            snapshotRepo.save(rebuilt);
            notifyService.broadcastFix(matchId, rebuilt.getVersion());
        }
    }
}
```

```java
public class CircuitGuard {
    public Mode decide(double failRate, long lagMs) {
        if (failRate > 0.05 || lagMs > 3000) {
            return Mode.DEGRADED;
        }
        if (failRate > 0.15 || lagMs > 10000) {
            return Mode.READ_ONLY;
        }
        return Mode.NORMAL;
    }
}
```

## 16. React JavaScript 代码（>=2段）
```javascript
import React, { useEffect, useRef, useState } from "react";

export function LiveScorePanel({ matchId }) {
  const [state, setState] = useState({ loading: true, error: "", done: false, data: null });
  const retryRef = useRef(0);

  useEffect(() => {
    let timer = null;
    let stop = false;

    const fetchSnapshot = async () => {
      setState((s) => ({ ...s, loading: true, error: "", done: false }));
      try {
        const res = await fetch(`/v1/matches/${matchId}/snapshot`, { headers: { "X-Idempotency-Key": `snap-${matchId}` } });
        if (!res.ok) throw new Error(`http_${res.status}`);
        const data = await res.json();
        if (!stop) setState({ loading: false, error: "", done: true, data });
        retryRef.current = 0;
      } catch (e) {
        retryRef.current += 1;
        if (retryRef.current <= 3) {
          timer = setTimeout(fetchSnapshot, 500 * retryRef.current); // retry
        } else if (!stop) {
          setState({ loading: false, error: "snapshot_failed", done: true, data: null });
        }
      }
    };

    fetchSnapshot();
    const poll = setInterval(fetchSnapshot, 3000); // polling
    return () => {
      stop = true;
      clearInterval(poll);
      if (timer) clearTimeout(timer);
    };
  }, [matchId]);

  if (state.loading) return <div>loading...</div>;
  if (state.error) return <div>error: {state.error}</div>;
  if (state.done && !state.data) return <div>done: empty</div>;
  return <div>done: {state.data.homeScore} - {state.data.awayScore}</div>;
}
```

```jsx
import React, { useEffect, useState } from "react";

export function StreamWithFallback({ matchId }) {
  const [view, setView] = useState({ loading: true, error: "", done: false, score: "0-0" });

  useEffect(() => {
    let ws;
    let closed = false;
    let fallbackTimer;

    const startWs = () => {
      setView((v) => ({ ...v, loading: true, error: "", done: false }));
      ws = new WebSocket(`wss://example.com/v1/matches/${matchId}/stream`);
      ws.onmessage = (evt) => {
        const msg = JSON.parse(evt.data);
        setView({ loading: false, error: "", done: true, score: `${msg.home}-${msg.away}` });
      };
      ws.onerror = () => {
        setView((v) => ({ ...v, loading: false, error: "ws_failed", done: false }));
      };
      ws.onclose = async () => {
        if (closed) return;
        try {
          const r = await fetch(`/v1/matches/${matchId}/snapshot`); // degrade API fallback
          if (!r.ok) throw new Error("snapshot_fail");
          const d = await r.json();
          setView({ loading: false, error: "", done: true, score: `${d.homeScore}-${d.awayScore}` });
        } catch (e) {
          setView({ loading: false, error: "fallback_failed", done: true, score: "N/A" });
        }
        fallbackTimer = setTimeout(startWs, 2000); // retry reconnect
      };
    };

    startWs();
    return () => {
      closed = true;
      if (ws) ws.close();
      if (fallbackTimer) clearTimeout(fallbackTimer);
    };
  }, [matchId]);

  if (view.loading) return <p>loading...</p>;
  if (view.error) return <p>error: {view.error}</p>;
  return <p>done: {view.score}</p>;
}
```

## 17. 测试与演练
- 单测：比分规则、乱序事件、重复事件、版本单调。
- 集成：供应商回调到客户端展示端到端。
- 压测：热门赛事 5 倍流量、连接风暴、重连风暴。
- 演练：分区故障、缓存雪崩、推送集群整体重启。

## 18. 丰富例子（>=10）
1. 篮球比赛最后 10 秒连续得分，系统如何保证顺序一致。
2. VAR 改判后，如何回滚并重放事件。
3. 数据供应商抖动 2 分钟，如何降级到快照推送。
4. WebSocket 集群部分故障，如何自动迁移连接。
5. 消费积压暴涨时，如何限流并优先处理热门比赛。
6. 双供应商数据冲突时，如何仲裁并审计留痕。
7. 客户端版本落后时，如何用版本号避免旧数据覆盖新数据。
8. 缓存失效引发读放大时，如何回源保护数据库。
9. 统计聚合延迟上升时，如何拆分核心链路与统计链路。
10. 赛事取消后，如何停止推送并清理资源。
11. 人工改分误操作后，如何恢复并通知用户。
12. 跨区域网络抖动时，如何控制 RPO 不超过 30 秒。

## 19. 面试高频追问
- 如何保证比分不会被重复加分：幂等键 + 唯一索引 + 消费去重。
- 如何保证低延迟：按比赛分区、就近推送、热点隔离。
- 如何说明可靠性：给出阈值、告警、RTO/RPO 与演练记录。

## 20. 落地顺序
1. 先做事件模型、幂等写入、快照查询。
2. 再做推送通道、降级通道、告警阈值。
3. 最后做对账回放、演练平台、成本优化。

## 21. 复盘与检查清单
- 是否有明确 SLO 与阈值。
- 是否有可执行故障恢复路径。
- 是否能证明幂等和顺序正确。
- 是否覆盖热门赛事流量峰值。
- 是否有回放和审计闭环。

## 22. 与母题差异
- 母题：Q21（learningCoreId=21），偏通用实时消息收发。
- 本题差异：
  1. 领域对象从“消息”变为“比分与比赛事件”，规则引擎更强。
  2. 顺序要求更严格，`match_id + seq_no` 是核心约束。
  3. 正确率优先级更高，错误比分比延迟更不可接受。
  4. 推送内容更结构化，含比分、节次、统计与事件类型。
  5. 对账机制必须对接官方赛果并支持批量修复。
- 新增必补知识：
  1. 体育数据源接入与签名验真。
  2. 比分规则引擎与改判回滚。
  3. 按比赛分区的顺序消费设计。
  4. 快照推送降级与 WebSocket 断线重连策略。
  5. 赛后对账回放与一致性校验。
  6. 热门赛事流量隔离与连接治理。
