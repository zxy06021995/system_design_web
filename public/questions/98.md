# Q98：Design Podcast Hosting Platform

## 1. 题目定义与评分
总分：97/100。  
本题目标是设计播客托管平台，覆盖上传、RSS 分发、订阅、发现、统计报表。  
高分标准：功能完整、链路可恢复、阈值可执行、故障可演练。

## 2. 源数据读取结果（来自 src/data/questions.ts）
- title: `Design Podcast Hosting Platform`
- tags: `播客`、`RSS`、`音频托管`、`订阅`、`发现`
- keyPoints: `RSS生成`、`音频CDN`、`订阅管理`、`内容发现`、`统计报表`
- learningCoreId: `22`

## 3. 业务目标与边界
- 业务目标：让创作者稳定上传并发布播客，让听众稳定订阅并收听。
- 核心边界：平台侧只保证托管、分发、订阅与统计，不承担复杂版权交易流程。
- 成功标准：发布成功率、播放首帧时延、订阅同步时延、统计延迟可量化达标。

## 4. 需求澄清（功能）
1. 音频上传、转码、存储、分发。
2. RSS Feed 自动生成与增量更新。
3. 订阅管理（关注、取消、变更通知）。
4. 内容发现（分类、推荐、检索）。
5. 统计报表（播放量、完播率、地域分布）。

## 5. 非功能需求（SLO/SLA）
1. 可用性目标：核心 API 月可用性 >= 99.95%。
2. 上传发布链路：P95 <= 800ms（不含异步转码完成时间）。
3. RSS 拉取 API：P95 <= 200ms。
4. 统计面板延迟：T+5 分钟内可见。
5. 数据正确性：关键计费/结算字段最终一致，日终对账差异率 <= 0.01%。

## 6. 容量估算
1. 100 万日活，20 万创作者，日新增节目 15 万条。
2. 平均音频 40MB，日入库约 6TB，副本 3x 后约 18TB/天。
3. 峰值上传 QPS 2,000；RSS 拉取峰值 QPS 50,000（热点节目集中）。
4. 统计事件写入峰值 30 万 EPS，冷存储按 180 天保留。
5. CDN 回源上限控制在总流量的 8% 内。

## 7. 架构总览
`Client -> API Gateway -> Upload Service -> Object Storage -> Transcode Worker -> Metadata DB -> RSS Service -> CDN -> Listener App`  
`Stats SDK -> Event Bus -> Stream Compute -> OLAP Store -> Dashboard`  
`Control Plane -> Config/Feature Flag -> Circuit Breaker/Rate Limit`

## 8. 数据模型与索引
1. `podcast_show(show_id, creator_id, title, category, status, created_at)`
2. `episode(ep_id, show_id, audio_key, duration, publish_at, rss_version, state)`
3. `subscription(user_id, show_id, status, updated_at)` 复合索引 `(show_id, status, updated_at)`
4. `play_event(event_id, ep_id, user_id, ts, play_ms, device, region)` 分区按天
5. `rss_snapshot(show_id, version, xml_blob, hash, generated_at)` 便于回滚和对比

## 9. 核心流程
1. 上传发布：上传 -> 病毒扫描 -> 转码 -> 元数据落库 -> 触发 RSS 生成 -> CDN 预热。
2. 订阅流程：订阅请求 -> 幂等校验 -> 关系写入 -> 通知投递 -> 推荐特征更新。
3. 播放统计：播放事件 SDK 上报 -> MQ -> 流式聚合 -> OLAP -> 报表展示。

## 10. API 设计
1. `POST /api/episodes/upload`：上传音频，返回 `uploadId`。
2. `POST /api/episodes/{epId}/publish`：发布节目，返回 `rssVersion`。
3. `GET /api/shows/{showId}/rss`：拉取 RSS XML（支持 `If-None-Match`）。
4. `POST /api/subscriptions`：订阅/取消订阅（请求需 `Idempotency-Key`）。
5. `GET /api/analytics/shows/{showId}`：拉取统计报表。

## 11. 一致性、幂等与事务边界
1. 单服务内：本地事务保证 `episode + outbox` 原子写入。
2. 跨服务：Outbox + MQ + 幂等消费，保证最终一致。
3. 幂等键：`creatorId + clientRequestId`，写入 24 小时去重表。
4. 回放机制：DLQ 事件支持按 `event_id` 定向重放。
5. 补偿动作：RSS 版本冲突时触发快照回退和重新生成。

## 12. 阈值与故障恢复路径（含 RTO/RPO）
1. 告警阈值：
- 上传失败率 > 1% 持续 5 分钟触发 P1。
- RSS 生成延迟 P95 > 3 分钟持续 10 分钟触发 P1。
- 订阅写入错误率 > 0.5% 持续 5 分钟触发 P1。
- 统计管道积压 > 15 分钟触发 P2。
2. RTO/RPO 目标：
- RSS 服务故障：`RTO <= 15 分钟`，`RPO <= 1 分钟`。
- 订阅服务故障：`RTO <= 20 分钟`，`RPO = 0`（主库 + 同步复制）。
- 统计报表故障：`RTO <= 60 分钟`，`RPO <= 5 分钟`。
3. 恢复路径：
- 第一步止血：网关限流 + 降级返回缓存 RSS。
- 第二步切换：服务发现摘除故障实例，流量切只读副本或备用集群。
- 第三步修复：回放 Outbox/DLQ，重建 RSS 快照，校验哈希一致。
- 第四步收敛：对账任务核对 `episode/rss_snapshot/subscription` 差异并自动补偿。

## 13. 高可用与降级策略
1. 多可用区部署：API、RSS、订阅、统计均 N+1。
2. 降级优先级：发布写入 > RSS 拉取 > 发现推荐 > 统计大盘。
3. CDN 故障时：回源限速 + 热门节目静态副本兜底。
4. MQ 积压时：暂停低优先级统计事件，仅保留关键计费事件。
5. 外部依赖超时：熔断 + 指数退避重试 + 兜底缓存。

## 14. 安全、合规与成本
1. 上传鉴权：短期签名 URL + 内容类型白名单。
2. 数据合规：PII 字段脱敏，传输与静态加密。
3. 审计：发布、下架、回滚、权限变更全留痕。
4. 成本策略：冷热分层存储、转码档位按节目热度动态调整。
5. 反滥用：上传频控、异常订阅行为识别、机器人流量拦截。

## 15. Java 关键代码（>=5）
```java
public class IdempotencyService {
    public boolean tryAcquire(String key, Duration ttl) {
        long now = System.currentTimeMillis();
        Long old = store.putIfAbsent(key, now + ttl.toMillis());
        if (old == null) {
            return true;
        }
        if (old < now) {
            store.replace(key, old, now + ttl.toMillis());
            return true;
        }
        return false;
    }
}
```

```java
public class PublishService {
    public PublishResult publish(long episodeId, String idemKey) {
        if (!idempotencyService.tryAcquire("publish:" + idemKey, Duration.ofHours(24))) {
            return PublishResult.duplicate(episodeId);
        }
        transactionTemplate.executeWithoutResult(tx -> {
            episodeRepo.markPublishing(episodeId);
            outboxRepo.append("EPISODE_PUBLISH", String.valueOf(episodeId));
        });
        return PublishResult.accepted(episodeId);
    }
}
```

```java
public class RssGenerator {
    public RssSnapshot generate(Show show, List<Episode> episodes) {
        String xml = xmlRenderer.render(show, episodes);
        String hash = sha256(xml);
        long version = rssRepo.nextVersion(show.getId());
        RssSnapshot snapshot = new RssSnapshot(show.getId(), version, xml, hash, Instant.now());
        rssRepo.save(snapshot);
        return snapshot;
    }
}
```

```java
public class RetryExecutor {
    public void runWithBackoff(Runnable task, int maxRetry) {
        for (int i = 1; i <= maxRetry; i++) {
            try {
                task.run();
                metrics.count("retry.success", 1);
                return;
            } catch (Exception ex) {
                long sleepMs = Math.min(30_000L, (1L << i) * 200L);
                sleepMs += ThreadLocalRandom.current().nextLong(50, 250);
                metrics.count("retry.fail", 1);
                if (i == maxRetry) {
                    dlq.publish("retry_exhausted", ex.getMessage());
                    throw ex;
                }
                LockSupport.parkNanos(sleepMs * 1_000_000L);
            }
        }
    }
}
```

```java
public class RecoveryOrchestrator {
    public void recoverRssIncident(long showId) {
        RssSnapshot latest = rssRepo.findLatest(showId);
        if (latest == null) {
            List<Episode> episodes = episodeRepo.findPublishedByShow(showId);
            Show show = showRepo.findById(showId);
            RssSnapshot snapshot = rssGenerator.generate(show, episodes);
            cdnService.purgeAndWarm(showId, snapshot.getVersion());
            return;
        }
        cdnService.purgeAndWarm(showId, latest.getVersion());
        reconcileService.verify(showId, latest.getHash());
    }
}
```

## 16. React JavaScript 代码（>=2）
```javascript
import React, { useEffect, useRef, useState } from "react";

export function RssHealthPanel({ showId }) {
  const [state, setState] = useState("loading"); // loading | done | error
  const [data, setData] = useState(null);
  const [error, setError] = useState("");
  const timerRef = useRef(null);

  useEffect(() => {
    let stopped = false;
    async function poll() {
      setState("loading");
      try {
        const resp = await fetch(`/api/shows/${showId}/rss/health`);
        if (!resp.ok) {
          throw new Error(`HTTP_${resp.status}`);
        }
        const json = await resp.json();
        if (stopped) return;
        setData(json);
        setError("");
        setState("done");
      } catch (e) {
        if (stopped) return;
        setError("拉取失败，进入降级缓存视图");
        setState("error");
      } finally {
        if (!stopped) {
          timerRef.current = setTimeout(poll, 5000); // 轮询
        }
      }
    }
    poll();
    return () => {
      stopped = true;
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, [showId]);

  if (state === "loading") return <div>loading...</div>;
  if (state === "error") return <div>error: {error}</div>;
  return <div>done: rssVersion={data?.version}, p95={data?.p95Ms}ms</div>;
}
```

```jsx
import React, { useState } from "react";

export function SubscribeButton({ userId, showId }) {
  const [state, setState] = useState("done"); // loading | done | error
  const [error, setError] = useState("");

  async function submitWithRetry(action) {
    const idemKey = `${userId}-${showId}-${action}`;
    setState("loading");
    setError("");
    for (let i = 0; i < 3; i++) {
      try {
        const resp = await fetch("/api/subscriptions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Idempotency-Key": idemKey
          },
          body: JSON.stringify({ userId, showId, action })
        });
        if (resp.ok) {
          setState("done");
          return;
        }
        if (resp.status >= 500) {
          await new Promise(r => setTimeout(r, 200 * (i + 1)));
          continue; // 重试
        }
        throw new Error(`BIZ_${resp.status}`);
      } catch (e) {
        if (i === 2) {
          setState("error");
          setError("订阅请求失败，请稍后重试");
        }
      }
    }
  }

  return (
    <div>
      <button onClick={() => submitWithRetry("subscribe")}>订阅</button>
      <button onClick={() => submitWithRetry("unsubscribe")}>取消订阅</button>
      {state === "loading" && <p>loading...</p>}
      {state === "error" && <p>error: {error}</p>}
      {state === "done" && <p>done</p>}
    </div>
  );
}
```

## 17. 测试与演练
1. 单测：RSS 版本递增、幂等键去重、状态机迁移。
2. 集成：发布后 RSS 可读、订阅关系可查、统计入仓可见。
3. 压测：上传峰值、RSS 热点拉取、订阅突刺流量。
4. 混沌：模拟 CDN 故障、MQ 堵塞、数据库主从切换。
5. 演练：按季度执行 RTO/RPO 实战演练并出复盘报告。

## 18. 丰富例子（>=10）
1. 热门节目发布后 5 分钟内 RSS 被抓取 30 万次，系统通过 CDN 命中维持 P95 190ms。
2. 转码集群单 AZ 故障，任务自动迁移到备用 AZ，发布延迟上升但未中断。
3. 订阅接口出现重试风暴，幂等键拦截重复写入，数据库写放大被控制。
4. RSS 生成器版本冲突，回滚到上一个快照并重新生成，RPO 控制在 1 分钟内。
5. 发现页推荐服务超时，降级为分类热门列表，核心播放链路保持可用。
6. 统计管道积压 20 分钟，暂停低优先级事件并优先恢复计费相关指标。
7. CDN 区域性抖动，触发回源限速与静态副本兜底，首帧时延仍在阈值内。
8. 某创作者恶意高频上传，风控限速生效并触发人工复核。
9. 订阅取消后客户端重复点击 3 次，最终状态仍一致且仅记录一次有效变更。
10. 数据库主实例切换后，RSS 服务切只读副本继续服务，写请求排队等待恢复。
11. 统计报表延迟超标后，运维按 Runbook 回放缺失分区，60 分钟内恢复。
12. 发布系统误配置导致批量失败，Feature Flag 回滚后逐步放量恢复。

## 19. 面试追问与回答
1. 问：为什么 learningCoreId 是 22？  
答：Q98 归类为“媒体处理与内容分发”，该细分类母题在配置中映射到 22。
2. 问：最关键的稳定性手段是什么？  
答：幂等键、Outbox、降级缓存、DLQ 回放、RTO/RPO 演练闭环。
3. 问：如何证明不是纸上架构？  
答：给出量化阈值、告警规则、故障路径和代码落点，且能演练验证。

## 20. 学习路线
1. 先掌握母题 Q22 的媒体分发主架构。
2. 再补 RSS 生成与订阅一致性细节。
3. 最后补统计报表链路与成本治理。

## 21. 上场 Checklist
1. 能在 1 分钟讲清上传到 RSS 发布全链路。
2. 能明确 3 条以上告警阈值及触发动作。
3. 能说明至少 1 条含 RTO/RPO 的恢复路径。
4. 能解释幂等、重试、降级如何配合。
5. 能讲清成本与体验的取舍依据。

## 22. 与母题差异
1. 母题是 Q22（视频流系统），关注视频播放与转码分发全局；本题聚焦播客托管与 RSS 生态。
2. 本题的核心协议对象是 RSS Feed，而母题更偏播放器协议（如 HLS/DASH）。
3. 本题订阅关系和节目更新通知是一等公民，母题更强调视频播放 QoE 与推荐分发。
4. 本题统计口径更偏创作者运营（订阅增长、完播率、栏目转化），母题偏播放体验与内容消费。
5. 本题故障治理需要重点覆盖 RSS 快照回滚与订阅一致性补偿。
6. 新增必补知识：
- RSS XML 规范与版本兼容策略。
- 音频 CDN 回源控制与缓存预热策略。
- 订阅关系幂等写入与去重模型。
- 节目发布状态机与快照回滚机制。
- 播客发现页召回与冷启动策略。
- 统计报表流批一体口径治理。
