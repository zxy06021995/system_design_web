# Design TinyURL / Bit.ly - 短链接系统（母题）

> 对应题：Q1 `Pastebin / Bit.ly - 短链接系统`  
> 迁移价值：这道题学透后，可以覆盖 URL 缩短、跳转链路稳定、热点缓存、ID 生成、统计分析（Q29）等一大类题。

---

## 1. 先讲清楚题目边界

### 1.1 P0 功能（必须有）
1. 长链接生成短链接（系统分配短码）。
2. 访问短码后快速 302 跳转到长链接。
3. 短码全局唯一，不能冲突。
4. 支持过期时间、禁用状态。
5. 基础统计：点击量、UV、来源、时间趋势。

### 1.2 P1 功能（加分）
1. 自定义别名（如 `promo2026`）。
2. 批量创建短链。
3. 防滥用（黑名单、恶意 URL 拦截、限流）。
4. 多租户隔离（企业客户独立域名与配额）。

### 1.3 非功能目标（面试必须量化）
1. 可用性：`>= 99.99%`。
2. 跳转延迟：P95 `< 20ms`，P99 `< 50ms`。
3. 生成延迟：P95 `< 120ms`。
4. 扩展能力：读写分离 + 分片，支持 10 倍增长。
5. 数据一致性：短链映射最终一致，关键元数据强一致。

---

## 2. 容量估算（要算，不要空谈）

### 2.1 假设
1. DAU = `10,000,000`。
2. 每日新建短链 = `10,000,000`（每人 1 条）。
3. 每日跳转次数 = `100,000,000`（每人 10 次）。
4. 峰值系数按 `5` 估算。

### 2.2 结果
1. 新建平均 QPS = `10,000,000 / 86400 ≈ 116`。
2. 跳转平均 QPS = `100,000,000 / 86400 ≈ 1157`。
3. 跳转峰值 QPS = `1157 * 5 ≈ 5785`（按 6k 设计）。
4. 单条短链元数据约 `500B`，年新增 `10M * 365 * 500B ≈ 1.8TB`（未含索引与备份）。

### 2.3 结论
1. 系统明显“读多写少”，核心是跳转链路。
2. 架构重点应放在：缓存命中率、热 key 保护、回源稳定、统计异步化。

---

## 3. 高层架构（主链路 + 分析链路）

```text
                 +---------------------------+
                 |        Client/App         |
                 +-------------+-------------+
                               |
                               v
                    +----------+----------+
                    | API Gateway / WAF  |
                    +----+-----------+---+
                         |           |
                         v           v
               +---------+--+    +---+-------------------+
               | Link API  |    | Redirect API (/r/{c}) |
               +----+-------+    +----+------------------+
                    |                 |
                    v                 v
            +-------+------+   +------+------------------+
            | Redis Cluster|   | Bloom Filter + Local L1|
            +-------+------+   +------+------------------+
                    |                 |
                    +--------+--------+
                             v
                     +-------+--------+
                     | MySQL Shards   |
                     | (主从 + 分片)   |
                     +-------+--------+
                             |
                             v
                     +-------+--------+
                     | Kafka Topic    |
                     | click-events   |
                     +-------+--------+
                             |
                             v
                   +---------+----------+
                   | Flink / Stream Job |
                   +---------+----------+
                             |
                             v
                   +---------+----------+
                   | ClickHouse / OLAP  |
                   +--------------------+
```

设计要点：
1. 跳转链路与统计链路解耦，跳转先返回 302，再异步记日志。
2. 读路径优先 Redis，DB 作为回源兜底。
3. 防穿透靠 Bloom Filter，防击穿靠单飞锁，防雪崩靠 TTL 抖动。

---

## 4. 数据模型（核心表）

### 4.1 短链主表

```sql
CREATE TABLE short_link (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT NOT NULL,
  short_code VARCHAR(16) NOT NULL,
  long_url VARCHAR(2048) NOT NULL,
  long_url_hash BINARY(16) NOT NULL,
  domain VARCHAR(128) NOT NULL,
  status TINYINT NOT NULL DEFAULT 1,         -- 1=active,2=disabled,3=deleted
  expire_at DATETIME NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_tenant_code (tenant_id, short_code),
  KEY idx_tenant_hash (tenant_id, long_url_hash),
  KEY idx_expire (expire_at)
) ENGINE=InnoDB;
```

### 4.2 自定义别名预占表（防并发抢注）

```sql
CREATE TABLE alias_reservation (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT NOT NULL,
  alias_code VARCHAR(32) NOT NULL,
  reserved_by VARCHAR(64) NOT NULL,
  reserved_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_tenant_alias (tenant_id, alias_code)
) ENGINE=InnoDB;
```

### 4.3 号段表（Segment ID，稳定替代雪花）

```sql
CREATE TABLE id_segment (
  biz_type VARCHAR(32) PRIMARY KEY,
  max_id BIGINT NOT NULL,
  step INT NOT NULL,
  version BIGINT NOT NULL DEFAULT 0,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB;
```

### 4.4 幂等表（写路径防重）

```sql
CREATE TABLE request_idempotency (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT NOT NULL,
  request_id VARCHAR(64) NOT NULL,
  response_json JSON NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_tenant_req (tenant_id, request_id)
) ENGINE=InnoDB;
```

### 4.5 点击事件（OLTP 落地可选，主流直接 Kafka）

```sql
CREATE TABLE click_event_raw (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  short_code VARCHAR(16) NOT NULL,
  clicked_at DATETIME NOT NULL,
  ip VARCHAR(45) NULL,
  user_agent VARCHAR(512) NULL,
  referrer VARCHAR(512) NULL,
  country VARCHAR(8) NULL,
  KEY idx_code_time (short_code, clicked_at)
) ENGINE=InnoDB;
```

---

## 5. API 设计（关键接口）

### 5.1 创建短链

```http
POST /api/v1/links
Headers:
  X-Tenant-Id: 1001
  X-Request-Id: req_20260223_0001
Body:
{
  "longUrl": "https://example.com/campaign?id=42",
  "customAlias": "promo2026",
  "expireAt": "2026-12-31T23:59:59Z"
}
```

返回：

```json
{
  "shortCode": "promo2026",
  "shortUrl": "https://s.example.com/promo2026",
  "longUrl": "https://example.com/campaign?id=42",
  "expireAt": "2026-12-31T23:59:59Z"
}
```

### 5.2 跳转

```http
GET /r/{shortCode}
```

返回 `302`，`Location: 原始长链`。

### 5.3 查询统计

```http
GET /api/v1/links/{shortCode}/analytics?from=2026-02-01&to=2026-02-23
```

返回总点击、UV、来源分布、设备分布、时间趋势。

---

## 6. 核心流程（逐步讲最稳）

### 6.1 创建短链流程
1. 网关鉴权、限流、注入 `traceId`。
2. 幂等检查：`tenantId + requestId` 命中直接返回旧结果。
3. 处理 `customAlias`：
   1. 有别名则先写 `alias_reservation`（唯一键防并发）。
   2. 无别名则申请 ID（Segment/Snowflake）并 Base62 编码。
4. 落库 `short_link`（事务提交）。
5. 回填缓存 `code -> longUrl`。
6. 返回短链结果。

例子：用户重复点“创建”按钮 3 次，因为 `requestId` 一致，只会创建 1 条记录。

### 6.2 跳转流程
1. 本地 L1 缓存查 `shortCode`。
2. Redis 查 `code -> longUrl`。
3. 未命中时先查 Bloom Filter，若确定不存在直接 404。
4. 若可能存在，回源 MySQL 查主表并校验状态/过期。
5. 回填缓存后返回 302。
6. 异步发送点击事件到 Kafka，不阻塞 302。

例子：热点短链每秒 10k 请求，99% 命中 Redis，DB 压力仍稳定。

---

## 7. 关键算法与取舍

### 7.1 短码生成
候选方案：
1. `hash(longUrl)`：短、可重复生成，但有碰撞与可枚举问题。
2. `全局递增ID + Base62`：简单稳定，工程上最常见。
3. `随机串`：冲突概率低，但需要冲突重试与熵源治理。

母题推荐：`Segment ID + Base62`。

原因：
1. 稳定可控，不依赖机器时钟。
2. 可离线申请号段，抗抖动好。
3. 与分库分表天然兼容。

### 7.2 防穿透/击穿/雪崩
1. 穿透：Bloom Filter + 空值短 TTL。
2. 击穿：单飞锁（同 key 只允许一个线程回源）。
3. 雪崩：TTL 加随机抖动（例如 `+ 0~15%`）。

### 7.3 一致性哈希在本题中的位置
1. 可用于多级缓存节点路由或统计聚合分桶。
2. 也可用于 MySQL 分片路由前置层，减少扩容搬迁量。

---

## 8. 缓存策略（读多写少场景）

### 8.1 Cache Aside
1. 读：先缓存，miss 再 DB，回填缓存。
2. 写：先 DB 后删缓存（或写 DB + 消息删缓存）。

### 8.2 更新一致性
1. 更新短链状态时，先提交 DB 事务。
2. 事务后发失效事件（Outbox 更稳）。
3. 消费端删 Redis 对应 key。

### 8.3 热点治理
1. 热 key 复制（逻辑别名映射多个物理 key）。
2. 本地缓存兜底（Caffeine，1-5 秒）。
3. 极热点可前置 CDN 302 缓存（短 TTL）。

---

## 9. Java 关键代码（面试可直接讲）

### 9.1 Base62 编码器

```java
public final class Base62Codec {
    private static final char[] ALPHABET =
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toCharArray();
    private static final int BASE = 62;

    public String encode(long value) {
        if (value < 0) {
            throw new IllegalArgumentException("value must be non-negative");
        }
        if (value == 0) {
            return String.valueOf(ALPHABET[0]);
        }
        StringBuilder sb = new StringBuilder();
        long x = value;
        while (x > 0) {
            int idx = (int) (x % BASE);
            sb.append(ALPHABET[idx]);
            x /= BASE;
        }
        return sb.reverse().toString();
    }
}
```

### 9.2 号段 ID 生成器（避免雪花时钟回拨风险）

```java
@Service
public class SegmentIdGenerator {
    private final JdbcTemplate jdbcTemplate;
    private final ConcurrentHashMap<String, SegmentBuffer> bufferMap = new ConcurrentHashMap<>();

    public SegmentIdGenerator(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public long nextId(String bizType) {
        SegmentBuffer buffer = bufferMap.computeIfAbsent(bizType, k -> new SegmentBuffer());
        return buffer.next(this::loadSegmentFromDb);
    }

    @Transactional
    protected Segment loadSegmentFromDb(String bizType) {
        // select ... for update 锁住该业务号段行，原子推进 max_id
        SegmentRow row = jdbcTemplate.queryForObject(
                "SELECT max_id, step FROM id_segment WHERE biz_type=? FOR UPDATE",
                (rs, n) -> new SegmentRow(rs.getLong("max_id"), rs.getInt("step")),
                bizType
        );
        long oldMax = row.maxId();
        long newMax = oldMax + row.step();
        jdbcTemplate.update(
                "UPDATE id_segment SET max_id=?, version=version+1 WHERE biz_type=?",
                newMax, bizType
        );
        // 可用区间: (oldMax, newMax]
        return new Segment(oldMax + 1, newMax);
    }

    private record SegmentRow(long maxId, int step) {}
}
```

### 9.3 创建短链服务（幂等 + 唯一约束 + 缓存回填）

```java
@Service
public class ShortLinkService {
    private final Base62Codec base62Codec = new Base62Codec();
    private final SegmentIdGenerator idGenerator;
    private final ShortLinkRepository shortLinkRepository;
    private final IdempotencyRepository idempotencyRepository;
    private final StringRedisTemplate redisTemplate;

    public ShortLinkService(SegmentIdGenerator idGenerator,
                            ShortLinkRepository shortLinkRepository,
                            IdempotencyRepository idempotencyRepository,
                            StringRedisTemplate redisTemplate) {
        this.idGenerator = idGenerator;
        this.shortLinkRepository = shortLinkRepository;
        this.idempotencyRepository = idempotencyRepository;
        this.redisTemplate = redisTemplate;
    }

    @Transactional
    public CreateLinkResponse create(long tenantId, String requestId, CreateLinkRequest req) {
        // 1) 幂等快速返回
        CreateLinkResponse replay = idempotencyRepository.findResponse(tenantId, requestId);
        if (replay != null) {
            return replay;
        }

        String code = req.customAlias();
        if (code == null || code.isBlank()) {
            long id = idGenerator.nextId("short_link");
            code = base62Codec.encode(id);
        }

        // 2) 插入主表，依赖唯一索引兜底并发冲突
        ShortLinkEntity entity = new ShortLinkEntity(
                tenantId, code, req.longUrl(), req.expireAt(), ShortLinkStatus.ACTIVE
        );
        shortLinkRepository.insert(entity);

        CreateLinkResponse response = new CreateLinkResponse(
                code, "https://s.example.com/" + code, req.longUrl(), req.expireAt()
        );

        // 3) 幂等记录与缓存回填
        idempotencyRepository.save(tenantId, requestId, response);
        redisTemplate.opsForValue().set(cacheKey(tenantId, code), req.longUrl(), Duration.ofHours(24));
        return response;
    }

    private String cacheKey(long tenantId, String code) {
        return "sl:" + tenantId + ":" + code;
    }
}
```

### 9.4 跳转服务（Bloom + Cache Aside + 异步埋点）

```java
@Service
public class RedirectService {
    private final StringRedisTemplate redisTemplate;
    private final ShortLinkRepository shortLinkRepository;
    private final BloomFilter<String> bloomFilter;
    private final ClickEventPublisher clickEventPublisher;

    public RedirectService(StringRedisTemplate redisTemplate,
                           ShortLinkRepository shortLinkRepository,
                           BloomFilter<String> bloomFilter,
                           ClickEventPublisher clickEventPublisher) {
        this.redisTemplate = redisTemplate;
        this.shortLinkRepository = shortLinkRepository;
        this.bloomFilter = bloomFilter;
        this.clickEventPublisher = clickEventPublisher;
    }

    public String resolve(long tenantId, String shortCode, RequestContext ctx) {
        String key = "sl:" + tenantId + ":" + shortCode;
        String longUrl = redisTemplate.opsForValue().get(key);
        if (longUrl != null) {
            clickEventPublisher.publishAsync(tenantId, shortCode, ctx);
            return longUrl;
        }

        // 布隆过滤器判断: 明确不存在则直接 404
        if (!bloomFilter.mightContain(key)) {
            throw new NotFoundException("short code not found");
        }

        ShortLinkEntity entity = shortLinkRepository.findActiveByCode(tenantId, shortCode);
        if (entity == null || entity.isExpired()) {
            throw new NotFoundException("short code invalid or expired");
        }

        redisTemplate.opsForValue().set(key, entity.getLongUrl(), Duration.ofHours(24));
        clickEventPublisher.publishAsync(tenantId, shortCode, ctx);
        return entity.getLongUrl();
    }
}
```

### 9.5 点击事件消费（统计链路）

```java
@Component
public class ClickEventConsumer {
    private final AnalyticsRepository analyticsRepository;
    private final StringRedisTemplate redisTemplate;

    public ClickEventConsumer(AnalyticsRepository analyticsRepository,
                              StringRedisTemplate redisTemplate) {
        this.analyticsRepository = analyticsRepository;
        this.redisTemplate = redisTemplate;
    }

    @KafkaListener(topics = "click-events", groupId = "analytics-g1")
    public void onEvent(ClickEvent event) {
        // 1) 实时计数: total clicks
        String counterKey = "stat:click:" + event.tenantId() + ":" + event.shortCode();
        redisTemplate.opsForValue().increment(counterKey);

        // 2) UV 近似计数（HyperLogLog）
        String uvKey = "stat:uv:" + event.tenantId() + ":" + event.shortCode() + ":" + event.day();
        redisTemplate.opsForHyperLogLog().add(uvKey, event.visitorId());

        // 3) 异步入 OLAP，支持趋势、来源、设备分析
        analyticsRepository.insertClickEvent(event);
    }
}
```

---

## 10. 一致性与容错设计

### 10.1 写路径一致性
1. 短链元数据以 MySQL 事务为准。
2. 缓存属于派生状态，允许短时不一致。
3. 删除/禁用短链采用“先 DB 后删缓存”。

### 10.2 幂等与重试
1. 客户端必须带 `requestId`。
2. 服务端用唯一键保证同请求只成功一次。
3. 重试只允许在幂等接口上做，且有退避上限。

### 10.3 故障降级
1. Redis 故障：降级为 DB + 本地短缓存 + 严格限流。
2. Kafka 故障：埋点降级到本地队列/文件，异步补传。
3. OLAP 故障：分析接口可降级返回“近实时数据不可用”。

---

## 11. 反作弊与安全

1. URL 安全扫描：接入恶意域名黑名单 + 内容安全服务。
2. 频控：按租户、IP、用户三层限流（令牌桶）。
3. 防枚举：短码长度下限、混淆策略、异常访问速率封禁。
4. 权限：短链管理接口要求鉴权，避免越权读写。
5. 隐私合规：IP 脱敏存储，统计报表按最小必要原则输出。

---

## 12. 可观测性与 SLO

### 12.1 关键指标
1. 跳转成功率、4xx/5xx 比例。
2. 跳转 P95/P99 延迟。
3. Redis 命中率、DB 回源率。
4. Kafka 积压长度、消费延迟。
5. 热 key TopN、布隆误判率。

### 12.2 告警阈值示例
1. P99 > 80ms 持续 5 分钟告警。
2. 缓存命中率 < 92% 告警。
3. 消费积压 > 5 分钟告警。
4. 5xx > 0.3% 告警并触发降级脚本。

---

## 13. 故障演练（面试官最爱问）

### 演练1：热点短链导致缓存击穿
1. 现象：单一短码 QPS 飙升，DB CPU 打满。
2. 动作：启用单飞锁 + 本地缓存 + 热 key 复制。
3. 验证：P99 从 180ms 回落到 45ms。

### 演练2：Redis 集群不可用
1. 现象：全量回源，跳转错误率上升。
2. 动作：网关限流 + 降级只保留 P0 短链 + 只读模式。
3. 验证：服务可用性保持 > 99.9%。

### 演练3：号段服务卡顿
1. 现象：新建短链大量超时。
2. 动作：预取双 buffer 号段、扩 step、加本地告警。
3. 验证：创建接口 P95 恢复到 110ms。

---

## 14. 与相近题目的差异（帮你“少题覆盖多题”）

1. 与 `Rate Limiter` 的关系：
   1. 短链题里限流是保护手段，不是业务主体。
   2. 限流题会更深入算法准确性与误伤控制。

2. 与 `API Gateway` 的关系：
   1. 短链题关注“业务链路读写与跳转稳定”。
   2. 网关题关注“多服务接入治理与策略下发”。

3. 与 `URL Shortener Analytics` 的关系：
   1. 短链题里的统计是配套能力。
   2. 分析题会深挖流式计算、OLAP 建模、近实时查询。

4. 与 `Distributed ID Generator` 的关系：
   1. 短链题只需“够用且稳定”的 ID 方案。
   2. ID 题会专门讨论时钟回拨、趋势递增、跨机房唯一性。

---

## 15. 面试高频追问与答题要点

1. 短码冲突怎么办？
   1. 系统分配短码用全局 ID + Base62，冲突概率近乎 0。
   2. 自定义别名用唯一索引和预占表防并发冲突。

2. 为什么跳转要 302 而不是 301？
   1. 301 会被浏览器强缓存，更新目标 URL 不灵活。
   2. 营销链路一般更适合 302，便于后续调整。

3. 如何保证统计不拖慢跳转？
   1. 302 先返回，埋点异步写 Kafka。
   2. 统计链路故障不影响主跳转链路。

4. 如何处理恶意短链？
   1. 创建时做 URL 风险扫描。
   2. 运行时支持即时禁用和全局封禁。

5. 如何做多租户隔离？
   1. 逻辑上 `tenantId` 全链路透传。
   2. 数据层唯一键和索引都带 `tenantId`。

---

## 16. 上场前 Checklist

1. 是否明确了读写比例和容量估算。
2. 是否说清楚短码生成策略与冲突处理。
3. 是否覆盖了缓存一致性三件套（穿透/击穿/雪崩）。
4. 是否解释了统计异步化与主链路解耦。
5. 是否给出故障降级与回滚方案。
6. 是否给出关键 SLO 与告警阈值。
7. 是否能回答“为什么不用某方案”的取舍题。

---

## 17. 30 秒总结（面试收尾）

这题本质是“读多写少的高可用跳转系统”。  
主链路用 `MySQL + Redis + Bloom + 幂等` 保证稳定与低延迟；  
统计链路用 `Kafka + 流处理 + OLAP` 保证可扩展分析能力；  
再配上限流、降级、演练和监控，才能从“能用”到“面试可过且可上线”。

