# Q49 Stock Exchange (股票交易所)

> 来源校验（questions.ts）  
> `title`: Stock Exchange (股票交易所)  
> `tags`: 撮合引擎, 订单簿, 低延迟, 高可用, 风控  
> `keyPoints`: 订单簿结构, 撮合优先级, 低延迟网络, 风控限价, 灾备容灾  
> `learningCoreId`: 84（母题：Online Payment System）

## 1. 三句话题目本质
1. 这题核心是“订单进来后，如何在低延迟下正确撮合成交”。
2. 难点是撮合正确性、并发写冲突、风控拦截与清算一致性。
3. 高分关键是把“交易链路 + 风控 + 清算 + 容灾”讲成闭环。

## 2. 一个真实场景故事
某券商开盘 10 分钟订单暴增，撮合服务延迟从 2ms 升到 35ms，部分订单超时撤单失败。原因是订单簿冷热数据未分层、风控同步调用阻塞撮合线程。优化后把风控改预检+异步复核，订单簿驻内存+日志落盘，延迟恢复到 P95 4ms。

## 3. 术语白话表（>=10）
1. Order Book：买卖盘挂单表。
2. Price-Time Priority：价格优先，时间优先。
3. Matching Engine：撮合引擎。
4. IOC/FOK：立即成交剩余撤销 / 全成否则撤销。
5. Market Order：市价单。
6. Limit Order：限价单。
7. Trade Event：成交事件。
8. Pre-trade Risk：交易前风控。
9. Post-trade Clearing：交易后清算。
10. WAL：预写日志，崩溃恢复用。
11. Hot/Cold Split：热点数据内存，冷数据磁盘。
12. Circuit Breaker：熔断保护。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 下单、撤单、改单。
2. 实时撮合并生成成交回报。
3. 交易前风控（额度、价格、黑名单）。
4. 交易后清算与资金持仓更新。
5. 行情推送（盘口、成交明细）。

### 4.2 非功能需求
1. 低延迟：撮合 P95 <= 5ms。
2. 高可用：核心交易 >= 99.99%。
3. 一致性：成交不可重复、不可丢失。
4. 可恢复：故障后按日志重放恢复。

### 4.3 不做范围
1. 不做完整监管报送平台。
2. 不做跨市场复杂套利策略引擎。
3. 不做全资产类别（仅股票现货）。

### 4.4 SLO
1. `match_latency_p95_ms <= 5`
2. `order_ack_p99_ms <= 20`
3. `trade_event_loss = 0`

## 5. 容量估算（数字推导）
1. 峰值下单 20 万单/s，撤单 10 万单/s。
2. 平均订单消息 400B，入口流量约 120MB/s。
3. 成交事件峰值 5 万条/s，需 MQ 异步分发。
4. 热门标的 top 1% 占 50% 流量，必须按标的分片。
5. 订单簿热数据驻内存：假设 1000 万挂单 * 120B ≈ 1.2GB（不含索引）。
6. 冷数据（历史订单、成交）落列式存储，按日归档。

## 6. 架构（简版+完整版）
### 6.1 简版
`Client -> Gateway -> Risk -> Matching Engine -> Trade MQ -> Clearing`

### 6.2 完整版
1. API Gateway：鉴权、限流、幂等键检查。
2. Pre-trade Risk：额度/价格带/账户状态校验。
3. Matching Cluster：按 `symbol` 分区，单分区串行撮合。
4. WAL + Snapshot：撮合状态持久化与恢复。
5. Trade Event MQ（Kafka）：成交、订单状态异步广播。
6. Clearing Service：资金和持仓更新，T+0/T+1 规则。
7. Market Data Service：盘口和逐笔成交推送。
8. Archive & Analytics：冷热分层与审计回放。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 下单
`POST /api/exchange/v1/orders`

请求：
```json
{
  "clientOrderId": "co-20260224-001",
  "accountId": "A1001",
  "symbol": "AAPL",
  "side": "BUY",
  "type": "LIMIT",
  "price": 180.25,
  "qty": 100
}
```

响应：
```json
{
  "orderId": "O998877",
  "status": "ACCEPTED",
  "receivedAt": "2026-02-24T10:00:00Z"
}
```

### 7.2 撤单
`POST /api/exchange/v1/orders/{orderId}/cancel`

### 7.3 查询订单
`GET /api/exchange/v1/orders/{orderId}`

错误码：
1. `422_PRICE_OUT_OF_BAND`
2. `409_DUPLICATE_CLIENT_ORDER_ID`
3. `409_ORDER_ALREADY_FINAL`
4. `429_RATE_LIMITED`

幂等规则：
1. `clientOrderId` 在账户维度唯一。
2. 重复下单返回同 `orderId` 与状态。

## 8. 数据模型（实体/索引/分片）
1. `order(order_id, client_order_id, account_id, symbol, side, type, price, qty, status, ts)`。
2. `trade(trade_id, buy_order_id, sell_order_id, symbol, price, qty, ts)`。
3. `position(account_id, symbol, qty, avg_price)`。
4. `cash_ledger(account_id, balance, frozen, updated_at)`。
5. `order_book_snapshot(symbol, snapshot_seq, payload, ts)`。

分片：
1. 撮合分片按 `symbol`。
2. 清算分片按 `account_id`。
3. 热订单簿内存化，历史订单归档冷存。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 网关验签+幂等检查。
2. 风控预检通过后写入撮合分区。
3. 撮合成交后写 WAL，并发布成交事件到 MQ。
4. 清算服务消费 MQ 更新资金持仓。

### 9.2 高峰流程
1. 按 symbol 分片隔离热点标的。
2. 风控降级为快路径（关键规则同步，次要规则异步）。
3. 行情推送与清算消费分离，防止相互阻塞。

### 9.3 故障恢复流程
1. 撮合节点重启后先加载 snapshot。
2. 回放 WAL 补齐状态。
3. 比对最后成交序列，缺失事件从 MQ 回补。

## 10. 一致性与事务边界
1. 撮合内要求强一致（同 symbol 串行）。
2. 成交事件发布采用 outbox 或“先 WAL 后发 MQ”保证不丢。
3. 清算为最终一致，支持重放。
4. 订单终态（FILLED/CANCELED/REJECTED）不可逆。
5. 资金账与持仓账通过对账任务日终收敛。

## 11. 可用性与容错（含 RTO/RPO）
1. 多机房部署，主活+备活。
2. symbol 分区可迁移，节点故障快速接管。
3. MQ 多副本，关键 topic 不丢消息。
4. RTO：撮合分区故障 60 秒内恢复。
5. RPO：订单/成交 RPO=0（通过 WAL+MQ+回放保障）。

## 12. 可观测性（指标+阈值+处置动作）
1. `match_latency_p95_ms > 5`：扩容热点分区并启用快风控。
2. `order_reject_rate > 3%`：排查风控误杀与行情异常。
3. `trade_mq_lag > 200000`：扩容清算消费者。
4. `symbol_skew_top1 > 35%`：触发分区再平衡。
5. `wal_replay_gap > 0`：阻止开盘并执行补回放。
6. `position_cash_diff_count > 0`：触发 P1 对账。

## 13. 安全与合规
1. 下单接口双向鉴权与签名防篡改。
2. 风控黑名单与合规规则先于撮合执行。
3. 操作全审计（改单、撤单、强平）。
4. 敏感数据脱敏展示。
5. 历史数据保留满足监管要求。

## 14. 成本与取舍
1. 更强一致性带来更高延迟成本。
2. 全量内存订单簿快但贵，需冷热分层。
3. 全同步清算准确但慢，异步清算需补偿。
4. 取舍：撮合强一致、清算最终一致+可回放。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法：价格时间优先撮合
```java
public List<Trade> match(Order incoming, OrderBook book) {
    List<Trade> trades = new ArrayList<>();
    while (incoming.remainingQty() > 0 && book.hasCross(incoming)) {
        Order top = book.bestOpposite(incoming.side());
        long qty = Math.min(incoming.remainingQty(), top.remainingQty());
        trades.add(new Trade(incoming.id(), top.id(), top.price(), qty));
        incoming.fill(qty);
        top.fill(qty);
        if (top.remainingQty() == 0) book.remove(top);
    }
    if (incoming.remainingQty() > 0 && incoming.type().isLimit()) book.add(incoming);
    return trades;
}
```

### 15.2 幂等去重：clientOrderId
```java
public AcceptResult acceptOrder(NewOrderReq req) {
    String key = req.accountId() + ":" + req.clientOrderId();
    String existed = idemRepo.findOrderId(key);
    if (existed != null) return AcceptResult.duplicate(existed);
    String orderId = orderIdGen.next();
    orderRepo.insert(orderId, req);
    idemRepo.save(key, orderId, Duration.ofDays(1));
    return AcceptResult.ok(orderId);
}
```

### 15.3 重试退避/失败处理：成交事件 MQ
```java
public void publishTradeWithRetry(TradeEvent e) {
    long backoff = 10;
    for (int i = 0; i < 4; i++) {
        try {
            mqProducer.send("trade-events", e.key(), e);
            return;
        } catch (RuntimeException ex) {
            if (i == 3) { dlqRepo.save(e.tradeId(), ex.getMessage()); throw ex; }
            sleep(backoff);
            backoff = Math.min(backoff * 2, 200);
        }
    }
}
```

### 15.4 一致性边界：WAL + snapshot
```java
@Transactional
public void appendWALAndSnapshot(String symbol, OrderBookDelta delta) {
    walRepo.append(symbol, delta.seq(), delta.payload());
    if (delta.seq() % 1000 == 0) {
        snapshotRepo.save(symbol, delta.seq(), delta.bookState());
    }
}
```

### 15.5 观测触发/回滚判定
```java
public void guardHotSymbol() {
    double p95 = metrics.timer("match_latency_p95_ms").value();
    if (p95 > 5.0) {
        featureSwitch.enable("risk_fast_path");
        alerting.fire("MATCH_LATENCY_HIGH", "p95=" + p95);
    }
    long mqLag = metrics.gauge("trade_mq_lag").longValue();
    if (mqLag > 200_000) scaler.scaleOut("clearing-consumer");
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 下单调用（loading/error/done）
```javascript
import { useState } from "react";

export function usePlaceOrder() {
  const [state, setState] = useState({ phase: "idle", order: null, error: "" });

  async function place(payload) {
    const clientOrderId = `co-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    setState({ phase: "loading", order: null, error: "" });
    try {
      const res = await fetch("/api/exchange/v1/orders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ...payload, clientOrderId })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      setState({ phase: "done", order: await res.json(), error: "" });
    } catch (e) {
      setState({ phase: "error", order: null, error: String(e.message || e) });
    }
  }

  return { state, place };
}
```

### 16.2 订单状态轮询（高峰降级：退避轮询）
```javascript
export async function pollOrder(orderId, onUpdate) {
  let interval = 500;
  for (let i = 0; i < 20; i++) {
    try {
      const res = await fetch(`/api/exchange/v1/orders/${orderId}`);
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      const data = await res.json();
      onUpdate(data);
      if (["FILLED", "CANCELED", "REJECTED"].includes(data.status)) return;
      interval = 500;
    } catch {
      interval = Math.min(interval * 2, 4000);
    }
    await new Promise((r) => setTimeout(r, interval));
  }
}
```

## 17. 测试策略
1. 单元测试：撮合优先级、撤单边界、风控拦截。
2. 集成测试：下单->撮合->清算->回报端到端。
3. 压测：开盘峰值与热点 symbol 场景。
4. 故障注入：MQ 积压、节点宕机、网络抖动。
5. 对账测试：成交账、资金账、持仓账一致性。

## 18. 丰富例子（>=10）
1. LIMIT 买单与卖一价成交。
2. IOC 单部分成交后剩余撤销。
3. FOK 单无法全成直接撤销。
4. 价格超涨跌停被风控拒绝。
5. 同 clientOrderId 重试不重复下单。
6. 热门标的分区迁移降延迟。
7. 清算延迟时成交仍成功，后续补账。
8. 节点重启后 WAL 回放恢复盘口。
9. 行情推送降级不影响撮合。
10. 异常账户触发强平保护。
11. 日终对账发现差异并补偿。
12. 多机房切换后连续交易不中断。

## 19. 面试追问 + 可复述回答
1. 撮合和清算为什么拆开？
回答：撮合追求毫秒级确定性，清算可以异步扩展并补偿。
2. 如何保证成交不丢？
回答：撮合先写 WAL，再发 MQ，消费端幂等。
3. 热门股票打爆怎么办？
回答：按 symbol 分区、热点再平衡、快风控路径。
4. 为什么要冷热分层？
回答：盘口热数据高频访问必须内存化，历史冷数据归档降成本。
5. 与母题 Q84 差别？
回答：Q84 是支付状态机，这题核心是订单簿撮合与行情低延迟。

## 20. 新手学习路线
1. 先实现限价单订单簿。
2. 加撤单与状态机。
3. 接入 MQ 和清算消费。
4. 做风控预检与熔断。
5. 做故障回放与对账演练。

## 21. 上场前 Checklist
1. 能讲清撮合优先级算法。
2. 能解释撮合与清算一致性边界。
3. 能说出 MQ、WAL、快照各自作用。
4. 能量化高峰和阈值处理动作。
5. 能与 Q84 清楚区分。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q84 Online Payment System。

### 22.2 共性能力
1. 都要求资金正确性和幂等。
2. 都需要风控和审计。
3. 都有异步事件链路。

### 22.3 关键差异
1. Q84 关注支付状态收敛；Q49 关注撮合订单簿。
2. Q49 延迟目标更严（毫秒级）。
3. Q49 存在盘口与行情分发。
4. Q49 需要按 symbol 分区和热点治理。
5. Q49 强调撮合引擎恢复（WAL+snapshot）。

### 22.4 本题新增知识点（>=5）
1. 订单簿结构与撮合优先级。
2. Symbol 分区与热点隔离。
3. 撮合 WAL+快照恢复机制。
4. 成交事件 MQ 解耦清算。
5. 交易链路冷热数据分层。
6. 行情与交易通道隔离。

### 22.5 面试差异话术
“Q84 讲支付闭环；Q49 讲交易撮合闭环。交易题的高分点在订单簿、撮合时延、清算解耦与恢复能力。”

---

## 单题自审（Q49）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦交易所而非支付模板：通过。
2. API 与 MQ/冷热策略落地清晰：通过。

### D. 工程落地检查
1. 阈值+动作绑定：通过。
2. RTO/RPO 与恢复路径明确：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端调用 API 与高峰退避轮询体现：通过。

### F. 母题差异检查
1. 与 Q84 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20
总分：96/100（通过）
