# Q100 - Design Load Balancer

## 1. 题目元信息（来自 `src/data/questions.ts`）
- id: `100`
- title: `Design Load Balancer`
- tags: `['负载均衡', 'LVS', 'Nginx', '健康检查', '算法']`
- keyPoints: `['轮询算法', '最少连接', 'IP哈希', '健康检查', '会话保持']`
- learningCoreId: `16`

## 2. 题目重述与边界
设计一个高可用负载均衡系统，支持四层/七层转发、动态上下线、健康检查、会话保持与流量治理；目标是把流量稳定分配到后端服务，同时在节点或机房故障时快速恢复。

## 3. 目标与非目标
- 目标：高可用、低延迟、可观测、可扩展、可灰度。
- 目标：支持多算法并可按业务路由策略动态切换。
- 非目标：不在本题内实现完整 WAF 与完整 API 网关插件生态。

## 4. 需求拆解
- 功能性：请求转发、健康检查、权重配置、会话保持、故障切换。
- 功能性：管理面 API（增删改查后端池、策略发布、灰度规则）。
- 非功能：P99 延迟、99.99% 可用性、配置发布一致性、可审计。

## 5. 容量与SLO假设
- 峰值 QPS：`1,000,000`。
- 单节点可承载：`80,000` QPS，按 `N+2` 冗余部署。
- SLO：
1. 可用性 `>= 99.99%`。
2. 转发层新增延迟 `P99 <= 8ms`。
3. 健康状态收敛 `<= 15s`。

## 6. 高层架构
- 数据面：Anycast DNS/GSLB -> LB 集群（L4/L7）-> Service 集群。
- 控制面：配置中心 -> 发布器 -> LB Agent 热更新。
- 观测面：指标/日志/追踪 -> 告警 -> 自动化回滚。
- 存储面：配置存储（强一致）+ 统计存储（最终一致）。

## 7. 核心数据模型
- `BackendNode(nodeId, ip, port, zone, weight, state, version)`
- `Pool(poolId, protocol, scheduler, stickyPolicy, healthPolicy)`
- `Route(routeId, host, path, method, poolId, canaryRule)`
- `HealthRecord(nodeId, timestamp, status, latencyMs, errRate)`
- `FailoverPlan(routeId, primaryZone, standbyZone, policy, cooldownSec)`

## 8. 路由与调度算法
- 轮询（Round Robin）：简单稳定，适合同构实例。
- 加权轮询：支持异构机型和冷热分层。
- 最少连接（Least Connections）：适合长连接/请求时长差异大。
- IP 哈希：适合会话亲和，但需处理扩缩容重映射。
- 实践：默认加权最少连接，静态资源可轮询，登录态可粘性策略。

## 9. 健康检查与摘流
- 主动探测：TCP、HTTP、gRPC health endpoint。
- 被动探测：5xx/超时/连接拒绝计数熔断。
- 阈值示例：连续 `3` 次失败摘流，连续 `2` 次成功恢复。
- 冷却窗口：摘流后 `30s` 禁止立即回切，避免抖动。

## 10. 会话保持与无状态化
- 优先无状态化：令牌放客户端，后端共享缓存。
- 必须粘性时：cookie-based sticky 或一致性哈希。
- 迁移策略：灰度阶段双写 session，逐步切到无状态。

## 11. 一致性与配置发布
- 配置版本号单调递增，LB 仅接受更高版本。
- 发布流程：预检 -> 分批发布 -> 指标观察 -> 全量。
- 回滚流程：一键回滚到最近稳定版本，保留审计日志。

## 12. 阈值设计与故障恢复路径（含RTO/RPO）
- 核心阈值：
1. `P99 > 20ms` 持续 `3` 分钟触发扩容。
2. `5xx > 1%` 持续 `2` 分钟触发降级与流量切换。
3. 后端池健康率 `< 70%` 触发跨可用区接管。
- 故障恢复路径：
1. 节点故障：探测失败 -> 摘流 -> 旁路重试 -> 自动恢复探测。
2. 可用区故障：GSLB 降权 -> 跨区切流 -> 只读/降级策略。
3. 控制面故障：冻结当前稳定配置 -> 禁止危险变更 -> 恢复后补发版本。
- 目标：`RTO <= 5 分钟`，`RPO = 0`（配置元数据采用强一致复制）。

## 13. 安全与合规
- 管理面 API 使用 mTLS + RBAC + 审计。
- 数据面支持 TLS 终止与证书自动轮换。
- 防护：连接限速、Header 大小限制、SYN 防护、黑白名单。

## 14. 可观测性与压测
- 指标：QPS、延迟分位数、错误率、活跃连接、健康节点比。
- 日志：访问日志、配置变更日志、摘流/恢复事件日志。
- 压测：稳态压测、突发压测、故障演练（单机/单区/全区）。

## 15. Java 实现片段（>=5）
```java
public enum NodeState {
    UP, DOWN, DRAINING
}
```

```java
public final class BackendNode {
    private final String nodeId;
    private final String ip;
    private final int port;
    private volatile int weight;
    private volatile NodeState state;

    public BackendNode(String nodeId, String ip, int port, int weight) {
        this.nodeId = nodeId;
        this.ip = ip;
        this.port = port;
        this.weight = Math.max(1, weight);
        this.state = NodeState.UP;
    }

    public String endpoint() {
        return ip + ":" + port;
    }

    public boolean isAvailable() {
        return state == NodeState.UP;
    }

    public void markDown() {
        this.state = NodeState.DOWN;
    }

    public void markUp() {
        this.state = NodeState.UP;
    }
}
```

```java
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class RoundRobinScheduler {
    private final AtomicInteger idx = new AtomicInteger(0);

    public BackendNode choose(List<BackendNode> nodes) {
        int size = nodes.size();
        if (size == 0) {
            throw new IllegalStateException("no backend available");
        }
        for (int i = 0; i < size; i++) {
            int pos = Math.floorMod(idx.getAndIncrement(), size);
            BackendNode n = nodes.get(pos);
            if (n.isAvailable()) {
                return n;
            }
        }
        throw new IllegalStateException("all backends are down");
    }
}
```

```java
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class LeastConnectionsScheduler {
    private final Map<String, AtomicInteger> inflight = new ConcurrentHashMap<>();

    public BackendNode choose(List<BackendNode> nodes) {
        return nodes.stream()
                .filter(BackendNode::isAvailable)
                .min(Comparator.comparingInt(n -> inflight
                        .computeIfAbsent(n.endpoint(), k -> new AtomicInteger(0))
                        .get()))
                .orElseThrow(() -> new IllegalStateException("no healthy node"));
    }

    public void onStart(BackendNode node) {
        inflight.computeIfAbsent(node.endpoint(), k -> new AtomicInteger(0)).incrementAndGet();
    }

    public void onDone(BackendNode node) {
        inflight.computeIfAbsent(node.endpoint(), k -> new AtomicInteger(0)).updateAndGet(v -> Math.max(0, v - 1));
    }
}
```

```java
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpHealthChecker {
    public boolean check(String url, int timeoutMs) {
        try {
            HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();
            conn.setConnectTimeout(timeoutMs);
            conn.setReadTimeout(timeoutMs);
            conn.setRequestMethod("GET");
            int code = conn.getResponseCode();
            return code >= 200 && code < 500;
        } catch (Exception ex) {
            return false;
        }
    }
}
```

```java
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class ConfigVersionGuard {
    private final ConcurrentMap<String, Long> routeVersion = new ConcurrentHashMap<>();

    public boolean applyIfNewer(String routeId, long incomingVersion) {
        return routeVersion.merge(routeId, incomingVersion, Math::max) == incomingVersion;
    }

    public long current(String routeId) {
        return routeVersion.getOrDefault(routeId, 0L);
    }
}
```

## 16. React JavaScript 实现片段（>=2）
```javascript
import { useEffect, useRef, useState } from 'react';

export function usePoolHealth(poolId) {
  const [state, setState] = useState({ loading: true, error: null, done: false, data: null });
  const timerRef = useRef(null);

  useEffect(() => {
    let cancelled = false;

    const poll = async () => {
      setState((s) => ({ ...s, loading: true, error: null, done: false }));
      try {
        const res = await fetch(`/api/lb/pools/${poolId}/health`, { method: 'GET' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (!cancelled) {
          setState({ loading: false, error: null, done: true, data });
        }
      } catch (err) {
        if (!cancelled) {
          setState({ loading: false, error: String(err), done: false, data: null });
        }
      } finally {
        if (!cancelled) {
          timerRef.current = setTimeout(poll, 5000);
        }
      }
    };

    poll();
    return () => {
      cancelled = true;
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, [poolId]);

  return state;
}
```

```jsx
import React, { useState } from 'react';

export default function PublishConfigButton({ routeId, version, payload }) {
  const [status, setStatus] = useState({ loading: false, error: null, done: false });

  const onPublish = async () => {
    setStatus({ loading: true, error: null, done: false });
    const idempotencyKey = `${routeId}-${version}`;

    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        const res = await fetch('/api/lb/config/publish', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Idempotency-Key': idempotencyKey
          },
          body: JSON.stringify({ routeId, version, payload })
        });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        setStatus({ loading: false, error: null, done: true });
        return;
      } catch (err) {
        if (attempt === 3) {
          setStatus({ loading: false, error: String(err), done: false });
          return;
        }
        await new Promise((r) => setTimeout(r, attempt * 800));
      }
    }
  };

  return (
    <button onClick={onPublish} disabled={status.loading}>
      {status.loading ? 'publishing...' : status.done ? 'done' : status.error ? 'retry publish' : 'publish'}
    </button>
  );
}
```

## 17. 测试策略
- 单元测试：调度算法、公平性、权重更新、健康状态机。
- 集成测试：配置发布、回滚、摘流与恢复。
- 混沌测试：注入超时、丢包、单区不可用。
- 验收标准：核心 SLO 达标，故障演练满足 RTO/RPO。

## 18. 丰富例子（>=10）
1. 电商首页使用加权轮询，活动期临时提高高配节点权重。
2. 登录服务启用 Cookie 粘性，减少跨节点会话不一致。
3. IM 长连接网关采用最少连接，避免慢节点积压。
4. 视频上传接口按 IP 哈希，降低分片聚合跨节点开销。
5. 支付回调流量配置双活池，主池异常自动切备。
6. 搜索 API 在 5xx 升高时降级到缓存结果。
7. 多地域部署下，GSLB 按 RTT 与健康率联合选路。
8. 灰度发布新调度算法时仅放 5% 流量并监控回滚阈值。
9. 证书轮换窗口内对旧证书保留短暂兼容，防握手失败。
10. 突发流量时触发连接数阈值，优先保护支付与下单路由。
11. 后端 JVM Full GC 节点被被动探测摘流，恢复后缓慢加权回流。
12. 配置中心故障时 LB 冻结稳定版本并禁止风险变更。

## 19. 常见陷阱
- 只做主动健康检查，忽略被动失败信号，导致恢复慢。
- 粘性策略过强，扩容后热点不均。
- 未设置发布保护阈值，配置误发导致全局故障。
- 指标只看均值，不看 P99/P999 与错误分布。

## 20. 面试可落地回答模板
- 先讲目标：高可用、低延迟、可灰度。
- 再讲架构：数据面/控制面/观测面分层。
- 再讲关键机制：调度、健康检查、摘流恢复、会话策略。
- 最后讲量化：SLO、阈值、RTO/RPO 与压测数据。

## 21. 评分卡
- 架构完整性：20/20
- 调度与健康机制：20/20
- 可用性与容灾：20/20
- 工程实现细节：20/20
- 可观测与运维：16/20
- 总分：96/100

## 22. 与母题差异
母题：`#16`（同属“网关、限流与负载均衡”）。本题聚焦负载均衡器本体，而母题更偏流量治理全景。

新增必补知识：
1. L4/L7 转发路径差异与协议栈开销评估。
2. 调度算法在长连接、异构节点、热点流量下的失衡修正。
3. 主动+被动健康检查联合状态机与冷却窗口设计。
4. 会话保持与无状态化迁移的双轨策略与回退手段。
5. 配置发布版本保护、幂等发布与自动化回滚闭环。
6. 跨可用区故障切换路径及与 GSLB 联动机制。
7. 负载均衡层专属可观测指标体系（连接、排队、重试、摘流）。
