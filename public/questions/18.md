# 母题 Q18：文档协同编辑系统（新手能懂 + 面试能讲清）

## 0. 先用三句话讲明白这题
1. 多人同时改同一份文档，系统要让每个人看到“最终一样”的内容。  
2. 难点不是“发消息”，而是“并发冲突怎么处理、断网回来怎么补”。  
3. 面试高分关键：你要讲清楚“规则 + 流程 + 兜底”，而不是只说 OT/CRDT 这几个词。  

---

## 1. 先讲一个真实小故事（最容易开场）
### 场景
- Alice 和 Bob 同时编辑一份会议纪要。  
- Alice 在第 5 个字符插入 `A`。  
- Bob 也在第 5 个字符插入 `B`。  

### 问题
- 如果没有规则，Alice 看到 `A` 在前，Bob 看到 `B` 在前，最终两人文档不一样。  

### 我们要做到
- 不管网络先后顺序如何，最终所有人文档一致。  

---

## 2. 把抽象名词翻译成白话（面试特别好用）
| 术语 | 白话解释 | 你可以怎么说 |
|---|---|---|
| Operation（操作） | 用户一次编辑动作 | “比如在 88 位置插入 hello” |
| baseVersion | 客户端编辑时看到的文档版本号 | “我是在 v120 基础上改的” |
| serverVersion | 服务端确认后的全局版本号 | “服务端现在是 v123” |
| OT | 并发操作来了先做“位置换算”再应用 | “把后来的操作改成适配新上下文” |
| CRDT | 操作天然可合并，不靠中心转换也能收敛 | “各端最后会自己对齐” |
| Snapshot（快照） | 某个版本文档全文 | “类似游戏存档” |
| Op Log（操作日志） | 从旧版本到新版本的编辑记录 | “回放录像” |
| Presence | 在线状态、光标位置 | “谁在线、光标在哪” |
| Idempotency（幂等） | 同一个请求重发多次，只生效一次 | “重发不重复写” |
| Backpressure（背压） | 处理不过来时主动降速 | “避免系统被拖死” |

---

## 3. 需求澄清（Functional / Non-Functional / 不做）
### 3.1 功能需求
- 多人实时编辑（文字插入、删除、替换）。  
- 光标同步（看到别人正在改哪里）。  
- 断网重连后自动同步。  
- 版本历史可回看。  

### 3.2 非功能需求
- 本地输入立刻显示（本地回显 < 50ms）。  
- 远端同步快（P95 < 200ms）。  
- 关键编辑不丢（操作日志可回放）。  
- 服务可用（>= 99.95%）。  

### 3.3 第一版不做
- 复杂排版引擎（页眉页脚、复杂表格布局）。  
- 超强离线加密协同。  
- 全球多区域强一致版本号。  

### 3.4 面试开口模板
“我先把需求分成三块：实时协同、正确性、可恢复性。  
实时协同关注延迟，正确性关注并发冲突，恢复性关注断网和重放。”  

---

## 4. 容量估算（一步一步算给面试官看）
### 4.1 输入假设（示例）
- 同时在线编辑用户：`60,000`  
- 人均编辑频率：`1.2 ops/s`  
- 单操作包大小：`220 bytes`  

### 4.2 计算
- 总操作吞吐：`60,000 * 1.2 = 72,000 ops/s`  
- 单向带宽：`72,000 * 220B ≈ 15.8MB/s`  
- 双向 + 协议开销按 3 倍：约 `47MB/s`  

### 4.3 为什么这个估算重要
- 它决定你需要多少网关连接节点、协同引擎节点、日志存储吞吐。  
- 面试官会看你是不是“用数字驱动架构”。  

### 4.4 面试一句话
“我会先按 70k ops/s 级别设计，再预留 2~3 倍突发空间。”  

---

## 5. 架构：先讲简版，再讲完整版（新手最容易懂）
### 5.1 简版（先让人听懂）
```text
客户端编辑器
  -> 网关（长连接）
    -> 协同服务（冲突处理）
      -> 操作日志库（永远追加）
      -> 快照库（定期存档）
```

### 5.2 完整版（面试加分）
```text
Client Editor SDK
  -> Edge Gateway (WebSocket, Auth, Routing)
    -> Collaboration Engine (OT/CRDT, ordering)
      -> Operation Log Store
      -> Snapshot Store
      -> Presence Service (cursor/online)
      -> PubSub (广播)
  -> Metrics + Logs + Traces + Alert
```

### 5.3 每层一句话职责
- SDK：本地先改，网络恢复后再对齐。  
- Gateway：管理连接，不做复杂业务。  
- Collaboration Engine：这是核心，决定“最终是否一致”。  
- Log/Snapshot：保证“能恢复、能追责、能回滚”。  

---

## 6. 数据模型（带白话解释）
### 6.1 文档主表
```sql
CREATE TABLE doc_meta (
  doc_id BIGINT PRIMARY KEY,
  title VARCHAR(256) NOT NULL,
  current_version BIGINT NOT NULL,
  snapshot_version BIGINT NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
```
- `current_version`：当前全局版本号。  
- `snapshot_version`：最近一次存档版本。  

### 6.2 操作日志（核心）
```sql
CREATE TABLE doc_op_log (
  op_id BIGINT PRIMARY KEY,
  doc_id BIGINT NOT NULL,
  actor_id BIGINT NOT NULL,
  client_op_id VARCHAR(128) NOT NULL,
  base_version BIGINT NOT NULL,
  server_version BIGINT NOT NULL,
  op_type VARCHAR(32) NOT NULL,
  op_payload JSON NOT NULL,
  ts TIMESTAMP NOT NULL,
  UNIQUE KEY uk_doc_actor_clientop (doc_id, actor_id, client_op_id),
  KEY idx_doc_version (doc_id, server_version)
);
```
- `client_op_id` 是幂等关键字段。  
- `server_version` 保证全序。  

### 6.3 快照表
```sql
CREATE TABLE doc_snapshot (
  doc_id BIGINT NOT NULL,
  version BIGINT NOT NULL,
  snapshot_blob LONGBLOB NOT NULL,
  created_at TIMESTAMP NOT NULL,
  PRIMARY KEY (doc_id, version)
);
```
- 没有快照就只能从 v1 全量回放，打开文档会很慢。  

---

## 7. 协议设计（消息字段讲透）
### 7.1 客户端发送操作
```json
{
  "type": "DOC_OP",
  "docId": 90001,
  "clientOpId": "u123-45678",
  "baseVersion": 120,
  "op": {"kind":"insert","pos":88,"text":"hello"},
  "traceId": "trace-abc"
}
```

### 7.2 服务端 ACK
```json
{
  "type": "DOC_OP_ACK",
  "docId": 90001,
  "clientOpId": "u123-45678",
  "serverVersion": 123,
  "transformed": {"kind":"insert","pos":90,"text":"hello"}
}
```

### 7.3 字段解释（面试可直接背）
- `clientOpId`：防重。  
- `baseVersion`：告诉服务端“我改的时候看到的版本”。  
- `serverVersion`：服务端确认后的最终顺序。  
- `transformed`：说明服务端做过位置调整。  

---

## 8. 核心流程（面试最重要）
### 8.1 正常编辑流程
1. 用户输入，SDK 本地先显示（不等服务器）。  
2. 操作发到协同服务。  
3. 服务端做顺序和冲突处理。  
4. 写日志、更新版本。  
5. 广播给其他用户。  

### 8.2 并发冲突流程（例子）
- A、B 同时在位置 10 插入字符。  
- 服务器先收到 A，B 后到。  
- B 位置会被改成 11（或按规则变更）。  
- 最终全员一致。  

### 8.3 断网重连流程（例子）
1. 用户断网时本地继续记录 pending ops。  
2. 重连带 `lastAckVersion`。  
3. 服务端补发缺失操作。  
4. 客户端重放 pending ops 并重新转换。  

### 8.4 打开大文档流程
1. 拉最近快照（比如 v1000）。  
2. 拉 v1001~最新增量。  
3. 回放增量后进入实时会话。  

---

## 9. OT/CRDT 到底怎么选（说人话）
### 9.1 你可以这样回答
- “如果是在线实时协同文本，首版我选 OT，性能和工程复杂度更可控。”  
- “如果强调离线长期编辑和多端最终收敛，我会考虑 CRDT。”  

### 9.2 为什么不是只背术语
- 面试官更想听“你为什么这么选”，不是听定义。  
- 你要给边界：规模、延迟、离线需求、团队实现能力。  

### 9.3 一句话对比
- OT：中心协调强，转换逻辑复杂。  
- CRDT：去中心更强，元数据成本更高。  

---

## 10. 一致性、事务、幂等（最容易扣分的点）
### 10.1 一致性目标
- 单文档最终一致。  
- 版本号单调递增。  
- 重试不重复应用。  

### 10.2 事务边界
- 同一文档操作入库 + 版本递增放在一个事务里。  
- 广播失败不回滚主事务，改为异步补发。  

### 10.3 幂等规则
- 唯一键：`doc_id + actor_id + client_op_id`。  
- 同一个 op 重发，返回旧 ACK，不重复写。  

---

## 11. 热点文档治理（大群编辑怎么不崩）
### 11.1 典型问题
- 一个热点文档 800 人在线，广播风暴导致队列积压。  

### 11.2 处理办法
- 文档会话分片（按 docId 路由到固定协同分区）。  
- 批量广播（多个操作合并推送）。  
- Presence 降采样（光标不必每毫秒都发）。  
- 慢客户端限速（防止拖垮全局）。  

### 11.3 面试例子
- “直播稿件协同写作时，我们把光标同步从 20Hz 降到 5Hz，CPU 降 35%，用户无明显感知。”  

---

## 12. 可用性与容错（必须讲演练）
### 12.1 常见故障
- 网关节点掉线。  
- 协同服务实例重启。  
- PubSub 堵塞。  
- 快照服务异常。  

### 12.2 对应策略
- 会话重连 + 同文档一致路由。  
- 未 ACK 操作重发。  
- 广播失败退化为增量拉取。  
- 快照失败退化日志回放。  

### 12.3 RTO / RPO
- RTO `< 5min`  
- RPO 接近 `0`（依赖 append-only 操作日志）  

---

## 13. 可观测性（指标一定要具体）
### 13.1 必看指标
- `op_ingest_qps`（写入吞吐）  
- `ack_latency_p95/p99`（用户体感）  
- `reconnect_recovery_time`（断线恢复）  
- `hot_doc_queue_depth`（热点风险）  
- `op_dedup_rate`（幂等重放情况）  

### 13.2 告警阈值示例
- `ack_p99 > 500ms` 持续 5 分钟 -> P1  
- `hot_doc_queue_depth > 5000` 持续 2 分钟 -> P1  
- `reconnect_recovery_time > 3s` 持续 10 分钟 -> P2  

### 13.3 新手好懂解释
- “如果 ACK 变慢，用户会感觉‘我打字别人看不到’。”  

---

## 14. 安全与合规
- 文档级权限（读/写/评论/分享）。  
- 所有编辑行为审计可追溯。  
- 传输层 TLS。  
- 敏感文档访问加水印和导出限制。  

---

## 15. 成本与取舍
### 15.1 主要成本
- 长连接基础设施成本。  
- 操作日志存储成本。  
- 热点文档广播带宽成本。  

### 15.2 常见取舍
- 更低延迟 = 更高实时广播成本。  
- 更长审计保留 = 更高存储成本。  
- 更强离线能力（CRDT）= 更高元数据成本。  

---

## 16. Java 关键代码（加注释，便于新手）
### 16.1 会话管理（谁在编辑这篇文档）
```java
public class SessionRegistry {
  private final ConcurrentHashMap<Long, ConcurrentHashMap<Long, Session>> docSessions = new ConcurrentHashMap<>();

  public void join(long docId, long userId, Session session) {
    // docId -> (userId -> session)
    docSessions.computeIfAbsent(docId, k -> new ConcurrentHashMap<>()).put(userId, session);
  }

  public void leave(long docId, long userId) {
    ConcurrentHashMap<Long, Session> users = docSessions.get(docId);
    if (users == null) return;
    users.remove(userId);
    if (users.isEmpty()) docSessions.remove(docId);
  }

  public Collection<Session> peers(long docId) {
    ConcurrentHashMap<Long, Session> users = docSessions.get(docId);
    return users == null ? List.of() : users.values();
  }
}
```

### 16.2 幂等 + 版本递增（核心写路径）
```java
public class OperationService {
  public Ack apply(long docId, long actorId, ClientOp op) {
    Transaction tx = txManager.begin();
    try {
      // 1) 幂等去重：同一个 clientOpId 不重复执行
      if (opRepo.exists(docId, actorId, op.clientOpId())) {
        return opRepo.loadAck(docId, actorId, op.clientOpId());
      }

      // 2) 锁文档版本，保证同文档顺序
      long current = docRepo.lockAndGetVersion(docId);

      // 3) 并发转换（示意）
      Operation transformed = transformer.transformAgainstRange(docId, op.baseVersion(), current, op.operation());
      long nextVersion = current + 1;

      // 4) 入日志 + 更新版本
      opRepo.insert(docId, actorId, op.clientOpId(), op.baseVersion(), nextVersion, transformed);
      docRepo.updateVersion(docId, nextVersion);

      tx.commit();
      return Ack.ok(docId, op.clientOpId(), nextVersion, transformed);
    } catch (Exception e) {
      tx.rollback();
      throw e;
    }
  }
}
```

### 16.3 重连补偿（按版本补缺口）
```java
public class ReconnectService {
  public SyncPackage resume(long docId, long lastAckVersion) {
    long latest = docRepo.currentVersion(docId);
    if (latest == lastAckVersion) return SyncPackage.empty(latest);

    // 缺口小：直接补操作日志
    if (latest - lastAckVersion <= 500) {
      List<OperationEvent> events = opRepo.list(docId, lastAckVersion + 1, latest);
      return SyncPackage.withEvents(latest, events);
    }

    // 缺口大：返回快照 + 增量
    Snapshot snap = snapshotRepo.latest(docId);
    List<OperationEvent> tail = opRepo.list(docId, snap.version() + 1, latest);
    return SyncPackage.withSnapshot(latest, snap, tail);
  }
}
```

### 16.4 快照压缩任务（降低打开文档成本）
```java
public class SnapshotJob {
  @Scheduled(fixedDelay = 60000)
  public void compact() {
    List<Long> docs = docRepo.findNeedSnapshotDocs(500); // 每累计 500 次操作做一次快照
    for (Long docId : docs) {
      Snapshot latest = snapshotRepo.latest(docId);
      long currentVersion = docRepo.currentVersion(docId);
      List<OperationEvent> ops = opRepo.list(docId, latest.version() + 1, currentVersion);

      byte[] merged = replay(latest.content(), ops);
      snapshotRepo.save(docId, currentVersion, merged);
    }
  }
}
```

---

## 17. 丰富例子（新手最容易吸收）
1. **同位置同时插入**：A 插 `X`，B 插 `Y`，规则决定谁先谁后，最终全员一致。  
2. **删除与插入冲突**：A 删 [5,8]，B 在 6 插入，B 的位置要重算。  
3. **断网地铁场景**：本地先记 20 个操作，重连后自动补齐。  
4. **热点文档场景**：800 人同改，启用批量广播与背压。  
5. **超时重发场景**：客户端重发同 opId，服务端识别后不重复执行。  
6. **快照损坏场景**：回退到上一个快照 + 增量日志恢复。  
7. **权限变更场景**：用户编辑中被撤权，后续操作立即拒绝。  
8. **多机房延迟场景**：ACK 变慢触发路由切换和降级。  
9. **审计追责场景**：定位“谁删除了第 3 段”，从 op log 回放可追溯。  
10. **算法升级场景**：OT v1 升级 v2，灰度对比异常就回滚。  

---

## 18. 测试策略（面试经常加分）
### 18.1 单测
- OT 转换函数边界测试。  
- 幂等去重测试。  

### 18.2 属性测试（Property-based）
- 随机打乱操作顺序，最终内容应一致。  

### 18.3 压测
- 单文档并发 100/500/1000 人。  
- 重连风暴场景。  

### 18.4 故障注入
- 模拟 PubSub 延迟、网关重启、日志库抖动。  

---

## 19. 面试高频追问 + 可直接复述答案
### Q1：为什么选 OT 不选 CRDT？
- “这个业务实时在线为主、离线不是第一优先，我先选 OT 以降低实现复杂度。后续如果离线场景变重，再评估 CRDT 迁移。”  

### Q2：怎么保证不丢操作？
- “操作先落 append-only 日志，再异步广播；ACK 以落日志为准，断线后按版本补齐。”  

### Q3：热点文档怎么扛？
- “固定路由到文档分区、批量广播、Presence 降采样、慢客户端限速。”  

### Q4：怎么证明你方案正确？
- “我会做随机并发操作的属性测试，验证最终收敛；再做断网重连与故障注入演练。”  

### Q5：如果算法升级出错怎么办？
- “发布走灰度，保留协议兼容层，异常一键回滚到稳定版本。”  

---

## 20. 新手学习路线（7 天）
1. 第 1 天：理解 WebSocket、ACK、重连。  
2. 第 2 天：写一个单房间协同原型（不处理冲突）。  
3. 第 3 天：加入版本号和幂等去重。  
4. 第 4 天：加入 OT 两三种核心转换规则。  
5. 第 5 天：加入快照和日志回放。  
6. 第 6 天：做压测和断网恢复。  
7. 第 7 天：按面试结构讲一遍并录音复盘。  

---

## 21. 上场前 Checklist
- [ ] 我能用 1 分钟说清这题本质。  
- [ ] 我能画出“客户端-网关-协同服务-日志/快照”架构。  
- [ ] 我能用例子说明并发冲突如何收敛。  
- [ ] 我能解释断网恢复怎么做。  
- [ ] 我能给出 3 个关键监控指标和阈值。  
- [ ] 我能回答“为什么 OT/CRDT 这么选”。  

---

## 22. 30 秒总结
- 这题最难的是“并发正确性”，不是“连接技术”。  
- 高分答案要覆盖：冲突处理、幂等去重、断网恢复、快照回放、故障演练。  
- 你只要按“故事 -> 规则 -> 例子 -> 兜底”讲，面试官会觉得你真的做过。  
