# Q46 Real-time Bidding (实时竞价)

> 来源校验（questions.ts）  
> `title`: Real-time Bidding (实时竞价)  
> `tags`: 广告竞价, 低延迟, 特征召回, 预算控制, 归因  
> `keyPoints`: 毫秒级请求链路, 多阶段召回排序, 预算与频控, 反作弊, 日志归因  
> `learningCoreId`: 36（母题：Design Amazon Recommendation）

## 1. 三句话题目本质
1. RTB 的本质是在极短时间内完成“是否投放 + 出价多少”的决策。
2. 难点是延迟约束极严（常见 100ms 内）且要兼顾收益、预算、风控。
3. 高分回答要讲清：请求链路分层、预算频控、反作弊和归因反馈闭环。

## 2. 一个真实场景故事
某广告平台高峰每秒 80 万次竞价请求，链路超时率升到 6%。问题集中在特征服务抖动和预算查询热点。团队优化为两层决策：快速候选召回+轻量打分先返回，复杂特征异步补齐；同时加预算本地配额桶，超时率降到 0.8%，eCPM 提升 11%。

## 3. 术语白话表（>=10）
1. Bid Request：广告请求（用户、媒体位、上下文）。
2. DSP：需求方平台，代表广告主出价。
3. SSP：供给方平台，提供流量库存。
4. Auction：竞价拍卖过程。
5. eCPM：每千次展示收益指标。
6. Pacing：预算消耗节奏控制。
7. Frequency Capping：频次上限控制（防重复打扰）。
8. Feature Store：在线特征存储。
9. Candidate Recall：候选广告召回。
10. Ranking：候选排序和出价计算。
11. Fraud Score：反作弊风险分。
12. Attribution：归因（曝光/点击/转化关联）。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 接收竞价请求并返回出价响应。
2. 支持多阶段召回与排序。
3. 支持预算控制与频次控制。
4. 支持反作弊过滤。
5. 支持曝光/点击/转化日志归因。

### 4.2 非功能需求
1. 低延迟：竞价响应 P95 <= 80ms。
2. 高可用：>=99.95%。
3. 高吞吐：支持百万级 QPS。
4. 收益稳定：预算超支率低于阈值。

### 4.3 不做范围
1. 不做广告素材审核平台全能力。
2. 不做深度离线训练平台设计。
3. 不做第三方账务结算系统。

### 4.4 SLO
1. `bid_response_p95_ms <= 80`。
2. `budget_overspend_rate <= 0.5%`。
3. `fraud_miss_rate <= 1%`（目标值）。

## 5. 容量估算（数字推导）
1. 峰值请求 80 万 QPS，平均请求体 1.5KB，入口约 1.2GB/s。
2. 每请求召回候选 200 条，排序后输出 1 条。
3. 若每候选打分 5us，单请求 1ms 计算预算，需并行化。
4. 曝光日志按 20% 命中率估算，约 16 万条/s。
5. 点击+转化日志约 1 万条/s，归因存储需按 7~30 天保留。
6. 结论：必须做快慢路径拆分 + 特征缓存 + 预算本地化。

## 6. 架构（简版+完整版）
### 6.1 简版
`Bid Gateway -> Auction Service -> Budget/Freq -> Response`

### 6.2 完整版
1. Bid Gateway：请求校验、超时控制、限流。
2. Recall Service：候选广告召回（关键词/人群/上下文）。
3. Ranking Service：多模型打分与出价计算。
4. Budget & Freq Service：预算节奏和频控校验。
5. Fraud Guard：实时反作弊评分。
6. Win Notifier：竞价赢单回调。
7. Logging Pipeline：曝光/点击/转化日志链路。
8. Attribution Engine：归因与效果报表。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 竞价接口
`POST /api/rtb/v1/bid`

请求：
```json
{
  "requestId": "bid-20260224-001",
  "slotId": "news_feed_top",
  "user": {"id":"u123","device":"ios"},
  "context": {"geo":"US","hour":10}
}
```

响应：
```json
{
  "creativeId": "cr_998",
  "bidPrice": 1.23,
  "campaignId": "cmp_88",
  "ttlMs": 120
}
```

### 7.2 曝光回调
`POST /api/rtb/v1/impression`

### 7.3 点击回调
`POST /api/rtb/v1/click`

错误码：
1. `204_NO_BID`
2. `429_BUDGET_EXHAUSTED`
3. `429_FREQ_CAPPED`
4. `503_MODEL_TIMEOUT`

幂等规则：
1. `requestId` 作为竞价幂等键。
2. 曝光/点击用 `eventId` 去重。

## 8. 数据模型（实体/索引/分片）
1. `campaign(campaign_id, daily_budget, pacing_mode, status)`。
2. `budget_spend(campaign_id, minute_bucket, spent)`。
3. `freq_cap(user_id, campaign_id, count, window_end)`。
4. `bid_log(request_id, campaign_id, score, price, ts)`。
5. `event_log(event_id, type, campaign_id, user_id_hash, ts)`。

索引与分片：
1. `campaign_id + minute_bucket` 支持预算快速更新。
2. 高频 `freq_cap` 使用 Redis 分片存储。
3. `event_log` 按日期分区，按 `campaign_id` 二级索引。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. Gateway 接收请求并设置 80ms 超时预算。
2. Recall 拉候选，Ranking 计算分数与出价。
3. Budget/Freq/Fraud 过滤，返回最优广告。

### 9.2 高峰流程
1. 特征服务慢时走降级特征（缓存特征）。
2. 模型超时走轻量规则模型兜底。
3. 预算服务启用本地令牌桶减少中心访问。

### 9.3 故障恢复流程
1. 某依赖异常触发熔断，切到 NO_BID 或低风险广告池。
2. 日志链路积压时先保主竞价，日志异步回补。
3. 恢复后做归因补算，修正报表偏差。

## 10. 一致性与事务边界
1. 竞价响应链路优先低延迟，采用最终一致记账。
2. 预算扣减采用“预扣+异步对账”模型。
3. 曝光日志至少一次投递，下游 `eventId` 去重。
4. 归因结果允许延迟收敛，不影响在线竞价。
5. 超支控制以分钟窗口修正，避免强一致导致超时。

## 11. 可用性与容错（含 RTO/RPO）
1. 核心服务多副本与跨 AZ 部署。
2. 依赖超时隔离，快慢路径分离。
3. 关键缓存多级（本地+Redis）提高容错。
4. RTO：核心竞价能力 10 分钟恢复。
5. RPO：日志与归因数据允许分钟级补偿。

## 12. 可观测性（指标+阈值+处置动作）
1. `bid_response_p95_ms` > 80ms（3m）：降级特征和模型。
2. `no_bid_rate` > 20%：检查召回覆盖和预算配置。
3. `budget_overspend_rate` > 0.5%：收紧 pacing 策略。
4. `fraud_block_rate` 异常突增：排查规则误杀。
5. `model_timeout_rate` > 2%：切换轻量模型并扩容。
6. `attribution_lag_min` > 30：触发回补任务。

## 13. 安全与合规
1. 用户标识哈希化，遵守隐私合规。
2. 反作弊策略防机器流量与点击农场。
3. 广告主数据访问隔离。
4. 高风险配置变更需要审批与审计。
5. 日志传输与存储加密。

## 14. 成本与取舍
1. 更复杂模型提高收益但增加延迟与成本。
2. 全量日志更精确但存储成本高。
3. 高频中心预算校验更准确但更慢。
4. 取舍：在线链路轻量化，离线链路补精度。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法/状态转移：候选排序与出价
```java
public BidDecision decide(List<CandidateAd> cands, Context ctx) {
    CandidateAd best = null;
    double bestScore = -1;
    for (CandidateAd ad : cands) {
        double score = ranker.score(ad, ctx);
        if (score > bestScore) {
            best = ad;
            bestScore = score;
        }
    }
    return best == null ? BidDecision.noBid() : BidDecision.win(best.id(), pricer.bid(bestScore));
}
```

### 15.2 幂等去重：请求去重
```java
public BidDecision bidWithIdem(BidRequest req) {
    BidDecision existed = idemRepo.get(req.requestId());
    if (existed != null) return existed;
    BidDecision decision = auction(req);
    idemRepo.save(req.requestId(), decision, Duration.ofMinutes(10));
    return decision;
}
```

### 15.3 重试退避/失败处理：模型调用降级
```java
public double scoreWithFallback(CandidateAd ad, Context ctx) {
    long delay = 10;
    for (int i = 0; i < 2; i++) {
        try {
            return modelClient.score(ad, ctx);
        } catch (RuntimeException ex) {
            sleep(delay);
            delay *= 2;
        }
    }
    return ruleScorer.score(ad, ctx);
}
```

### 15.4 一致性边界：预算预扣
```java
@Transactional
public boolean reserveBudget(String campaignId, long minuteBucket, double amount) {
    double left = budgetRepo.getRemainingForUpdate(campaignId, minuteBucket);
    if (left < amount) return false;
    budgetRepo.consume(campaignId, minuteBucket, amount);
    outboxRepo.insert("BUDGET_RESERVED", campaignId + ":" + minuteBucket);
    return true;
}
```

### 15.5 观测触发/回滚判定
```java
public void guardrail() {
    double timeoutRate = metrics.gauge("model_timeout_rate").value();
    if (timeoutRate > 0.02) {
        switcher.enable("lightweight_model");
        alerting.fire("MODEL_TIMEOUT_HIGH", "rate=" + timeoutRate);
    }
    double over = metrics.gauge("budget_overspend_rate").value();
    if (over > 0.005) {
        pacingControl.tighten();
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 竞价请求调试（loading/error/done）
```javascript
import { useState } from "react";

export function useBidPreview() {
  const [state, setState] = useState({ phase: "idle", data: null, error: "" });

  async function preview(payload) {
    setState({ phase: "loading", data: null, error: "" });
    try {
      const res = await fetch("/api/rtb/v1/bid", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok && res.status !== 204) throw new Error(`HTTP_${res.status}`);
      if (res.status === 204) return setState({ phase: "done", data: { noBid: true }, error: "" });
      setState({ phase: "done", data: await res.json(), error: "" });
    } catch (e) {
      setState({ phase: "error", data: null, error: String(e.message || e) });
    }
  }
  return { state, preview };
}
```

### 16.2 预算调整 API（幂等+重试）
```javascript
export async function adjustCampaignBudget(campaignId, dailyBudget) {
  const reqId = `budget-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 120;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch(`/api/campaign/v1/${campaignId}/budget`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Idempotency-Key": reqId },
        body: JSON.stringify({ dailyBudget, requestId: reqId })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 1000);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：排序、出价、预算频控规则。
2. 集成测试：竞价链路端到端+日志归因。
3. 压测：80 万 QPS 下延迟与超时率。
4. 故障测试：模型超时、特征缺失、日志积压。
5. 反作弊测试：异常点击流量注入。

## 18. 丰富例子（>=10）
1. 高峰时轻量模型兜底避免超时。
2. 新广告主预算过快消耗被 pacing 限速。
3. 用户频控命中后返回 no-bid。
4. 反作弊拦截异常设备 ID。
5. 竞价赢单但曝光回调延迟，后续补归因。
6. 某媒体位流量激增触发限流。
7. 候选召回不足导致 no-bid 上升并告警。
8. 预算服务短暂不可用时本地配额桶生效。
9. 模型版本回滚恢复 CTR。
10. 归因延迟导致报表暂时偏差后收敛。
11. 非核心日志抽样降低存储成本。
12. 竞价策略灰度发布后逐步放量。

## 19. 面试追问 + 可复述回答
1. 为什么 RTB 强调快慢路径？
回答：在线链路必须在预算时间内返回，复杂计算放离线或异步。
2. 预算怎么避免超支？
回答：在线预扣+分钟级对账补偿+pacing 控制。
3. 反作弊在链路中放哪里？
回答：召回后排序前做快速过滤，降低无效计算与损失。
4. 模型超时如何处理？
回答：降级规则模型、缩特征集、快速 fail-open/fail-close 策略。
5. 与推荐系统题区别？
回答：RTB 额外强调预算、竞价规则、归因和风控实时性。

## 20. 新手学习路线
1. 先掌握召回-排序基本链路。
2. 补预算频控和出价策略。
3. 加入反作弊与归因流水线。
4. 做降级策略与超时治理。
5. 进行压测和收益评估。

## 21. 上场前 Checklist
1. 能画出 100ms 竞价时序图。
2. 能说出预算和频控关键策略。
3. 能量化延迟阈值和超支阈值。
4. 能解释反作弊与归因位置。
5. 能说明与母题 Q36 的边界。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q36 Design Amazon Recommendation。

### 22.2 共性能力
1. 都包含召回、排序、特征服务。
2. 都需要在线推理与离线反馈。
3. 都依赖实验与指标监控。

### 22.3 关键差异
1. Q36 目标是推荐效果；Q46 目标是竞价收益与时延约束。
2. Q46 增加预算控制、竞价规则和赢单流程。
3. Q46 更强调反作弊与归因闭环。
4. Q46 延迟预算更严格，常是毫秒级硬约束。
5. Q46 需要与广告主预算、媒体位策略强耦合。

### 22.4 本题新增知识点（>=5）
1. 竞价拍卖与出价策略。
2. Pacing 与频控工程落地。
3. 反作弊实时评分与拦截。
4. 曝光/点击/转化归因机制。
5. 快慢路径与超时降级设计。
6. 收益与稳定性双目标优化。

### 22.5 面试差异话术
“Q36 是推荐泛化题，Q46 是广告竞价实战题；除了排序外，预算、频控、反作弊和归因才是 RTB 的核心差异。”

---

## 单题自审（Q46）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦 RTB，不泛化为普通推荐：通过。
2. 预算、频控、反作弊、归因完整：通过。

### D. 工程落地检查
1. 阈值与动作绑定：通过。
2. RTO/RPO 和降级策略明确：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端满足 API/状态流转/重试幂等：通过。

### F. 母题差异检查
1. 与 Q36 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过）
