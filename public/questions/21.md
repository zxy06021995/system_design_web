# 母题 Q21：聊天系统（Chat System，新手能懂 + 面试能讲清）

## 0. 先用三句话讲明白这题
1. 聊天系统本质是“把一条消息稳定、尽快、按规则送到对方设备”。  
2. 真正难点不是发消息，而是“顺序、重试、离线、多端一致”。  
3. 面试高分关键：你要讲清楚“消息生命周期 + 可靠投递 + 故障兜底”。  

---

## 1. 先讲一个真实小故事（最好开场）
### 场景
- 小王在手机上给小李发“到了吗？”。  
- 小李当时地铁没网，10 分钟后上线。  
- 小李在 iPad 和手机同时登录。  

### 问题
- 消息要不要丢？（不能）  
- 哪个设备先收到？（都要收到，状态要一致）  
- 重连后能不能按顺序补齐？（必须）  

### 我们要做到
- 发送方看到“已发送/已送达/已读”状态可追踪。  
- 接收方离线也能补齐消息。  
- 多端状态一致，顺序可解释。  

---

## 2. 把抽象名词翻译成白话（面试特别好用）
| 术语 | 白话解释 | 面试可直接说法 |
|---|---|---|
| Conversation | 会话 | “一对一或群聊的消息容器” |
| Message ID | 消息唯一编号 | “每条消息都能被唯一定位” |
| Seq | 会话内顺序号 | “保证这条消息在本会话的先后顺序” |
| ACK | 收到确认 | “客户端告诉服务端我确实收到了” |
| Read Receipt | 已读回执 | “用户看过这条消息了” |
| Fan-out | 扇出投递 | “一条群消息分发给多个成员” |
| Offline Queue | 离线队列 | “用户不在线时先存着” |
| At-least-once | 至少一次 | “可能重复，但不会丢” |
| Idempotency | 幂等 | “重复请求只处理一次” |
| Backfill | 补拉历史 | “重连后按缺口拉消息” |

---

## 3. 需求澄清（Functional / Non-Functional / 不做）
### 3.1 功能需求
- 支持单聊、群聊。  
- 支持文本消息（首版），后续可扩展图片/语音。  
- 支持消息状态：发送中、已发送、已送达、已读。  
- 支持离线消息和重连补拉。  
- 支持多端登录同步（手机/平板/PC）。  

### 3.2 非功能需求
- 发送到服务端 ACK：P95 `< 100ms`。  
- 在线投递延迟：P95 `< 300ms`。  
- 可用性：`>= 99.95%`。  
- 消息丢失率目标：接近 0（通过日志与重试保障）。  
- 单会话顺序有保证。  

### 3.3 第一版不做
- 不做端到端加密（可作为高级版本）。  
- 不做复杂消息撤回规则（先做基础撤回窗口）。  
- 不做超大群（如万人群）复杂分层投递。  

### 3.4 面试开口模板
“我先按消息生命周期来讲：创建 -> 持久化 -> 投递 -> ACK -> 已读 -> 归档。  
每一步都要有失败兜底和观测指标。”  

---

## 4. 容量估算（一步一步算）
### 4.1 输入假设（示例）
- DAU：`50,000,000`  
- 峰值在线用户：`8,000,000`  
- 平均每用户每天发送消息：`30`  
- 峰值系数：`6x`  
- 文本消息平均大小（含协议）：`300B`  

### 4.2 计算
- 日消息量：`50,000,000 * 30 = 1,500,000,000`（15 亿）  
- 平均消息写入 QPS：`1,500,000,000 / 86400 ≈ 17,361`  
- 峰值写入 QPS：`17,361 * 6 ≈ 104,166`  

### 4.3 带宽粗估
- 仅写入数据：`104,166 * 300B ≈ 29.8MB/s`  
- 加上协议、扇出、ACK，按 4 倍预估：约 `120MB/s` 量级。  

### 4.4 为什么这很关键
- 决定 WebSocket 网关连接数、消息队列分区数、存储写吞吐。  

---

## 5. 架构：先讲简版，再讲完整版
### 5.1 简版（先让人听懂）
```text
客户端 -> 聊天网关 -> 消息服务 -> 消息存储
                        -> 在线投递
                        -> 离线补偿
```

### 5.2 完整版（面试加分）
```text
Client SDK
  -> Chat Gateway (WebSocket, auth, session routing)
    -> Message Service (idempotency, seq allocation, state machine)
      -> Message Store (append-only + query index)
      -> Conversation Store (members, metadata)
      -> Delivery Queue (Kafka/Pulsar)
      -> Delivery Worker (online push / offline queue)
      -> ACK Service (delivered/read updates)
      -> Sync Service (reconnect backfill)
  -> Push Channel (APNS/FCM for offline wakeup)
  -> Observability (metrics/logs/traces/alerts)
```

### 5.3 每层一句话职责
- Gateway：管理连接与路由，不做重业务。  
- Message Service：写入、分配顺序、幂等控制。  
- Delivery Worker：负责真正“送达”。  
- Sync Service：用户重连时补齐缺口。  

---

## 6. 消息生命周期（你必须会讲）
1. **Create**：客户端发消息请求。  
2. **Persist**：服务端落库，拿到 messageId + seq。  
3. **Fan-out**：投递到接收者设备。  
4. **Delivered ACK**：设备确认收到。  
5. **Read ACK**：用户打开会话后标记已读。  
6. **Archive**：冷数据归档，降低热存储成本。  

---

## 7. API 设计（带示例）
### 7.1 发送消息
`POST /v1/messages/send`

Request:
```json
{
  "conversationId": "c-10086",
  "senderId": "u-1",
  "clientMsgId": "u1-170000001",
  "type": "TEXT",
  "content": "到了吗？"
}
```

Response:
```json
{
  "messageId": "m-9000001",
  "seq": 12045,
  "serverTs": 1771900123456,
  "status": "SENT"
}
```

### 7.2 拉取历史
`GET /v1/conversations/{id}/messages?fromSeq=12000&limit=50`

### 7.3 ACK 已送达
`POST /v1/messages/{messageId}/delivered`

### 7.4 ACK 已读
`POST /v1/conversations/{id}/read?upToSeq=12045`

### 7.5 重连补拉
`GET /v1/sync?conversationId=c-10086&lastSeq=12020`

---

## 8. 数据模型（SQL + 白话）
### 8.1 会话表
```sql
CREATE TABLE conversation (
  conversation_id BIGINT PRIMARY KEY,
  type VARCHAR(16) NOT NULL,        -- SINGLE / GROUP
  owner_id BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
```

### 8.2 会话成员表
```sql
CREATE TABLE conversation_member (
  conversation_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  role VARCHAR(16) NOT NULL,
  joined_at TIMESTAMP NOT NULL,
  PRIMARY KEY (conversation_id, user_id)
);
```

### 8.3 消息主表（核心）
```sql
CREATE TABLE message (
  message_id BIGINT PRIMARY KEY,
  conversation_id BIGINT NOT NULL,
  seq BIGINT NOT NULL,              -- 会话内递增序号
  sender_id BIGINT NOT NULL,
  client_msg_id VARCHAR(128) NOT NULL,
  msg_type VARCHAR(16) NOT NULL,
  content JSON NOT NULL,
  send_ts TIMESTAMP NOT NULL,
  UNIQUE KEY uk_conv_clientmsg (conversation_id, sender_id, client_msg_id),
  UNIQUE KEY uk_conv_seq (conversation_id, seq),
  KEY idx_conv_time (conversation_id, send_ts)
);
```

### 8.4 投递状态表
```sql
CREATE TABLE message_delivery (
  message_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  device_id VARCHAR(64) NOT NULL,
  state VARCHAR(16) NOT NULL,       -- PENDING/DELIVERED/READ
  updated_at TIMESTAMP NOT NULL,
  PRIMARY KEY (message_id, user_id, device_id)
);
```

### 8.5 离线队列表（可落 Redis/Kafka）
```sql
CREATE TABLE offline_inbox (
  user_id BIGINT NOT NULL,
  conversation_id BIGINT NOT NULL,
  seq BIGINT NOT NULL,
  message_id BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL,
  PRIMARY KEY (user_id, conversation_id, seq)
);
```

---

## 9. 协议设计（WebSocket 事件）
### 9.1 客户端发消息事件
```json
{
  "event": "SEND_MSG",
  "conversationId": "c-10086",
  "clientMsgId": "u1-170000001",
  "payload": {"type":"TEXT","text":"到了吗？"}
}
```

### 9.2 服务端确认事件
```json
{
  "event": "MSG_ACK",
  "clientMsgId": "u1-170000001",
  "messageId": "m-9000001",
  "seq": 12045,
  "status": "SENT"
}
```

### 9.3 下行投递事件
```json
{
  "event": "NEW_MSG",
  "conversationId": "c-10086",
  "messageId": "m-9000001",
  "seq": 12045,
  "payload": {"type":"TEXT","text":"到了吗？"}
}
```

### 9.4 字段解释（面试可直接背）
- `clientMsgId`：解决重发重复写。  
- `seq`：保证会话内顺序。  
- `messageId`：全局唯一追踪 ID。  

---

## 10. 核心流程（面试必讲）
### 10.1 正常发送流程
1. 客户端发送 `SEND_MSG`（带 clientMsgId）。  
2. 服务端幂等检查，重复就回放旧结果。  
3. 落库生成 messageId + seq。  
4. 写投递队列，异步推送给接收方。  
5. 发送方收到 `MSG_ACK`。  

### 10.2 在线投递流程
1. Delivery Worker 查接收方在线设备。  
2. 下行 `NEW_MSG`。  
3. 设备回 `DELIVERED_ACK`。  
4. 更新 message_delivery 状态。  

### 10.3 离线补偿流程
1. 接收方离线，消息进入 offline_inbox。  
2. 同时走 APNS/FCM 推送“有新消息”。  
3. 用户上线后按 `lastSeq` 补拉。  

### 10.4 多端已读同步流程
1. 用户在 iPad 打开会话，发 `read upToSeq=12045`。  
2. 服务端更新 read pointer。  
3. 广播到该用户其他设备（手机/PC）同步已读状态。  

---

## 11. 一致性、顺序、幂等（面试核心）
### 11.1 顺序保证策略
- 单会话使用 `seq` 单调递增。  
- 只承诺“会话内顺序”，不承诺跨会话顺序。  

### 11.2 一致性边界
- 消息落库后视为已发送成功。  
- 投递是最终一致（可能短延迟）。  

### 11.3 投递语义
- 默认 `at-least-once`（可能重复）。  
- 客户端按 `messageId` 去重展示。  

### 11.4 幂等策略
- 唯一键：`conversation_id + sender_id + client_msg_id`。  
- 重试请求命中幂等后返回历史 ACK。  

---

## 12. 可用性与容错（系统自己挂了怎么办）
### 12.1 常见故障
- 网关节点掉线。  
- 队列积压。  
- 存储抖动。  
- 某个用户离线很久。  

### 12.2 对应策略
- 网关掉线：客户端自动重连 + resume token。  
- 队列积压：优先级队列 + 扩容 worker + 背压。  
- 存储抖动：快速失败 + 重试 + 降级策略。  
- 长离线：分页补拉，避免一次性拉爆。  

### 12.3 RTO / RPO
- RTO `< 10 min`。  
- RPO 目标接近 0（消息主日志持久化）。  

---

## 13. 可观测性（指标一定要具体）
### 13.1 必看指标
- `send_qps`, `deliver_qps`, `ack_qps`  
- `send_to_ack_p95/p99`  
- `delivery_latency_p95/p99`  
- `offline_queue_depth`  
- `dedup_hit_rate`  
- `queue_lag`  

### 13.2 告警阈值示例
- `send_to_ack_p99 > 500ms` 持续 5 分钟 -> P1  
- `offline_queue_depth` 持续上涨 10 分钟 -> P1  
- `queue_lag > 60s` -> P1  

### 13.3 新手好懂解释
- “如果 queue lag 上涨，用户会感觉消息发出去了但对方迟迟收不到。”  

---

## 14. 安全与合规
- 鉴权：连接建立时 token 校验 + 续签。  
- 权限：会话成员才能收发该会话消息。  
- 审计：关键操作（撤回、拉黑、封禁）全留痕。  
- 敏感内容：可接入内容审核策略。  

---

## 15. 成本与取舍
### 15.1 主要成本
- 长连接网关资源成本。  
- 消息存储与索引成本。  
- 推送和离线队列成本。  

### 15.2 常见取舍
- 更低延迟要更高广播和网络成本。  
- 更强可靠性要更多持久化与重试开销。  
- 全量已读明细成本高，可用 read pointer 省成本。  

---

## 16. Java 关键代码（加注释，便于新手）
### 16.1 发送消息主流程（幂等 + 落库）
```java
public class MessageService {
  public SendAck send(SendCommand cmd) {
    Transaction tx = txManager.begin();
    try {
      // 幂等：避免客户端重试导致重复消息
      Message existing = messageRepo.findByClientMsgId(cmd.conversationId(), cmd.senderId(), cmd.clientMsgId());
      if (existing != null) {
        return SendAck.replay(existing.getMessageId(), existing.getSeq());
      }

      long seq = seqAllocator.nextSeq(cmd.conversationId());
      long msgId = idGenerator.nextId();
      messageRepo.insert(msgId, cmd.conversationId(), seq, cmd.senderId(), cmd.clientMsgId(), cmd.payload());
      outboxRepo.insert(msgId, cmd.conversationId(), seq, "MSG_CREATED");
      tx.commit();
      return SendAck.ok(msgId, seq);
    } catch (Exception e) {
      tx.rollback();
      throw e;
    }
  }
}
```

### 16.2 投递 Worker（在线优先，离线入箱）
```java
public class DeliveryWorker {
  public void onMessage(MessageEvent event) {
    List<DeviceSession> sessions = sessionService.onlineDevices(event.getReceiverId());
    if (sessions.isEmpty()) {
      offlineInbox.save(event.getReceiverId(), event.getConversationId(), event.getSeq(), event.getMessageId());
      pushService.notify(event.getReceiverId(), "NEW_MESSAGE");
      return;
    }

    for (DeviceSession s : sessions) {
      gateway.push(s, event.toDownlinkPayload());
      deliveryRepo.markPending(event.getMessageId(), event.getReceiverId(), s.getDeviceId());
    }
  }
}
```

### 16.3 ACK 处理（送达/已读）
```java
public class AckService {
  public void onDelivered(long messageId, long userId, String deviceId) {
    deliveryRepo.updateState(messageId, userId, deviceId, "DELIVERED");
  }

  public void onRead(long conversationId, long userId, long upToSeq) {
    readPointerRepo.update(conversationId, userId, upToSeq);
    // 同步到该用户其他设备
    syncService.broadcastReadState(conversationId, userId, upToSeq);
  }
}
```

### 16.4 重连补拉（按缺口）
```java
public class SyncService {
  public SyncResult resume(long conversationId, long userId, long lastSeq) {
    long latestSeq = messageRepo.latestSeq(conversationId);
    if (lastSeq >= latestSeq) return SyncResult.empty(latestSeq);

    // 一次最多补 200 条，避免大包
    List<Message> patch = messageRepo.listBySeqRange(conversationId, lastSeq + 1, Math.min(lastSeq + 200, latestSeq));
    return SyncResult.withMessages(latestSeq, patch);
  }
}
```

---

## 17. 丰富例子（保证你能讲给新手听）
1. **发送后立刻断网**：客户端重试同 clientMsgId，不会重复写。  
2. **接收方离线 3 小时**：消息进离线队列，上线后按 seq 补齐。  
3. **群聊 500 人**：一条消息 fan-out 到 500 个收件人。  
4. **多端登录**：手机已读后，PC 同步已读状态。  
5. **网络抖动重复 ACK**：幂等更新状态，不影响结果。  
6. **队列积压**：优先投递最近消息，老消息分批补偿。  
7. **热点群爆发**：按会话分区扩容 worker。  
8. **消息撤回**：生成“撤回事件”而不是直接删库。  
9. **消息重复展示**：客户端按 messageId 去重。  
10. **审计追责**：通过 messageId + op log 定位链路。  

---

## 18. 测试策略（面试加分）
### 18.1 单测
- seq 分配单调性。  
- 幂等发送去重。  
- ACK 状态机（SENT->DELIVERED->READ）。  

### 18.2 压测
- 单聊高并发压测。  
- 群聊 fan-out 压测。  
- 重连风暴压测。  

### 18.3 故障注入
- 队列延迟注入。  
- 网关节点故障。  
- 存储短时超时。  

### 18.4 回归
- 每次协议升级做兼容性测试（n 与 n-1 客户端）。  

---

## 19. 面试高频追问 + 可直接复述答案
### Q1：怎么保证消息不丢？
- “消息先持久化再 ACK，投递失败靠队列重试和离线补偿。”  

### Q2：怎么保证顺序？
- “按会话分配递增 seq，只承诺会话内顺序。”  

### Q3：为什么会重复消息？
- “我们用至少一次投递保证不丢，所以客户端要按 messageId 去重。”  

### Q4：离线太久怎么补？
- “按 lastSeq 分页补拉，不一次拉全量。”  

### Q5：群聊超大怎么办？
- “分层 fan-out、批量下发、热点会话隔离。”  

---

## 20. 新手学习路线（7 天）
1. 第 1 天：做单聊 send/receive。  
2. 第 2 天：加 WebSocket 连接管理。  
3. 第 3 天：加 messageId、seq、clientMsgId。  
4. 第 4 天：加 ACK 和已读指针。  
5. 第 5 天：加离线队列和重连补拉。  
6. 第 6 天：加监控指标和告警。  
7. 第 7 天：按面试结构讲一遍并复盘。  

---

## 21. 上场前 Checklist
- [ ] 我能讲清消息生命周期 6 步。  
- [ ] 我能讲清顺序、幂等、至少一次投递的关系。  
- [ ] 我能讲清离线补偿和多端同步。  
- [ ] 我能说出 3 个关键指标和阈值。  
- [ ] 我能举 3 个真实故障例子。  

---

## 22. 30 秒总结
- 聊天系统的核心是“可靠投递 + 顺序可解释 + 断线可恢复”。  
- 面试只讲 WebSocket 不够，必须讲消息状态机、幂等、离线补偿和观测闭环。  
- 你按“故事 -> 生命周期 -> 例子 -> 兜底”讲，面试官会很容易认可。  
