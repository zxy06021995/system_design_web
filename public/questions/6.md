# Q6 Query Cache - 搜索引擎查询缓存（超高频）

## 1. 三句话题目本质
1. 这题是“用缓存降低搜索后端压力，并保证结果足够新鲜”。  
2. 难点是缓存命中率、失效策略、热点查询和一致性平衡。  
3. 面试要讲清：什么该缓存、缓存多久、失效如何做、缓存雪崩怎么扛。  

## 2. 一个真实场景故事
你做电商搜索，晚高峰每秒 3 万次查询，ES 集群 CPU 90%+。上线查询缓存后，命中率从 18% 提升到 62%，ES QPS 降了一半。但第二天出现“用户搜 iPhone 价格没更新”投诉。你补了版本化失效 + 热点短 TTL + 主动失效后，既保住了性能，也把陈旧数据投诉降到可控范围。  

## 3. 术语白话表（新手可懂）
1. Query Normalization：把“同义查询”归一成同一缓存键。  
2. Cache Key：缓存键，一般由查询词+过滤条件组成。  
3. TTL：过期时间。  
4. Cache Hit：命中缓存，直接返回。  
5. Cache Miss：未命中，要查后端。  
6. Cache Stampede：大量请求同时击穿缓存。  
7. Hot Key：超热点查询。  
8. Stale Data：过期或旧数据。  
9. Write-through：更新数据时同步更新缓存。  
10. Cache-aside：读未命中再回源并写缓存。  
11. Single Flight：同一键并发回源只放行一个请求。  
12. Negative Cache：缓存“无结果”，防止穿透。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 缓存搜索结果页（列表 + 聚合信息）。  
2. 支持 TTL、主动失效、版本化键。  
3. 支持热点识别和热点保护。  
4. 支持缓存命中率和回源率监控。  
5. 支持“空结果缓存”避免穿透。  

### 4.2 非功能需求
1. 低延迟：命中路径毫秒级返回。  
2. 稳定：回源峰值可控，不打爆搜索后端。  
3. 可控新鲜度：关键查询需更快更新。  
4. 高可用：缓存集群故障时系统可降级。  

### 4.3 不做范围
1. 不做搜索排序模型训练。  
2. 不做索引构建流程。  
3. 不做复杂个性化推荐。  

### 4.4 SLO/SLA
1. 查询整体 P95 < 120ms。  
2. 缓存命中率目标 >= 55%。  
3. 缓存故障时核心搜索可用性 >= 99.9%。  

## 5. 容量估算（数字推导）
假设日搜索请求 8 亿，平均响应体 6KB：  
1. 平均 QPS：8 亿 / 86400 ≈ 9259/s。  
2. 峰值按 4 倍：约 3.7 万/s。  
3. 若命中率 60%，回源 QPS 降到约 1.48 万/s。  
4. 缓存 500 万个键，每键平均 8KB（含元数据）约 40GB。  
5. 热点 Top 1 万键占流量 35%，需单独热键保护。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`Query API -> 归一化 -> Query Cache -> Search Backend -> 回填缓存`

### 6.2 完整版
1. Query Normalizer：词法归一、参数排序、同义词映射。  
2. Cache Gateway：统一读写缓存与降级逻辑。  
3. L1 Local Cache：进程内短 TTL 缓存。  
4. L2 Distributed Cache：Redis/Memcached 集群。  
5. SingleFlight Guard：并发回源合并。  
6. Invalidation Bus：索引更新事件触发主动失效。  
7. Search Backend：ES / OpenSearch 集群。  
8. Metrics & Alert：命中率、回源、陈旧率、热点告警。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `GET /v1/search?q=&filters=&sort=`  
2. `POST /v1/cache/invalidate`（按 query pattern 或 version）  
3. `GET /v1/cache/stats`  

请求示例：
```json
{
  "q": "iphone 15",
  "filters": {"priceMin": 3000, "brand": "apple"},
  "sort": "relevance",
  "page": 1,
  "size": 20
}
```

响应示例：
```json
{
  "items": [{"id":"sku_1","title":"iPhone 15 128G"}],
  "total": 1823,
  "cache": {"hit": true, "ttlLeftSec": 18}
}
```

错误码：`429_CACHE_THROTTLED`、`503_CACHE_CLUSTER_DEGRADED`、`504_SEARCH_BACKEND_TIMEOUT`。  

## 8. 数据模型（实体、索引、分片分区）
1. `cache_entry`：`key`、`payload`、`version`、`expire_at`。  
2. `hot_query_stat`：`query_norm`、`qps_1m`、`last_seen`。  
3. `invalidate_event`：`event_id`、`scope`、`version`、`created_at`。  
4. `negative_cache`：`key`、`reason`、`expire_at`。  
5. 分片：按 `hash(key)` 分片，热点键可复制到专用分片。  
6. 索引：`idx_expire_at` 用于清理任务。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：请求归一化 -> 查 L1/L2 -> 命中返回；未命中回源并写缓存。  
2. 高峰：热点键击穿风险 -> SingleFlight + 过期随机抖动 + 热点预热。  
3. 故障恢复：缓存集群异常 -> 降级只读 L1 + 后端限流 -> 集群恢复后渐进回暖。  

## 10. 一致性与事务边界
1. 搜索缓存一般接受秒级最终一致。  
2. 价格/库存敏感字段可拆分为短 TTL 子缓存。  
3. 主动失效优先版本化键，避免“删不干净”。  
4. 读链路采用 cache-aside，写链路由索引更新事件驱动失效。  

## 11. 可用性与容错
1. L1+L2 两级缓存，L2 挂了仍可保住部分流量。  
2. 熔断：回源超时率 > 20% 持续 3 分钟，触发强降级。  
3. 降级策略：只返回热门结果、关闭高成本聚合。  
4. 防雪崩：TTL 随机抖动 + 分批过期。  
5. RTO 10 分钟，RPO 0（缓存可重建）。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `cache_hit_ratio`  
2. `backend_fallback_qps`  
3. `query_p95_ms`  
4. `hot_key_qps`  
5. `stale_result_ratio`  

告警阈值：  
1. 命中率 < 45%（15分钟）-> P1。  
2. 回源 QPS 超基线 2 倍（10分钟）-> P1。  
3. 查询 P95 > 200ms（10分钟）-> P1。  
4. 热点键 QPS > 5000 且抖动增大 -> P2。  

处置：热点隔离 -> 预热 -> 限流 -> 回源保护 -> 复盘键设计。  

## 13. 安全与合规
1. 缓存键禁止携带明文 PII。  
2. 用户个性化结果要区分租户/用户作用域，防串读。  
3. 缓存管理接口需 RBAC 控制和审计。  
4. 响应体敏感字段做脱敏缓存或不缓存。  
5. 防止缓存投毒：只信任后端签名响应。  

## 14. 成本与取舍
1. TTL 长命中高但新鲜度差；TTL 短新鲜但成本高。  
2. L1 命中快但容量小；L2 容量大但网络开销高。  
3. 全量主动失效准确但成本高，版本化更稳定。  
4. 缓存更多字段可省回源，但内存成本和一致性复杂度上升。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 查询归一化与键生成
```java
public class QueryKeyBuilder {
    public String build(SearchRequest req) {
        String q = req.getQ().trim().toLowerCase();
        Map<String, String> filters = new TreeMap<>(req.getFilters()); // 排序保证稳定
        String raw = q + "|" + filters + "|" + req.getSort() + "|" + req.getPage() + "|" + req.getSize();
        return "qcache:" + Hashing.sha256(raw);
    }
}
```

### 15.2 SingleFlight 防击穿
```java
public class SingleFlightCache {
    private final ConcurrentHashMap<String, CompletableFuture<SearchResponse>> inFlight = new ConcurrentHashMap<>();

    public SearchResponse getOrLoad(String key, Supplier<SearchResponse> loader) {
        CompletableFuture<SearchResponse> future = inFlight.computeIfAbsent(key, k ->
            CompletableFuture.supplyAsync(() -> {
                try { return loader.get(); }
                finally { inFlight.remove(k); }
            })
        );
        return future.join();
    }
}
```

### 15.3 Cache-Aside 读路径
```java
public class QueryCacheService {
    private final CacheClient cache;
    private final SearchBackend backend;

    public SearchResponse query(String key, SearchRequest req) {
        SearchResponse cached = cache.get(key, SearchResponse.class);
        if (cached != null) return cached.withCacheHit(true);
        SearchResponse fresh = backend.search(req);
        cache.set(key, fresh, ttlWithJitter(30));
        return fresh.withCacheHit(false);
    }

    private int ttlWithJitter(int baseSec) {
        return baseSec + ThreadLocalRandom.current().nextInt(0, 15);
    }
}
```

### 15.4 版本化失效
```java
public class VersionedKey {
    public String key(String normKey, long version) {
        return "qcache:v" + version + ":" + normKey;
    }

    public long nextVersion(long current) {
        return current + 1;
    }
}
```

### 15.5 负缓存防穿透
```java
public class NegativeCacheGuard {
    private final CacheClient cache;

    public Optional<SearchResponse> tryGetNegative(String key) {
        String marker = cache.get(key + ":neg", String.class);
        return marker == null ? Optional.empty() : Optional.of(SearchResponse.empty());
    }

    public void markNegative(String key) {
        cache.set(key + ":neg", "1", 10); // 10秒短TTL
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 缓存命中率看板（React + TS）
```tsx
type CacheStats = { hitRatio: number; fallbackQps: number; p95Ms: number };

export function QueryCacheDashboard() {
  const [stats, setStats] = useState<CacheStats | null>(null);
  useEffect(() => {
    fetch("/api/cache/stats").then(r => r.json()).then(setStats);
  }, []);
  if (!stats) return <div>loading...</div>;
  return (
    <div>
      <p>命中率: {(stats.hitRatio * 100).toFixed(2)}%</p>
      <p>回源QPS: {stats.fallbackQps}</p>
      <p>P95延迟: {stats.p95Ms}ms</p>
    </div>
  );
}
```

### 16.2 缓存失效运维页（React + TS）
```tsx
export function InvalidatePanel() {
  const [pattern, setPattern] = useState("iphone");
  async function invalidate() {
    await fetch("/api/cache/invalidate", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({ pattern })
    });
    alert("失效任务已提交");
  }
  return (
    <div>
      <input value={pattern} onChange={e => setPattern(e.target.value)} />
      <button onClick={invalidate}>执行失效</button>
    </div>
  );
}
```

## 17. 测试策略
1. 单测：键归一化、TTL 抖动、负缓存逻辑。  
2. 集成：缓存未命中 -> 回源 -> 回填 -> 再命中。  
3. 压测：热点键冲击下 SingleFlight 是否生效。  
4. 演练：缓存集群整体不可用降级流程。  
5. 回归：索引更新后缓存陈旧窗口验证。  

## 18. 丰富例子（面试可复述）
1. 双十一热点词“iPhone”如何防击穿。  
2. 价格刚改，如何缩短陈旧窗口。  
3. 缓存命中率突然下跌如何定位。  
4. 某键超热点导致单分片过载如何拆分。  
5. 搜索后端超时时如何降级返回。  
6. 空查询被刷，如何用负缓存防穿透。  
7. 同义词扩展上线后为何命中率掉了。  
8. 租户隔离不当导致串读如何避免。  
9. 版本化失效为何比全量删除更稳。  
10. L1 命中很高但结果陈旧如何平衡。  
11. 缓存投毒风险如何控制。  
12. 高峰结束后如何回收预热资源。  

## 19. 面试追问+回答模板
1. 问：缓存和搜索结果一致性怎么保证？  
答：不追求强一致，采用版本化失效 + 短 TTL + 主动失效，控制陈旧窗口。  
2. 问：为什么要两级缓存？  
答：L1 极快但小，L2 容量大；组合可兼顾延迟和成本。  
3. 问：最常见故障是什么？  
答：热点击穿和雪崩，核心手段是 SingleFlight、TTL 抖动和回源限流。  

## 20. 新手学习路线
1. 先学 Cache-Aside 和 TTL。  
2. 再学击穿/穿透/雪崩三类问题。  
3. 学键设计与归一化。  
4. 学版本化失效和热点治理。  
5. 最后练告警阈值和故障演练话术。  

## 21. 上场前Checklist
1. 能讲清缓存键设计。  
2. 能讲清三大缓存故障及应对。  
3. 能给出明确告警阈值。  
4. 能解释新鲜度与命中率的取舍。  
5. 能讲出与缓存母题的边界差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q34 Design Redis`。  

### 22.2 共性能力
1. 都需要缓存读写与淘汰策略。  
2. 都会涉及分片和高可用。  
3. 都需要监控命中率和延迟。  
4. 都要考虑故障降级。  

### 22.3 关键差异
1. Q34 是“通用缓存/内存数据库设计”，Q6 是“搜索查询缓存应用设计”。  
2. Q6 更强调查询归一化和结果新鲜度。  
3. Q6 重点在击穿与回源保护，不展开 Redis 内部实现细节。  
4. Q6 更关注搜索业务口径（陈旧率、回源率）。  
5. Q34 会深入持久化/复制/哨兵，Q6 重点是业务缓存策略。  

### 22.4 本题新增必补知识
1. Query key 归一化。  
2. 搜索场景版本化失效。  
3. 负缓存与防穿透策略。  
4. 热点查询预热机制。  
5. 缓存陈旧窗口治理。  

### 22.5 面试差异话术
1. “Q34 讲 Redis 怎么造，Q6 讲 Redis 在搜索查询里怎么用好。”  
2. “Q6 的第一问题是回源压力和陈旧结果，不是内核数据结构。”  
3. “这题答高分要把命中率、新鲜度、稳定性三者权衡说清楚。”  
