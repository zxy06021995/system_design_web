# Q7 Amazon Sales Ranking - 亚马逊销售排名（高频）

## 1. 三句话题目本质
1. 这题是“高并发销量写入 + 低延迟 TopK 排名查询”的组合题。  
2. 难点在于：实时性、去重、防刷、分类榜单和最终一致。  
3. 面试要讲清：如何保证榜单既快又可信，不被刷单轻易操控。  

## 2. 一个真实场景故事
你做电商“热销榜”，大促时每秒数十万订单事件涌入。早期做法是每单实时更新 DB 排序，结果写入锁冲突严重，榜单延迟到分钟级。重构后改成“流式聚合 + Redis ZSet + 分层刷新”，榜单延迟降到秒级，且通过反作弊权重把刷单商品的异常排名压制住。  

## 3. 术语白话表（新手可懂）
1. TopK：前 K 名榜单。  
2. Ranking Score：排名分值，不一定等于销量。  
3. ZSet：Redis 有序集合，适合排行榜。  
4. Event Time：事件发生时间（下单时间）。  
5. Processing Time：系统处理时间。  
6. Watermark：流处理里判断“迟到数据”的边界。  
7. Late Event：延迟到达的订单事件。  
8. Anti-fraud：反作弊，识别刷单。  
9. Window Aggregation：按时间窗口聚合销量。  
10. Snapshot：榜单快照。  
11. Tie-breaker：同分时的排序规则。  
12. Rebuild：全量重算榜单。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持全站榜、类目榜、地区榜。  
2. 支持实时更新 Top100。  
3. 支持时间维度（日榜、周榜、月榜）。  
4. 支持反作弊权重。  
5. 支持历史榜单回溯查询。  

### 4.2 非功能需求
1. 高吞吐订单事件接入。  
2. 榜单查询低延迟。  
3. 结果可解释（分值构成可追溯）。  
4. 对迟到事件有补偿策略。  

### 4.3 不做范围
1. 不做复杂推荐排序（召回粗排精排）。  
2. 不做库存系统本身。  
3. 不做广告竞价排序。  

### 4.4 SLO/SLA
1. 榜单刷新延迟 P95 < 5s。  
2. 榜单查询 P95 < 50ms。  
3. 统计准确率 >= 99.9%（日终对账口径）。  

## 5. 容量估算（数字推导）
假设日订单 1.5 亿，峰值每秒订单事件 12 万：  
1. 若每单都更新榜单，写压过高，不可直接同步写。  
2. 采用秒级微批聚合后，每秒榜单更新降至约 2 万 key。  
3. 榜单维度：3000 类目 * 3 时间窗 * Top100，约 90 万记录。  
4. 若每条记录 120B，内存约 103MB（不含索引和副本）。  
5. 历史快照按天保留 180 天，需对象存储归档。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`订单事件 -> 流聚合 -> 排名服务 -> Redis ZSet -> 榜单API`

### 6.2 完整版
1. Event Ingest：订单/退款/取消事件统一接入。  
2. Stream Aggregator：按类目和窗口聚合净销量。  
3. Score Engine：加入反作弊权重、退货惩罚、时效权重。  
4. Rank Writer：批量写入 Redis ZSet。  
5. Rank Query API：分页读取榜单、商品详情拼接。  
6. Snapshot Service：周期固化榜单快照。  
7. Reconciliation Job：离线对账重算，修正偏差。  
8. Observability：延迟、准确率、异常波动监控。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `GET /v1/rankings?category=phone&window=DAY&top=100`  
2. `GET /v1/rankings/{category}/history?date=2026-02-24`  
3. `POST /v1/rankings/rebuild`（运维接口）  

响应示例：
```json
{
  "category": "phone",
  "window": "DAY",
  "generatedAt": "2026-02-24T10:30:00Z",
  "items": [
    {"skuId":"sku_1","score":9876.3,"rank":1},
    {"skuId":"sku_2","score":9760.1,"rank":2}
  ]
}
```

错误码：`429_RANKING_QUERY_LIMITED`、`503_RANKING_REBUILDING`、`504_DETAIL_SERVICE_TIMEOUT`。  

## 8. 数据模型（实体、索引、分片分区）
1. `order_event`：`event_id`、`sku_id`、`category_id`、`type`、`qty`、`event_time`。  
2. `rank_score`：`category_id`、`window`、`sku_id`、`score`、`updated_at`。  
3. `rank_snapshot`：`snapshot_id`、`category_id`、`window`、`payload_uri`。  
4. `fraud_signal`：`sku_id`、`risk_level`、`weight_factor`。  
5. `recon_diff`：`category_id`、`window`、`sku_id`、`delta_score`。  
6. 分片：按 `category_id` 分片，热点类目单独扩展。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：订单事件入流 -> 窗口聚合 -> 计算分值 -> 批量写榜 -> 查询返回。  
2. 高峰：秒杀流量激增 -> 微批窗口缩短 + 按类目限速 + 明细异步补齐。  
3. 故障恢复：流任务失败 -> 从 checkpoint 恢复 -> 回放事件 -> 对账修正。  

## 10. 一致性与事务边界
1. 榜单追求近实时，不追求每秒强一致。  
2. 订单主账是事实源，榜单是派生数据。  
3. 迟到事件进入补偿流，更新对应窗口分值。  
4. 日终离线重算可校正实时链路误差。  

## 11. 可用性与容错
1. 双写保护：实时榜 + 最近快照兜底。  
2. 熔断：商品详情服务异常时先返回 sku+score。  
3. 降级：高峰只维护 Top100，不计算长尾。  
4. 防刷：异常订单权重降级，不直接计满分。  
5. RTO 15 分钟，RPO 1 分钟（基于流 checkpoint）。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `rank_refresh_lag_sec`  
2. `rank_query_p95_ms`  
3. `late_event_ratio`  
4. `fraud_adjusted_ratio`  
5. `recon_delta_rate`  

告警阈值：  
1. 刷新延迟 > 8s（10分钟）-> P1。  
2. 查询 P95 > 80ms（10分钟）-> P1。  
3. 迟到事件占比 > 5%（30分钟）-> P2。  
4. 对账偏差 > 0.5%（日终）-> P1。  

处置：扩容流任务 -> 回放补偿 -> 暂时降级榜单维度 -> 对账修复。  

## 13. 安全与合规
1. 榜单计算链路记录可审计（分值来源可追踪）。  
2. 运维重算接口必须 RBAC + 审计。  
3. 防刷规则更新需灰度发布和回滚。  
4. 不在榜单缓存中暴露敏感交易信息。  
5. 跨区榜单遵循数据合规边界。  

## 14. 成本与取舍
1. 实时每单更新最准确但成本极高，微批是更优平衡。  
2. 榜单维度越多，计算和存储成本指数上升。  
3. 反作弊越激进，误伤风险越高，需人工复核兜底。  
4. 全量重算准确但慢，增量流快但有漂移，需双轨结合。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 排名分值计算器
```java
public class RankScoreCalculator {
    public double score(int soldQty, int refundQty, double fraudWeight, long recencyMinutes) {
        int net = Math.max(0, soldQty - refundQty);
        double freshness = 1.0 / (1.0 + recencyMinutes / 60.0);
        return net * fraudWeight * (0.7 + 0.3 * freshness);
    }
}
```

### 15.2 ZSet 批量写入
```java
public class RankingWriter {
    private final JedisPool pool;

    public void batchWrite(String key, Map<String, Double> skuScore) {
        try (Jedis jedis = pool.getResource()) {
            Pipeline p = jedis.pipelined();
            skuScore.forEach((sku, score) -> p.zadd(key, score, sku));
            p.expire(key, 3600);
            p.sync();
        }
    }
}
```

### 15.3 迟到事件补偿
```java
public class LateEventHandler {
    public void handle(OrderEvent event, Instant watermark, Consumer<OrderEvent> compensate) {
        if (event.eventTime().isBefore(watermark.minusSeconds(120))) {
            compensate.accept(event); // 放入补偿流重算窗口
            return;
        }
        // 正常路径由主流处理
    }
}
```

### 15.4 同分 Tie-break 排序
```java
public class TieBreaker {
    public int compare(ProductRank a, ProductRank b) {
        int scoreCmp = Double.compare(b.score(), a.score());
        if (scoreCmp != 0) return scoreCmp;
        int soldCmp = Integer.compare(b.soldQty(), a.soldQty());
        if (soldCmp != 0) return soldCmp;
        return Long.compare(a.skuId(), b.skuId()); // 稳定排序
    }
}
```

### 15.5 日终对账修复
```java
public class RankReconcileService {
    public List<ReconDiff> diff(Map<String, Double> realtime, Map<String, Double> offline) {
        List<ReconDiff> out = new ArrayList<>();
        for (Map.Entry<String, Double> e : offline.entrySet()) {
            double rt = realtime.getOrDefault(e.getKey(), 0.0);
            double delta = e.getValue() - rt;
            if (Math.abs(delta) > 0.01) {
                out.add(new ReconDiff(e.getKey(), delta));
            }
        }
        return out;
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 榜单运营看板（React + TS）
```tsx
type RankingItem = { skuId: string; score: number; rank: number };

export function RankingBoard() {
  const [items, setItems] = useState<RankingItem[]>([]);
  useEffect(() => {
    fetch("/api/rankings?category=phone&window=DAY&top=20")
      .then(r => r.json())
      .then(d => setItems(d.items));
  }, []);
  return (
    <ol>
      {items.map(i => <li key={i.skuId}>#{i.rank} {i.skuId} - {i.score.toFixed(2)}</li>)}
    </ol>
  );
}
```

### 16.2 反作弊调权面板（React + TS）
```tsx
export function FraudWeightPanel() {
  const [skuId, setSkuId] = useState("");
  const [weight, setWeight] = useState(0.6);

  async function submit() {
    await fetch("/api/rankings/fraud-weight", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ skuId, weight })
    });
    alert("权重已更新");
  }

  return (
    <div>
      <input value={skuId} onChange={e => setSkuId(e.target.value)} placeholder="sku id" />
      <input type="number" step="0.1" value={weight} onChange={e => setWeight(Number(e.target.value))} />
      <button onClick={submit}>更新权重</button>
    </div>
  );
}
```

## 17. 测试策略
1. 单测：分值计算、同分排序、迟到事件逻辑。  
2. 集成：事件接入 -> 聚合 -> 榜单写入 -> 查询全链路。  
3. 压测：高峰 12 万 EPS 场景下刷新延迟。  
4. 故障演练：流任务重启、checkpoint 回退、Redis 分片故障。  
5. 对账测试：实时榜与离线重算结果偏差验证。  

## 18. 丰富例子（面试可复述）
1. 同款商品不同店铺如何分别排名。  
2. 退款高发时榜单如何避免虚高。  
3. 迟到订单如何补偿到正确时间窗。  
4. 大促峰值时为何不实时逐单更新。  
5. 热门类目榜比冷门类目榜更慢怎么办。  
6. 分值相同时为什么要稳定排序。  
7. 反作弊误伤正常商品如何回滚。  
8. 榜单 API 超时如何降级。  
9. 历史榜单回看如何存储更省钱。  
10. 指标看起来正常但用户觉得不准怎么排查。  
11. 同步链路中断后如何快速恢复。  
12. 跨区数据延迟导致榜单差异如何解释。  

## 19. 面试追问+回答模板
1. 问：为什么不用数据库直接 `order by sales`？  
答：高并发下写放大和排序开销过高，需流聚合 + 内存排行榜。  
2. 问：实时性和准确性冲突怎么解？  
答：实时链路给秒级结果，离线对账修正偏差，形成双轨闭环。  
3. 问：如何防刷单影响榜单？  
答：分值模型引入风控权重，异常事件降权并保留人工复核通道。  

## 20. 新手学习路线
1. 先掌握 TopK 和 ZSet。  
2. 再学流式聚合和窗口。  
3. 学迟到事件与补偿。  
4. 学反作弊与权重机制。  
5. 学对账与恢复方案。  

## 21. 上场前Checklist
1. 能讲清榜单分值不等于销量。  
2. 能讲清实时链路与离线链路分工。  
3. 能给出明确延迟和准确率阈值。  
4. 能讲出反作弊策略如何落地。  
5. 能讲出与母题在技术重点上的差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q83 E-commerce Website`。  

### 22.2 共性能力
1. 都处理订单事件和商品数据。  
2. 都有高峰流量问题。  
3. 都需要缓存与异步解耦。  
4. 都有反作弊和风控考量。  

### 22.3 关键差异
1. Q83 是全链路电商系统，Q7 是榜单子系统。  
2. Q7 重点是 TopK 排名与实时聚合，不展开库存履约。  
3. Q7 更强调迟到事件与窗口补偿。  
4. Q83 关注交易成功链路，Q7 关注榜单可信和实时。  
5. Q7 的核心指标是刷新延迟和偏差率。  

### 22.4 本题新增必补知识
1. 流式 TopK 聚合。  
2. 排名分值设计与可解释性。  
3. 迟到事件处理。  
4. 反作弊权重接入。  
5. 榜单对账修复闭环。  

### 22.5 面试差异话术
1. “Q7 不是订单系统本体，而是订单事件派生出的排行系统。”  
2. “答 Q7 要重点讲实时聚合、排序稳定性和反作弊，不是支付库存细节。”  
3. “Q83 讲交易闭环，Q7 讲指标与榜单可信闭环。”  
