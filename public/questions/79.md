# Q79 - Design Online Collaborative Spreadsheet

## 1. 题目元信息（来自 questions.ts）
- id: 79
- title: Design Online Collaborative Spreadsheet
- tags: 协同编辑, OT/CRDT, 电子表格, 公式计算, 实时同步
- keyPoints: OT/CRDT算法, 单元格锁定, 公式计算, 版本控制, 实时同步
- learningCoreId: 18

## 2. 需求澄清
- 支持多人同时编辑同一工作簿（sheet + cell）。
- 支持值编辑、公式编辑、格式编辑、插入删除行列。
- 低延迟实时可见，跨端一致。
- 可回放历史版本，支持审计。
- 离线后重连可追平。

## 3. 非功能目标
- 可用性: 99.95% 月度可用。
- 编辑回显P95 < 150ms（同区域）。
- 冲突收敛: 同一操作集最终一致。
- 持久化可靠: 核心操作不丢。
- 安全: 租户隔离、操作审计。

## 4. 核心对象模型
- Workbook(workbookId, ownerId, version)
- Sheet(sheetId, workbookId, rowCount, colCount)
- Cell(sheetId, row, col, value, formula, style, revision)
- Op(opId, actorId, baseVersion, type, payload, ts)
- Snapshot(workbookId, version, blobRef)
- CursorPresence(userId, sheetId, cursorPos, selectionRange, heartbeatTs)

## 5. API 设计
- `POST /v1/workbooks/{id}/ops:batch` 提交操作批。
- `GET /v1/workbooks/{id}/ops?fromVersion=x` 增量拉取。
- `GET /v1/workbooks/{id}/snapshot?version=v` 拉取快照。
- `POST /v1/workbooks/{id}/recalculate` 触发公式重算。
- `GET /v1/workbooks/{id}/presence` 在线协作者状态。

## 6. 实时通道设计
- WebSocket 主通道: op 广播、ack、presence。
- SSE/Long Poll 降级通道: WS不可用时保证可编辑。
- 客户端本地 op-queue，服务端顺序日志。
- 每个 op 带 `opId` 做幂等去重。

## 7. OT 与 CRDT 选型
- 表格结构操作（插删行列）优先 OT，易控制顺序与变换规则。
- 单元格值/样式可用 CRDT LWW-Register + 向量时钟。
- 混合模型: 结构层 OT，单元格内容层 CRDT。
- 冲突策略: 同格同时写入时按逻辑时钟+actor优先级决议，并写审计。

## 8. 公式计算与依赖图
- 维护 DAG: cell -> dependents。
- 增量重算: 拓扑排序，仅算脏节点。
- 循环引用检测: Tarjan SCC，发现环即标记错误态。
- 热点公式分片执行，防止单点阻塞。

## 9. 存储与索引
- Op Log: Kafka/Pulsar 分区按 `workbookId`。
- 热数据: Redis（最近版本、presence、热点单元格）。
- 冷数据: 对象存储（快照）、OLTP（元数据）。
- 索引: `(workbookId, version)`、`(sheetId,row,col)`。

## 10. 一致性与事务边界
- 单工作簿内以“版本递增”作为线性提交边界。
- op 提交采用事务外盒（Outbox）保证“写库+发流”一致。
- 客户端收到 ack(version) 才认为 done。
- 跨工作簿无强一致，按最终一致+补偿。

## 11. 阈值、容量与SLO
- 单工作簿并发编辑阈值: 200 活跃连接，超过触发分片房间。
- 单连接 op 速率阈值: 50 ops/s，超限令牌桶限流。
- 重放阈值: backlog > 20k ops 走“快照+增量”模式。
- 错误预算: 30天内失败请求占比 <= 0.05%。

## 12. 故障恢复路径（含RTO/RPO）
- 机房级故障:
  - 路径: DNS/GSLB 切流 -> 只读保护 1-2 分钟 -> 主从提升 -> 增量追平 -> 恢复写入。
  - RTO: 10 分钟。
  - RPO: 30 秒（跨地域异步复制）。
- 消息队列堆积:
  - 路径: 触发降级（暂停 presence 广播）-> 扩容 consumer -> 快照优先回补 -> 恢复全量广播。
  - RTO: 15 分钟。
  - RPO: 0（op log 持久化）。
- 单分片数据库故障:
  - 路径: 自动故障转移 -> 回放 binlog/oplog -> 校验版本连续性。
  - RTO: 5 分钟。
  - RPO: 5 秒。

## 13. 可靠性机制
- 幂等键: `opId` 全局唯一，服务端去重窗口 24h。
- 重试策略: 指数退避(200ms~5s) + 抖动。
- 熔断降级: 公式重算服务异常时只返回值缓存并标记“待刷新”。
- 死信队列: 连续失败 op 进入人工/自动修复流程。

## 14. 安全与审计
- 文档级 ACL + 行列级策略扩展点。
- 传输 TLS，静态数据加密（KMS）。
- 审计日志: 谁在何时改了哪个单元格（前后值）。
- 防滥用: IP/用户双维限流、异常编辑模式检测。

## 15. Java 关键实现（>=5）
```java
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class OpDedupService {
    private final Map<String, Long> seen = new ConcurrentHashMap<>();
    private final long ttlMs = 24L * 60 * 60 * 1000;

    public boolean firstSeen(String opId, long nowMs) {
        Long old = seen.putIfAbsent(opId, nowMs);
        if (old == null) return true;
        if (nowMs - old > ttlMs) {
            seen.put(opId, nowMs);
            return true;
        }
        return false;
    }
}
```

```java
import java.util.ArrayList;
import java.util.List;

public class OtTransform {
    public List<Op> transformBatch(List<Op> incoming, List<Op> concurrentOps) {
        List<Op> result = new ArrayList<>();
        for (Op op : incoming) {
            Op cur = op;
            for (Op c : concurrentOps) {
                cur = transform(cur, c);
            }
            result.add(cur);
        }
        return result;
    }

    private Op transform(Op a, Op b) {
        if (a.type().equals("INSERT_ROW") && b.type().equals("INSERT_ROW") && a.row() >= b.row()) {
            return a.withRow(a.row() + 1);
        }
        if (a.type().equals("DELETE_ROW") && b.type().equals("INSERT_ROW") && a.row() >= b.row()) {
            return a.withRow(a.row() + 1);
        }
        return a;
    }
}
```

```java
import java.util.*;

public class FormulaEngine {
    public List<String> topoOrder(Map<String, List<String>> graph, Map<String, Integer> indegree) {
        Deque<String> q = new ArrayDeque<>();
        for (Map.Entry<String, Integer> e : indegree.entrySet()) {
            if (e.getValue() == 0) q.add(e.getKey());
        }
        List<String> order = new ArrayList<>();
        while (!q.isEmpty()) {
            String n = q.poll();
            order.add(n);
            for (String next : graph.getOrDefault(n, Collections.emptyList())) {
                indegree.put(next, indegree.get(next) - 1);
                if (indegree.get(next) == 0) q.add(next);
            }
        }
        return order;
    }
}
```

```java
import java.time.Instant;

public class SnapshotPlanner {
    public boolean shouldSnapshot(long opSinceLastSnapshot, Instant lastSnapshotAt, Instant now) {
        boolean byCount = opSinceLastSnapshot >= 5000;
        boolean byTime = lastSnapshotAt.plusSeconds(300).isBefore(now);
        return byCount || byTime;
    }
}
```

```java
import java.util.concurrent.ThreadLocalRandom;

public class RetryPolicy {
    public long nextDelayMs(int attempt) {
        long base = (long) Math.min(5000, 200 * Math.pow(2, Math.max(0, attempt - 1)));
        long jitter = ThreadLocalRandom.current().nextLong(0, 120);
        return base + jitter;
    }
}
```

## 16. React 前端关键实现（>=2）
```javascript
import { useEffect, useRef, useState } from "react";

export function useWorkbookSync(workbookId) {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [done, setDone] = useState(false);
  const [data, setData] = useState(null);
  const timerRef = useRef(null);

  useEffect(() => {
    let stop = false;
    async function load() {
      setLoading(true);
      setError(null);
      try {
        const res = await fetch(`/v1/workbooks/${workbookId}/snapshot?version=latest`);
        if (!res.ok) throw new Error(`snapshot failed: ${res.status}`);
        const json = await res.json();
        if (!stop) {
          setData(json);
          setDone(true);
        }
      } catch (e) {
        if (!stop) setError(String(e));
      } finally {
        if (!stop) setLoading(false);
      }
    }

    load();
    timerRef.current = setInterval(async () => {
      try {
        const res = await fetch(`/v1/workbooks/${workbookId}/ops?fromVersion=latest`);
        if (!res.ok) throw new Error("poll failed");
        const patch = await res.json();
        setData((old) => ({ ...old, ...patch }));
      } catch (e) {
        setError(String(e));
      }
    }, 2000); // 轮询兜底

    return () => {
      stop = true;
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [workbookId]);

  return { loading, error, done, data };
}
```

```jsx
import React, { useState } from "react";

export default function SubmitOpsButton({ workbookId, ops }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [done, setDone] = useState(false);

  async function submitWithRetry() {
    setLoading(true);
    setError(null);
    setDone(false);
    const idemKey = `idem-${Date.now()}-${Math.random().toString(36).slice(2)}`; // 幂等键
    for (let i = 0; i < 3; i += 1) {
      try {
        const res = await fetch(`/v1/workbooks/${workbookId}/ops:batch`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Idempotency-Key": idemKey
          },
          body: JSON.stringify({ ops })
        });
        if (!res.ok) throw new Error(`submit failed: ${res.status}`);
        await res.json();
        setDone(true);
        setLoading(false);
        return;
      } catch (e) {
        if (i === 2) {
          setError(String(e));
          setLoading(false);
          return;
        }
        await new Promise((r) => setTimeout(r, 200 * (2 ** i))); // 重试退避
      }
    }
  }

  if (loading) return <button disabled>提交中...</button>;
  if (error) return <button onClick={submitWithRetry}>失败重试</button>;
  if (done) return <button onClick={submitWithRetry}>已提交</button>;
  return <button onClick={submitWithRetry}>提交编辑</button>;
}
```

## 17. 监控与告警
- 延迟: op 提交P95/P99、重算耗时。
- 质量: 冲突率、重试率、幂等命中率。
- 可靠性: RTO/RPO 实际达成、复制延迟。
- 业务: 活跃协作者数、每文档 ops/s。

## 18. 丰富例子（>=10）
1. 两人同时编辑 A1，后到达操作按时钟被覆盖，并记录审计。
2. 用户甲插入第3行，用户乙编辑原第5行，OT转换后定位到第6行。
3. 大文档打开时先加载快照，再回放 300 条增量 op。
4. WS 断连后自动切到轮询，编辑继续可用。
5. 公式 `=SUM(A1:A1000)` 上游变更后只重算受影响节点。
6. 环形依赖 `A1=B1+1, B1=A1+1` 被检测并标红。
7. 热点表格并发 300 人时拆分 presence 广播频道。
8. 某节点崩溃后由副本接管，5 分钟内恢复写入。
9. 重复提交同一 `opId` 被幂等层拦截，无重复写入。
10. 公式服务异常时返回缓存值并提示“结果可能延迟更新”。
11. 区域网络抖动导致 ack 超时，客户端按退避重试成功。
12. 跨地域切流后，30 秒内完成增量追平，用户几乎无感。

## 19. 测试策略
- 单测: OT转换规则、CRDT合并、公式拓扑排序。
- 集成: 提交->广播->持久化->重放闭环。
- 混沌: 断网、延迟注入、分区脑裂演练。
- 回归: 历史版本回放一致性校验。

## 20. 面试回答框架
- 先定目标: 实时、收敛、可恢复。
- 再讲架构: 通道、日志、快照、重算、审计。
- 然后讲权衡: OT vs CRDT 混合原因。
- 最后讲兜底: 阈值、降级、RTO/RPO 与演练。

## 21. 评分与改进建议
- 功能完整度: 24/25
- 一致性与冲突处理: 24/25
- 高可用与容灾: 24/25
- 工程落地性: 24/25
- 总分：96/100
- 下一步提升: 增加跨工作簿公式引用隔离与沙箱执行。

## 22. 与母题差异
- 母题（learningCoreId=18）强调通用文档协同；本题更强调“电子表格特有的公式依赖与单元格语义”。
- 本题对结构化操作（插删行列）与单元格内容冲突需要分层治理。
- 本题在性能上更依赖增量重算而非全文重算。

新增必补知识：
1. 表格结构变换下的 OT 下标漂移修正。
2. 公式依赖图维护与循环引用检测。
3. 大范围批量编辑的脏节点裁剪策略。
4. 单元格锁定与权限模型（编辑、查看、受保护范围）。
5. 计算服务降级与缓存结果一致性边界。
6. 快照压缩与版本回放窗口设计。
