# Q63：Design Cloud Storage Gateway（面试复述版）

## 1. 三句话题目本质
1. 存储网关是“本地协议入口 + 云端对象存储后端”的桥梁。  
2. 难点在缓存一致性、断网可用和回传同步冲突。  
3. 高分点是分层缓存、幂等上传、冷热数据和恢复演练。  

## 2. 真实场景故事
制造企业本地 NAS 需要无感接入云备份，白天写入密集、夜间同步云端。网络抖动时上传失败会反复重试，导致链路拥塞。  
新方案将上传拆成“分片 + 本地 WAL + 异步回传 MQ”，本地先 ACK，后台重试同步，冲突按版本向量解决。  

## 3. 术语白话表（>=10）
|术语|白话解释|面试可复述|
|---|---|---|
|Gateway|协议网关|屏蔽 SMB/NFS/S3 差异|
|Chunk|分片|大文件切小块上传|
|WAL|写前日志|断电后可恢复|
|Metadata|元数据|路径、版本、权限|
|Sync Cursor|同步游标|记录同步进度|
|Cache Evict|缓存淘汰|热数据留本地|
|Outbox|事务消息表|可靠投递同步事件|
|Conflict|冲突|多端同时改同文件|
|Hot/Cold|冷热分层|热文件 SSD，冷文件云端|
|RPO|恢复点目标|最多丢失多久|
|RTO|恢复时间目标|多久恢复服务|
|DLQ|死信队列|异常同步隔离处理|

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能
- 文件上传下载、目录遍历、权限透传。  
- 本地缓存与云端异步同步。  
- 版本历史、冲突标记、手动合并。  

### 4.2 非功能
- 本地读延迟 P95 < 20ms。  
- 同步可用性 >= 99.9%。  
- 数据最终一致，可审计。  

### 4.3 不做
- 不做全文检索。  
- 不做全球多活强一致。  

### 4.4 SLO
- `upload_ack_p95 < 80ms`  
- `sync_lag_p95 < 120s`  
- `conflict_unresolved < 0.5%`  

## 5. 容量估算（数字推导）
- 1,000 个站点，每站点日写入 200GB，总 200TB/天。  
- 平均文件 8MB，约 2,600 万文件/天。  
- 分片 4MB：约 5,200 万 chunk/天。  
- 元数据每条 300B，日增约 7.8GB（不含索引）。  
- 热缓存保留最近 7 天活跃文件，冷数据云端归档。  

## 6. 架构（简版+完整版）
### 6.1 简版
```text
Client -> Gateway Cache -> Metadata DB -> MQ -> Cloud Object Storage
```
### 6.2 完整版
```text
SMB/NFS/S3 Adapter -> AuthZ -> Chunk Service
                    -> Local WAL + Cache
                    -> Metadata Store
                    -> Outbox -> MQ(sync.event)
                    -> Sync Worker -> Cloud Object Storage
                    -> Conflict Resolver -> Audit/Alert
```

## 7. API设计（请求/响应/错误码/幂等）
### 7.1 初始化分片上传
`POST /api/v1/files/upload/init`
```json
{"path":"/dept/a.txt","size":10485760,"checksum":"sha256:..."}
```
Response:
```json
{"uploadId":"up_88","partSize":4194304}
```

### 7.2 上传分片
`PUT /api/v1/files/upload/{uploadId}/parts/{partNo}`
Headers: `Idempotency-Key: up_88_1`
Response:
```json
{"etag":"etag_1","accepted":true}
```

### 7.3 错误码
- `GW_409_VERSION_CONFLICT`  
- `GW_429_SYNC_THROTTLED`  
- `GW_503_CLOUD_UNAVAILABLE`  

## 8. 数据模型（实体/索引/分片）
- `file_meta(file_id,path,latest_ver,owner,mtime)`  
- `file_ver(file_id,ver,manifest,status)`  
- `chunk_ref(chunk_hash,size,ref_cnt,store_tier)`  
- `sync_task(task_id,file_id,ver,state,retry,next_at)`  
- 索引：`file_meta(path)`、`sync_task(state,next_at)`。  
- 分片：按 `site_id + path_hash`。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：写入本地 WAL 和 metadata，立即 ACK，异步上传云端。  
2. 高峰：同步 worker 按站点限速，热点目录优先。  
3. 故障：云端不可用时任务排队，恢复后按 cursor 续传。  

## 10. 一致性与事务边界
- 本地写：metadata + outbox 同事务。  
- 云端同步最终一致，按版本号幂等提交。  
- 冲突以“目录级锁 + 版本向量”解决。  

## 11. 可用性与容错（含RTO/RPO）
- 网关多实例，cache 与 metadata 主从。  
- RTO 30 分钟（单站点），RPO 5 分钟（依赖 WAL 刷盘）。  
- DLQ 保存失败同步任务，支持按站点回放。  

## 12. 可观测性（指标+阈值+处置动作）
- `sync_lag_sec > 300`：扩 worker，降级低优目录。  
- `upload_error_rate > 1%`：检查磁盘或云端状态。  
- `cache_hit_ratio < 70%`：调大热缓存或调整淘汰策略。  
- `dlq_count > 5000`：暂停发布，执行重传 runbook。  

## 13. 安全与合规
- 传输 TLS，静态数据 AES-256。  
- KMS 管理站点密钥。  
- 审计所有删除、覆盖、权限变更操作。  

## 14. 成本与取舍
- 热缓存提速但贵，按访问频次下沉冷数据。  
- 小文件聚合上传降低对象存储请求成本。  
- CDN 仅用于文档门户静态资源，不参与企业私有文件上传。  

## 15. Java关键代码（>=5段）
```java
public UploadInit init(InitCmd c) {
  tx.begin();
  try { var u = uploadRepo.create(c); outbox.append("UPLOAD_INIT", u.id(), u.toJson()); tx.commit(); return u; }
  catch (Exception e) { tx.rollback(); throw e; }
}
```
```java
public void putPart(String uploadId, int partNo, byte[] data, String idemKey) {
  if (idemRepo.exists(idemKey)) return;
  cacheStore.put(uploadId, partNo, data);
  idemRepo.save(idemKey, "OK");
}
```
```java
public void syncTask(SyncTask t) {
  try { cloud.putObject(t.bucket(), t.key(), t.payload()); taskRepo.done(t.id()); }
  catch (Exception e) { retryOrDlq(t, e.getMessage()); }
}
```
```java
public void retryOrDlq(SyncTask t, String err) {
  if (t.retry() >= 6) { mq.send("sync.dlq", t.id(), err); return; }
  long d = Math.min(120000, (1L << t.retry()) * 1000L);
  taskRepo.scheduleRetry(t.id(), d);
}
```
```java
public void rebuildHotCache(String pathPrefix) {
  List<FileMeta> hot = metaRepo.topAccess(pathPrefix, 10000);
  hot.forEach(f -> cacheWarmup.load(f.fileId()));
}
```

## 16. 前端功能代码（React JS >=2段，仅API协作）
```javascript
import { useState } from "react";
export function UploadPanel() {
  const [state, setState] = useState("idle");
  const start = async (payload) => {
    setState("loading");
    const r = await fetch("/api/v1/files/upload/init", { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload) });
    setState(r.ok ? "done" : "error");
  };
  return null;
}
```
```javascript
import { useEffect, useState } from "react";
export function SyncStatus() {
  const [msg, setMsg] = useState("");
  useEffect(() => {
    let t = null;
    const poll = async () => {
      const r = await fetch("/api/v1/files/sync/status");
      if (!r.ok) setMsg("同步状态暂不可用");
      else {
        const b = await r.json();
        if (b.lagSec > 300) setMsg("高峰中，文件可能延迟同步");
      }
      t = setTimeout(poll, 3000);
    };
    poll(); return () => clearTimeout(t);
  }, []);
  return null;
}
```

## 17. 测试策略
- 单测：分片幂等、版本冲突、重试策略。  
- 集成：本地写入到云端可见。  
- 压测：单站点 5Gbps 上传。  
- 故障：断网、对象存储 5xx、磁盘满。  

## 18. 丰富例子（>=10）
1. 断网 30 分钟后自动续传。  
2. 同文件双端改动冲突标记。  
3. 热门目录缓存命中提升。  
4. 小文件合并上传降成本。  
5. 大文件分片失败重传。  
6. 云端超时触发退避。  
7. DLQ 任务人工回放。  
8. 误删版本快速恢复。  
9. 热点租户限速保护全局。  
10. 月底审计导出。  

## 19. 面试追问+可复述回答
- 问：为什么本地先 ACK？答：保障业务写入体验，云同步异步补齐。  
- 问：如何避免重复上传？答：分片幂等键+chunk hash 去重。  
- 问：冲突怎么处理？答：版本向量检测，默认保留双版本等待合并。  

## 20. 新手学习路线
1. 先学分片上传和元数据模型。  
2. 再学 outbox+MQ 同步。  
3. 最后学冲突与恢复。  

## 21. 上场前Checklist
- [ ] 说清本地写与云同步分离。  
- [ ] 说明冲突检测。  
- [ ] 给阈值和处置。  
- [ ] 解释冷热分层。  
- [ ] 解释 RTO/RPO。  

## 22. 与母题差异（Q31）
- 共性：文件元数据、同步与版本。  
- 差异：本题重点是“企业网关协议转换 + 站点断网容错”。  
- 新增知识：WAL、cursor 同步、站点限速、对象存储成本模型、冲突向量。  
- 话术：母题是端到端网盘，本题是本地存储接云的中间层。  

## 自审评分
- 完整性20/20 易懂性19/20 面试可讲19/20 技术深度19/20 工程落地19/20
总分：96/100（通过）
