# Q27 搜索引擎技术（Crawler + Typeahead）- 面试高分版

## 1. 三句话题目本质
1. 这是“抓取+索引+输入联想”一体化题，核心是离线抓取结果如何快速变成在线可用建议词。  
2. 难点在于两条时效链路：文档索引可见、建议词权重更新都要快且稳定。  
3. 高分回答要讲清：数据流、前缀索引结构、热点治理、故障降级。

## 2. 真实场景故事（问题-方案-结果）
- 问题：热点新闻爆发后，用户输入关键词前缀时拿不到最新建议，补全落后 30 分钟。  
- 方案：把建议词更新从日批改为流式增量；查询日志实时汇总热度，Trie 采用双版本热切换。  
- 结果：建议词新鲜度从 30 分钟降到 5 秒内，Typeahead P95 维持在 45ms。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Crawler Frontier | 待抓取URL队列 | 按优先级决定先抓谁 |
| Politeness | 礼貌抓取 | 限制同站点抓取速率 |
| Inverted Index | 倒排索引 | 关键词到文档列表 |
| Trie | 前缀树 | 快速做输入补全 |
| Suggestion Rank | 建议词排序分数 | 热度+新鲜度共同决定 |
| Debounce | 输入防抖 | 降低接口抖动请求 |
| Incremental Update | 增量更新 | 只更新变化数据 |
| Snapshot Version | 快照版本 | 支持发布和回滚 |
| Fallback | 降级兜底 | 失败时给默认热词 |
| Query Log | 查询日志 | 反映真实用户意图 |
| Synonym | 同义词扩展 | 提升召回覆盖 |
| Rewrite | 查询改写 | 纠错和规范化处理 |

## 4. 需求澄清（功能/非功能/不做/SLO）
### 4.1 功能需求
1. 抓取网页并增量更新索引。  
2. 提供输入联想（Typeahead）建议词。  
3. 支持同义词和拼写纠错。  
4. 支持运营人工干预建议词排序。  
5. 支持全量重建和版本回滚。

### 4.2 非功能需求
1. 联想延迟低（毫秒级）。  
2. 建议词新鲜度高（秒级）。  
3. 热点时系统稳定可降级。  
4. 支持多语言词典扩展。

### 4.3 不做范围
1. 不做广告竞价。  
2. 不做语义问答引擎。  
3. 不做复杂个性化推荐。

### 4.4 SLO
1. Typeahead：P95 < 60ms。  
2. 建议词更新延迟：P95 < 10s。  
3. 服务可用性：>= 99.95%。

## 5. 容量估算（含数字推导）
1. 抓取文档：日增 100M。  
2. 查询日志：峰值 80k/s。  
3. Typeahead QPS：峰值 150k。  
4. 词典规模：50M 词，前缀节点 200M。  
5. 热点前缀 Top1% 占 45% 流量，必须缓存+隔离。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
Crawler -> Indexer -> Suggest Builder -> Trie Service -> Typeahead API
```

### 6.2 完整版
```text
Crawler Cluster -> URL Frontier -> Content Parser -> Index Pipeline
Query Log Stream -> Feature Aggregator -> Suggest Rank Builder
Suggest Version Store (A/B)
Typeahead Gateway -> Trie Nodes + Hot Cache + Synonym Service
Ops: Override Console + Metrics + Rollback Controller
```

## 7. API设计（请求/响应/错误码/幂等）
1. `GET /api/v1/typeahead?q=twit&lang=en&limit=10`  
2. `POST /api/v1/typeahead/override`（运营人工覆盖）  
3. `POST /api/v1/typeahead/version/publish`  
4. `GET /api/v1/search?q=twitter%20search`

错误码：`INVALID_QUERY`、`RATE_LIMITED`、`VERSION_NOT_READY`、`OVERRIDE_CONFLICT`

## 8. 数据模型（实体/索引/分片）
1. `doc(doc_id, url, title, body, lang, updated_at)`  
2. `term_posting(term, doc_id, tf, updated_at)`  
3. `suggest_term(term, score, lang, version)`  
4. `prefix_bucket(prefix, top_terms, version)`  
5. `override_rule(prefix, forced_term, weight, expire_at)`  
6. 分片：`hash(prefix)` 做 Trie 节点分片。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常
抓取更新 -> 索引增量 -> 日志聚合热词 -> 更新建议词 -> 发布新版本。

### 9.2 高峰
热点词突发 -> 热点缓存命中 -> 未命中走Trie -> 超时降级热门词模板。

### 9.3 故障恢复
某 Trie 分片故障 -> 网关熔断该分片 -> 返回降级建议 -> 自动拉起副本后回切。

## 10. 一致性与事务边界
1. 搜索结果和建议词允许短时间不一致。  
2. 建议词发布采用版本原子切换。  
3. Override 规则优先级高于自动分数。  
4. 重试更新需幂等（term + version）。

## 11. 可用性与容错（含RTO/RPO）
1. Trie 多副本部署；Gateway 健康检查。  
2. 热点前缀缓存防抖动。  
3. 超时降级静态热词。  
4. 版本回滚一键切换。  
5. RTO 10min，RPO 5min。

## 12. 可观测性（指标 + 阈值 + 动作）
指标：
- `typeahead_p95_ms`
- `suggest_update_lag_sec`
- `trie_error_rate`
- `hot_prefix_cache_hit_ratio`
- `override_conflict_count`

阈值与动作：
1. `typeahead_p95_ms > 80` 持续 10min -> P1，开启限流并扩大缓存。  
2. `suggest_update_lag_sec > 20` 持续 5min -> P1，扩容构建任务。  
3. `trie_error_rate > 1%` -> P1，分片熔断+副本切换。

## 13. 安全与合规
1. 运营接口 RBAC + 审计。  
2. 敏感词库联动过滤。  
3. 用户日志脱敏与最短保留策略。  
4. 管理操作双人审批（高风险）。

## 14. 成本与取舍
1. 全内存 Trie 延迟低但成本高。  
2. 增量更新实时但系统复杂。  
3. 更频繁发布提高新鲜度但增加运营风险。  
4. 强纠错提升体验但可能误改用户意图。

## 15. Java关键代码（>=5段）
### 15.1 Trie插入
```java
public class TrieService {
    private final Node root = new Node();
    public void insert(String term) {
        Node cur = root;
        for (char c : term.toCharArray()) {
            cur = cur.children.computeIfAbsent(c, k -> new Node());
        }
        cur.end = true;
    }
    static class Node { Map<Character, Node> children = new HashMap<>(); boolean end; }
}
```

### 15.2 前缀检索TopK
```java
public class PrefixQuery {
    public List<String> suggest(String prefix, int k) {
        Node n = find(prefix.toLowerCase(Locale.ROOT));
        if (n == null) return List.of();
        PriorityQueue<TermScore> minHeap = new PriorityQueue<>(Comparator.comparingDouble(TermScore::score));
        Deque<Node> stack = new ArrayDeque<>();
        stack.push(n);
        while (!stack.isEmpty()) {
            Node cur = stack.pop();
            if (cur.end && cur.term != null) {
                minHeap.offer(new TermScore(cur.term, cur.score));
                if (minHeap.size() > k) minHeap.poll();
            }
            for (Node child : cur.children.values()) stack.push(child);
        }
        List<TermScore> arr = new ArrayList<>(minHeap);
        arr.sort((a, b) -> Double.compare(b.score(), a.score()));
        return arr.stream().map(TermScore::term).toList();
    }
    private Node find(String p) {
        Node cur = root;
        for (char c : p.toCharArray()) {
            cur = cur.children.get(c);
            if (cur == null) return null;
        }
        return cur;
    }
    private final Node root = new Node();
    static class Node {
        Map<Character, Node> children = new HashMap<>();
        boolean end;
        String term;
        double score;
    }
    record TermScore(String term, double score) {}
}
```

### 15.3 热度分数计算
```java
public class SuggestScorer {
    public double score(long freq, long ageSec, double ctr) {
        double hot = Math.log1p(Math.max(freq, 0));
        double fresh = 1.0 / (1.0 + ageSec / 3600.0);
        return hot * 0.6 + fresh * 0.2 + ctr * 0.2;
    }
}
```

### 15.4 版本化发布
```java
public class SuggestVersionManager {
    public void publish(String version) {
        if (!qualityGate.pass(version)) throw new IllegalStateException("quality fail");
        versionRepo.atomicSwitch(version);
    }
}
```

### 15.5 Override合并
```java
public class OverrideMerger {
    public List<String> merge(List<String> auto, List<String> forced) {
        LinkedHashSet<String> merged = new LinkedHashSet<>();
        merged.addAll(forced);
        merged.addAll(auto);
        return new ArrayList<>(merged);
    }
}
```

## 16. 前端功能代码（React JS >=2段）
### 16.1 输入联想 API 协作模块（防抖 + 错误处理）
```javascript
export async function fetchTypeahead(q, limit = 10) {
  const state = { loading: true, items: [], error: "" };
  try {
    const resp = await fetch(`/api/v1/typeahead?q=${encodeURIComponent(q)}&limit=${limit}`);
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    state.items = data.items || [];
  } catch (e) {
    state.error = `联想失败: ${String(e.message || e)}`;
  } finally {
    state.loading = false;
  }
  return state;
}

export function debounceTypeahead(waitMs = 200) {
  let timer = null;
  return (q, cb) => {
    clearTimeout(timer);
    timer = setTimeout(async () => cb(await fetchTypeahead(q)), waitMs);
  };
}
```

### 16.2 运营覆盖 API 协作模块（幂等 + 重试）
```javascript
export async function submitOverride({ prefix, term, weight = 100 }, retry = 0) {
  try {
    const resp = await fetch("/api/v1/typeahead/override", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Idempotency-Key": `ov-${prefix}-${Date.now()}`
      },
      body: JSON.stringify({ prefix, term, weight })
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, status: "SAVED", error: "" };
  } catch (e) {
    if (retry < 2) return submitOverride({ prefix, term, weight }, retry + 1);
    return { ok: false, status: "FAILED", error: `保存失败: ${String(e.message || e)}` };
  }
}
```

## 17. 测试策略
1. Trie 单测（插入、查询、边界前缀）。  
2. 集成测试（抓取更新->建议词可见）。  
3. 压测（输入抖动、热点前缀）。  
4. 故障演练（分片故障、发布回滚）。  
5. 质量测试（建议词点击率、无结果率）。

## 18. 丰富例子（>=10）
1. 热点新闻词 5 秒进入联想列表。  
2. 新词不出现：检查日志聚合延迟。  
3. 拼写错误词被纠错到热门词。  
4. 多语言混输触发错误分词。  
5. 某 prefix 分片过热导致超时。  
6. override 规则冲突导致排序异常。  
7. 版本发布后点击率下降如何回滚。  
8. 缓存命中率骤降如何排查。  
9. 敏感词误放出如何止血。  
10. 日志延迟导致新鲜度下降。  
11. 高峰期间如何限流保护核心功能。  
12. 前缀歧义（apple公司/水果）如何处理。

## 19. 面试追问 + 可复述回答
1. Crawler 和 Typeahead 为什么要分层？  
可复述：抓取是重吞吐离线链路，Typeahead 是低延迟在线链路，分层才能同时优化。  

2. 如何保证建议词实时？  
可复述：用查询日志流式聚合更新分数，版本化热切换，避免全量重建阻塞。  

3. 热点流量怎么扛？  
可复述：前缀缓存+防抖+网关限流+超时降级，优先保证可用。

## 20. 新手学习路线
1. 先理解 Trie 和倒排索引。  
2. 再学建议词打分。  
3. 再学增量更新和发布回滚。  
4. 最后学观测、告警和应急流程。

## 21. 上场前Checklist
- [ ] 能讲清 crawler 数据如何进入 typeahead。  
- [ ] 能说清 Trie 结构和热点优化。  
- [ ] 能给出3个告警阈值。  
- [ ] 能解释版本化发布/回滚。  
- [ ] 能讲和 Q32 的差异。

## 22. 与母题差异（对应 Q32）
### 22.1 对应母题
- Q32 Design Google Search Engine

### 22.2 共性能力
1. 抓取与索引更新。  
2. 查询链路性能优化。  
3. 版本化发布和回滚。  
4. 搜索质量评估。

### 22.3 关键差异（>=5条）
1. Q27 重点是输入联想子系统，Q32 是全搜索平台。  
2. Q27 更强调前缀结构和低延迟返回。  
3. Q27 更依赖查询日志实时热度。  
4. Q32 更强调网页抓取规模与排序全景。  
5. Q27 的运营 override 能力更核心。

### 22.4 本题新增必补知识（>=5条）
1. Trie/DAWG 前缀结构。  
2. 热词实时打分。  
3. 输入防抖与前端体验。  
4. 建议词版本切换。  
5. override 审计与回滚。

### 22.5 面试差异话术（3条）
1. “Q27 我会把 typeahead 当独立高QPS系统讲，不只是一句‘用Trie’。”  
2. “Q32 讲全链路，Q27 讲低延迟联想和新鲜度。”  
3. “Q27 的高分点是日志到建议词的秒级闭环。”
