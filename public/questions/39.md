# Q39 Distributed Session (分布式会话)

> 来源校验（questions.ts）  
> `title`: Distributed Session (分布式会话)  
> `tags`: Session共享, 无状态服务, 会话存储, 登录态, 安全  
> `keyPoints`: Session集中存储, 会话续期, 跨域登录态, 并发登录控制, 安全加固  
> `learningCoreId`: 13（母题：Design Distributed Counter）

## 1. 三句话题目本质
1. 这题本质是“多实例无状态服务下，如何可靠管理登录态”。
2. 难点不在登录接口本身，而在会话续期、撤销传播、并发设备控制和安全风险。
3. 高分回答要覆盖：会话状态模型、存储架构、一致性边界、失效策略、故障降级。

## 2. 一个真实场景故事
某内容平台把单体迁到 Kubernetes 后，用户频繁“刚登录就掉线”。原因是旧方案把 session 放本机内存，流量切到新实例就找不到会话。改成 Redis Cluster 集中存储 + 网关会话中间件后，问题缓解；但又出现“用户改密后旧设备仍可访问 20 秒”。最终通过撤销事件广播 + 黑名单短缓存 + 会话版本校验，把安全窗口从 20 秒压到 2 秒内。

## 3. 术语白话表（>=10）
1. Session ID：会话唯一标识。
2. Access Session：当前请求携带的短期登录态。
3. Sliding Expiration：每次活跃访问会延长过期时间。
4. Absolute Expiration：无论活跃与否，固定最大生存时长。
5. Session Store：集中会话存储（通常 Redis）。
6. Session Revocation：主动失效（踢下线、改密下线）。
7. Concurrent Session Limit：同账号最大在线设备数。
8. Device Fingerprint：设备指纹，用于风控与并发控制。
9. Session Fixation：会话固定攻击。
10. Rotation：会话轮换（定期更换 sid）。
11. Risk-based Auth：高风险请求触发二次验证。
12. Revocation Lag：撤销生效传播延迟。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 登录创建会话，网关可快速校验。
2. 会话支持滑动续期和绝对过期。
3. 支持主动下线单设备/全设备。
4. 支持同账号并发设备限制。
5. 支持跨实例共享和审计追踪。

### 4.2 非功能需求
1. 会话校验低延迟（P95 <= 20ms）。
2. 高可用（>= 99.95%）。
3. 安全可控（可快速撤销、可风控拦截）。
4. 支持水平扩容和跨可用区部署。

### 4.3 不做范围
1. 不设计 OAuth2/OIDC 全协议细节。
2. 不做权限模型（RBAC/ABAC）完整体系。
3. 不做账号注册/找回密码流程。

### 4.4 SLO
1. `session_validate_p95_ms <= 20`。
2. `session_revoke_effective_p95 <= 2s`。
3. `session_store_availability >= 99.95%`。

## 5. 容量估算（数字推导）
1. 日活 1200 万，峰值并发在线会话 450 万。
2. 单会话记录约 1.2KB（用户、设备、过期、风控标签）。
3. 原始存储约 `450万 * 1.2KB ≈ 5.4GB`。
4. 按 Redis 元数据+副本系数 2.8 估算：`5.4 * 2.8 ≈ 15.1GB`。
5. 峰值校验 18 万 QPS，续期写入约 2.5 万 QPS。
6. 若续期每请求都写，会产生写放大；需“最短续期间隔”（如 5 分钟）控制写流量。

## 6. 架构（简版+完整版）
### 6.1 简版
`Gateway -> Session Middleware -> Redis Session Store`

### 6.2 完整版
1. Auth Service：登录成功后签发 `sid`。
2. Session Middleware：网关层校验 sid、设备、版本。
3. Session Store（Redis Cluster）：主存会话状态。
4. Revocation Bus（Kafka）：广播撤销事件。
5. Local Revocation Cache：网关本地黑名单短缓存。
6. Risk Service：异常 IP/设备触发加强校验。
7. Audit Service：记录会话创建/续期/撤销轨迹。
8. Session Admin API：运营执行“踢人/全端下线”。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 创建会话
`POST /api/session/v1/create`

请求：
```json
{
  "userId": 1001,
  "deviceId": "ios-abc",
  "ip": "1.2.3.4",
  "requestId": "login-20260224-001"
}
```

响应：
```json
{
  "sid": "s_8f8aa1...",
  "expiresInSec": 3600,
  "absoluteExpireAt": "2026-02-25T10:00:00Z"
}
```

### 7.2 校验会话
`GET /api/session/v1/validate?sid=...`

错误码：
1. `401_SESSION_NOT_FOUND`
2. `401_SESSION_EXPIRED`
3. `401_SESSION_REVOKED`
4. `429_RISK_CHALLENGE_REQUIRED`

### 7.3 续期会话（幂等）
`POST /api/session/v1/refresh`

幂等规则：
1. 通过 `refreshId` 去重，10 分钟内重复续期返回同结果。
2. 续期间隔未达阈值（如 300 秒）直接返回原过期时间，避免写放大。

### 7.4 撤销会话
`POST /api/session/v1/revoke`

请求：
```json
{
  "sid": "s_8f8aa1...",
  "reason": "PASSWORD_CHANGED",
  "operator": "system"
}
```

## 8. 数据模型（实体/索引/分片）
1. `session_record`：`sid, user_id, device_id, state, version, expire_at, abs_expire_at, ip_hash`。
2. `user_session_index`：`user_id -> [sid...]`（并发控制用）。
3. `session_idempotency`：`refresh_id, sid, result_expire_at, expire_at`。
4. `revoke_event`：`event_id, sid, reason, ts`。
5. `session_audit`：`actor, action, sid, user_id, ts`。

分片与索引：
1. 主分片键：`sid`，保证校验读均匀。
2. 二级索引：`user_id` 用于“全端下线”和并发数统计。
3. 撤销事件按 `event_id` 顺序消费，幂等处理。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 登录成功创建 `sid`，写入 `session_record`。
2. 网关收到请求先校验本地撤销缓存，再查 Session Store。
3. 校验通过后，按续期间隔策略决定是否刷新 TTL。

### 9.2 高峰流程
1. 校验流量激增时，本地缓存热门 `sid` 短期命中。
2. 续期采用节流写策略，防止 store 写入暴涨。
3. 并发设备达到上限时，按策略踢最旧会话。

### 9.3 故障恢复流程
1. Session Store 分片故障时，网关触发熔断与短时降级。
2. 对低风险请求允许“最近一次校验结果短暂信任”。
3. 分片恢复后清理降级状态并强制刷新关键会话。

## 10. 一致性与事务边界
1. 会话一致性为最终一致；安全撤销路径要求“近实时一致”。
2. 创建会话与审计日志分事务，审计失败不影响登录成功。
3. 撤销操作以 store 状态更新为准，广播失败走重试补偿。
4. 并发登录限制以 `user_session_index` 最终收敛，允许毫秒级竞态窗口。
5. 关键操作（改密）必须触发“全端撤销 + 黑名单即时生效”。

## 11. 可用性与容错（含 RTO/RPO）
1. Session Store 多副本，支持自动故障转移。
2. 网关侧降级策略：只读缓存 + 风险分级放行。
3. 撤销广播失败进入重试队列和 DLQ。
4. RTO：核心校验能力 10 分钟内恢复。
5. RPO：会话数据允许秒级损失（可重新登录恢复），安全事件审计不允许丢。

## 12. 可观测性（指标+阈值+处置动作）
1. `session_validate_p95_ms` > 20ms（5 分钟）：扩容网关缓存与排查慢分片。
2. `session_store_timeout_rate` > 1%（3 分钟）：触发熔断并降低续期写入。
3. `session_refresh_qps` > 基线 2 倍（5 分钟）：启用续期节流策略。
4. `revoke_propagation_p95_ms` > 2000ms：检查消息积压并启动补发任务。
5. `concurrent_kick_count` 激增 > 3 倍：排查异常登录与共享账号。
6. `risk_challenge_rate` > 5%：检查风控规则误杀并灰度回滚。

## 13. 安全与合规
1. Cookie 设置 `HttpOnly + Secure + SameSite=Lax/Strict`。
2. 登录成功后强制 `sid` 轮换，防会话固定攻击。
3. `sid` 采用高熵随机值，禁止可预测序列。
4. 会话绑定设备指纹与风险评分，异常行为触发二次验证。
5. 审计日志保留关键字段并做脱敏存储，满足合规追溯。

## 14. 成本与取舍
1. 更短 TTL 安全性更高，但用户体验差、续期写压力大。
2. 更强撤销一致性（同步广播）安全更强，但延迟成本更高。
3. 本地缓存可降低延迟，但会扩大实例间短暂不一致窗口。
4. 结论：核心操作走强安全路径，普通流量走成本优先路径。

## 15. Java 关键代码（>=5段）
### 15.1 会话状态转移（创建）
```java
public Session createSession(long userId, String deviceId, String ip) {
    String sid = sidGenerator.newSid();
    Instant now = Instant.now();
    Session s = new Session(sid, userId, deviceId, "ACTIVE", 1L,
            now.plusSeconds(3600), now.plusSeconds(86400), hashIp(ip));
    sessionRepo.save(sid, s, 3600);
    userIndexRepo.add(userId, sid);
    return s;
}
```

### 15.2 幂等续期/去重
```java
public RefreshResult refresh(String sid, String refreshId) {
    String idemKey = "refresh:" + sid + ":" + refreshId;
    if (idemRepo.exists(idemKey)) {
        return idemRepo.getResult(idemKey);
    }
    Session s = sessionRepo.get(sid);
    if (s == null || !"ACTIVE".equals(s.state())) return RefreshResult.invalid();
    if (Duration.between(s.lastRefreshAt(), Instant.now()).toSeconds() < 300) {
        return RefreshResult.skipped(s.expireAt());
    }
    Instant next = Instant.now().plusSeconds(3600);
    sessionRepo.updateExpireAt(sid, next);
    RefreshResult r = RefreshResult.ok(next);
    idemRepo.save(idemKey, r, 600);
    return r;
}
```

### 15.3 重试退避/失败处理
```java
public void publishRevokeWithRetry(RevokeEvent event) {
    long backoff = 50;
    for (int i = 0; i < 4; i++) {
        try {
            revokeBus.publish(event);
            return;
        } catch (RuntimeException ex) {
            if (i == 3) {
                dlqRepo.save(event.sid(), ex.getMessage());
                throw ex;
            }
            sleep(backoff);
            backoff = Math.min(backoff * 2, 400);
        }
    }
}
```

### 15.4 一致性边界（改密触发全端下线）
```java
@Transactional
public void revokeAllByUser(long userId, String reason) {
    List<String> sids = userIndexRepo.listByUser(userId);
    for (String sid : sids) {
        sessionRepo.markRevoked(sid, reason); // 本地事务边界：状态先落库
    }
    for (String sid : sids) {
        publishRevokeWithRetry(new RevokeEvent(sid, reason)); // 异步传播
    }
}
```

### 15.5 观测触发与降级判定
```java
public void guardValidatePath() {
    double timeoutRate = metrics.gauge("session_store_timeout_rate").value();
    if (timeoutRate > 0.01) {
        degradeSwitch.enable("session_validate_soft_mode");
        alerting.fire("SESSION_STORE_TIMEOUT_HIGH", "rate=" + timeoutRate);
    }
    long lag = metrics.timer("revoke_propagation_p95_ms").value();
    if (lag > 2000) {
        replayService.triggerRevokeReplay();
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 会话校验 Hook（loading/error/done + 轮询）
```javascript
import { useEffect, useState } from "react";

export function useSessionValidate(sid) {
  const [state, setState] = useState({ phase: "idle", valid: false, error: "" });

  useEffect(() => {
    let timer;
    let cancelled = false;

    const tick = async () => {
      setState((s) => ({ ...s, phase: "loading" }));
      try {
        const res = await fetch(`/api/session/v1/validate?sid=${encodeURIComponent(sid)}`);
        if (!res.ok) throw new Error(`HTTP_${res.status}`);
        const data = await res.json();
        if (!cancelled) setState({ phase: "done", valid: !!data.valid, error: "" });
      } catch (e) {
        if (!cancelled) setState({ phase: "error", valid: false, error: String(e.message || e) });
      }
      timer = setTimeout(tick, 15000);
    };

    if (sid) tick();
    return () => {
      cancelled = true;
      clearTimeout(timer);
    };
  }, [sid]);

  return state;
}
```

### 16.2 撤销会话 API（幂等键 + 失败重试）
```javascript
export async function revokeSession(sid, reason) {
  const requestId = `revoke-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 120;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch("/api/session/v1/revoke", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Idempotency-Key": requestId },
        body: JSON.stringify({ sid, reason, operator: "user_action" })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 800);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：会话创建、续期节流、过期与撤销状态机。
2. 集成测试：多实例校验一致性、改密全端下线收敛。
3. 压测：18 万 QPS 校验 + 2.5 万 QPS 续期混合流量。
4. 故障测试：Redis 分片故障、撤销消息积压、风控误杀注入。
5. 安全测试：会话固定、重放攻击、盗用 sid 场景。

## 18. 丰富例子（>=10）
1. 用户切换实例后会话仍可校验成功。
2. 改密后旧设备 2 秒内被强制下线。
3. 活跃用户每 5 分钟最多续期一次，写压力下降。
4. 单账号登录超 3 台设备时自动踢最旧会话。
5. 某分片故障时低风险请求短暂放行，高风险强制挑战。
6. 撤销事件积压触发补发，最终黑名单收敛。
7. 某地区 IP 异常，风控拦截率升高并自动告警。
8. 用户主动“退出全部设备”触发批量撤销。
9. 会话轮换后旧 sid 立即失效，防固定攻击。
10. 审计查询可追溯“谁在何时踢掉了哪个会话”。
11. 边缘网络波动导致校验超时，熔断后恢复。
12. 运营误操作撤销某批会话，可按审计记录回滚。

## 19. 面试追问 + 可复述回答
1. 为什么不用 sticky session？
回答：粘滞会话会降低弹性扩缩与故障切换能力，不适合云原生多实例环境。
2. 续期每次都写是不是最稳？
回答：安全上可行但写放大会明显，实际用“最短续期间隔 + 绝对过期”平衡。
3. 改密后如何快速失效全端？
回答：先落库标记撤销，再广播事件，网关本地黑名单先兜底，保证秒级生效。
4. 怎么避免会话被盗用长期有效？
回答：会话轮换、设备绑定、风险触发二次验证、异常地理位置拦截。
5. Q39 和常规用户系统题差别？
回答：Q39聚焦会话基础设施和一致性细节，不展开账户和权限全链路。

## 20. 新手学习路线
1. 先理解 Cookie/Session/JWT 差异和适用场景。
2. 再实现集中会话存储与网关校验中间件。
3. 补上续期策略、并发设备控制、撤销广播。
4. 增加风控与安全测试。
5. 最后做压测和故障演练，形成可复述案例。

## 21. 上场前 Checklist
1. 能解释会话状态机（ACTIVE/REVOKED/EXPIRED）。
2. 能量化续期写放大与优化手段。
3. 能给出撤销传播阈值和恢复动作。
4. 能说明并发设备限制策略与副作用。
5. 能讲清安全防护（固定攻击、盗用、重放）。
6. 能区分 Q39 与母题 Q13 的关注层级。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q13 Design Distributed Counter。

### 22.2 共性能力
1. 都强调高并发下状态读写与分片扩展。
2. 都需要幂等处理和一致性边界定义。
3. 都依赖可观测阈值和故障恢复机制。

### 22.3 关键差异
1. Q13 关注“计数正确与吞吐”，Q39 关注“登录态安全与生命周期”。
2. Q13 核心对象是数值累加；Q39 核心对象是会话状态机。
3. Q13 多为最终一致计数；Q39 某些安全操作要求秒级强生效。
4. Q13 热点治理偏写扩散；Q39 治理重点是校验延迟和撤销传播。
5. Q39 需要设备/风险维度，Q13 通常不涉及。

### 22.4 本题新增知识点（>=5）
1. Sliding + Absolute 双过期策略。
2. 会话撤销事件传播与黑名单兜底。
3. 并发设备上限与踢人策略。
4. 会话轮换与固定攻击防护。
5. 风险分级下的会话校验降级机制。
6. 会话审计与合规追溯。

### 22.5 面试差异话术
“母题 Q13 是分布式状态累加基础能力；Q39 在这个基础上增加了会话状态机、安全撤销、设备并发和风险控制，是身份会话基础设施题。”

---

## 单题自审（Q39）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 协作代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障三流程完整：通过。

### C. 专属性检查
1. 明确聚焦会话共享与安全，不是泛用户系统：通过。
2. 场景细节覆盖续期/撤销/并发登录：通过。

### D. 工程落地检查
1. 含阈值+动作绑定：通过。
2. 含 RTO/RPO 与降级策略：通过。

### E. 代码相关性检查
1. Java 覆盖状态转移、幂等、重试、一致性、观测触发：通过。
2. 前端覆盖 API 调用、成功失败、状态流转、重试/幂等：通过。

### F. 母题差异检查
1. 与 Q13 的共性/差异/新增知识/话术明确：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过）
