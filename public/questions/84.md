# Q84：Design Online Payment System（在线支付系统）- 95分面试版

## 1. 三句话题目本质
1. 支付系统第一目标不是快，而是“钱不能错、账要对、状态可追溯”。  
2. 真正难点是跨系统不可靠通信下，如何做到“尽量一次成功，失败可补偿，最终可对账收敛”。  
3. 面试高分关键：支付状态机、幂等、防重扣、双记账、清结算、对账修复闭环。  

## 2. 一个真实场景故事
用户在电商下单，支付时遇到网络抖动：
- 用户页面显示“支付失败”，于是又点了一次支付。
- 其实第一次支付已经在通道侧成功扣款。
- 你的系统如果没处理好幂等，就可能重复扣款，形成客诉。

第二天对账时又发现：
- 渠道账单显示成功 10000 笔。
- 本地支付单只有 9998 笔成功。

业务会问：
1. 两笔去哪了？
2. 用户的钱和商家的账怎么保证不乱？
3. 如果系统有错，多久能自动修复？

这就是支付系统设计题必须回答的问题。

## 3. 术语白话表（至少 10 项）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Payment Intent | 支付意图单 | “先创建支付任务，再执行支付动作” |
| Auth | 预授权 | “先冻结额度，不立即扣款” |
| Capture | 扣款确认 | “把预授权转成真正扣款” |
| Void | 撤销预授权 | “扣款前把冻结取消” |
| Idempotency Key | 幂等键 | “重复请求只生效一次” |
| Callback/Webhook | 回调通知 | “支付渠道异步通知最终结果” |
| Ledger | 账本 | “资金变动流水系统” |
| Double-entry | 双记账 | “每笔资金同时有借方和贷方” |
| Clearing | 清分 | “把交易按机构/商户/费率拆分” |
| Settlement | 结算 | “按周期把钱打给商户” |
| Reconciliation | 对账 | “本地账和渠道账逐笔核对” |
| Chargeback | 拒付 | “持卡人争议，银行撤回资金” |
| Pending | 待确认状态 | “暂时不知道成功失败，后续查询/回调收敛” |
| PCI-DSS | 支付安全规范 | “卡数据处理必须遵守的安全标准” |
| AML/KYC | 反洗钱/实名审查 | “高风险交易合规审查” |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 创建支付单（支付意图）、发起支付、查询支付状态。
- 支持多支付方式（银行卡、钱包、网关聚合）。
- 支持退款（全额/部分）、撤销、拒付处理。
- 支持清分、结算、对账和补偿修复。
- 支持商户通知（支付结果回调）和失败重推。

### 4.2 非功能需求（SLO 示例）
- 支付下单接口：`P95 <= 200ms`。
- 支付结果收敛时延：`P95 <= 60s`（回调或轮询确认）。
- 资金账务准确率：`100%`（不可妥协）。
- 可用性：`>= 99.99%`（核心支付链路）。
- 对账差错修复时效：`T+1 前收敛`。

### 4.3 Out of Scope（首版不做）
- 不自建银行卡清算网络（依赖外部渠道）。
- 不做跨境税务与多币种复杂合规细节。
- 不做复杂信贷/分期产品。

## 5. 容量估算（含数字推导）
### 5.1 假设
- 日支付请求：`1.8B`
- 峰值支付 QPS：`80,000`
- 回调放大倍数：`2.5x`（重试机制）
- 日退款请求：`20M`

### 5.2 吞吐估算
- 平均 QPS：`1.8B / 86400 ≈ 20,833`
- 峰值 QPS：`80,000`
- 回调峰值 QPS：`200,000`（含重试）

### 5.3 存储估算
- 支付订单按 1KB/条：`~1.8TB/day`
- 账本分录按双记账至少 2 条/支付：`>= 3.6B entries/day`
- 审计与对账明细长期保存，需冷热分层。

### 5.4 关键结论
- 回调处理能力要按“主流量 + 重试放大”设计。
- 账本是核心资产，需独立高可靠存储和审计。
- 对账必须批处理 + 自动修复，不可全靠人工。

## 6. 架构（简版 + 完整版）
### 6.1 简版架构
```text
Merchant -> Payment API -> Risk -> Channel Router -> Channel Adapter
                          -> Payment State Machine -> Ledger
                          -> Reconciliation -> Clearing/Settlement
```

### 6.2 完整版架构
```text
[Merchant/App]
  -> [Payment Gateway]
  -> [AuthN/AuthZ + Idempotency]
  -> [Risk Engine]
  -> [Payment Orchestrator]
      -> [Channel Router]
      -> [Channel Adapter A/B/C]
      -> [Callback Receiver]
      -> [Status Poller]
  -> [Payment State Store]
  -> [Outbox Event Bus]
      -> [Ledger Service]
      -> [Merchant Notify Service]
      -> [Reconciliation Service]
      -> [Clearing Service]
      -> [Settlement Service]
  -> [Audit & Compliance Service]
  -> [Observability + Alert]
```

### 6.3 组件职责
- Payment Orchestrator：状态机核心，统一编排支付流程。
- Ledger Service：双记账，保证借贷平衡。
- Reconciliation：对账发现差异并触发补偿。
- Merchant Notify：把最终状态可靠通知业务方。

## 7. API 设计（含请求/响应样例）
### 7.1 创建支付意图单
`POST /api/v1/payments/intents`

Request:
```json
{
  "merchantId": 9001,
  "bizOrderId": "O202602240001",
  "amount": 19900,
  "currency": "CNY",
  "payMethod": "CARD",
  "idempotencyKey": "pay_9001_req_abc"
}
```

Response:
```json
{
  "paymentId": "P202602240001",
  "status": "CREATED",
  "clientAction": "REDIRECT",
  "redirectUrl": "https://pay.example.com/checkout/P202602240001"
}
```

### 7.2 查询支付状态
`GET /api/v1/payments/{paymentId}`

Response:
```json
{
  "paymentId": "P202602240001",
  "status": "PENDING",
  "channel": "BANK_A",
  "updatedAt": "2026-02-24T10:22:33Z"
}
```

### 7.3 发起退款
`POST /api/v1/payments/{paymentId}/refunds`

Request:
```json
{
  "refundAmount": 9900,
  "reason": "USER_CANCEL",
  "idempotencyKey": "refund_abc_1"
}
```

### 7.4 渠道回调（内部）
`POST /internal/v1/channels/callback`

Request:
```json
{
  "channel": "BANK_A",
  "channelTxnId": "txn_778899",
  "paymentId": "P202602240001",
  "status": "SUCCESS",
  "amount": 19900,
  "signature": "xxxx"
}
```

### 7.5 错误码语义
- `409_IDEMPOTENCY_CONFLICT`：同幂等键参数不一致。
- `422_INVALID_STATE_TRANSITION`：非法状态迁移。
- `503_CHANNEL_TIMEOUT`：通道超时，进入 PENDING。
- `424_RISK_REJECTED`：风控拒绝。

## 8. 数据模型（核心表/索引）
### 8.1 支付订单表
```sql
CREATE TABLE payment_order (
  payment_id VARCHAR(64) PRIMARY KEY,
  merchant_id BIGINT NOT NULL,
  biz_order_id VARCHAR(128) NOT NULL,
  amount BIGINT NOT NULL,
  currency VARCHAR(8) NOT NULL,
  pay_method VARCHAR(32) NOT NULL,
  status VARCHAR(32) NOT NULL,          -- CREATED/PENDING/SUCCESS/FAILED/CANCELED/REFUNDED
  channel VARCHAR(32),
  channel_txn_id VARCHAR(128),
  idempotency_key VARCHAR(128) NOT NULL,
  version BIGINT NOT NULL DEFAULT 1,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  UNIQUE(merchant_id, idempotency_key)
);
CREATE INDEX idx_pay_merchant_biz ON payment_order(merchant_id, biz_order_id);
CREATE INDEX idx_pay_status_time ON payment_order(status, updated_at);
```

### 8.2 账本分录表（双记账）
```sql
CREATE TABLE ledger_entry (
  entry_id BIGINT PRIMARY KEY,
  payment_id VARCHAR(64) NOT NULL,
  account_id BIGINT NOT NULL,
  direction VARCHAR(8) NOT NULL,        -- DEBIT/CREDIT
  amount BIGINT NOT NULL,
  currency VARCHAR(8) NOT NULL,
  entry_type VARCHAR(32) NOT NULL,      -- PAY/REFUND/FEE/CHARGEBACK
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_ledger_payment ON ledger_entry(payment_id);
CREATE INDEX idx_ledger_account_time ON ledger_entry(account_id, created_at DESC);
```

### 8.3 退款表
```sql
CREATE TABLE payment_refund (
  refund_id VARCHAR(64) PRIMARY KEY,
  payment_id VARCHAR(64) NOT NULL,
  merchant_id BIGINT NOT NULL,
  amount BIGINT NOT NULL,
  status VARCHAR(32) NOT NULL,          -- CREATED/PENDING/SUCCESS/FAILED
  idempotency_key VARCHAR(128) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  UNIQUE(payment_id, idempotency_key)
);
```

### 8.4 对账结果表
```sql
CREATE TABLE reconcile_result (
  rec_id BIGINT PRIMARY KEY,
  payment_id VARCHAR(64) NOT NULL,
  channel_status VARCHAR(32),
  local_status VARCHAR(32),
  diff_type VARCHAR(32) NOT NULL,       -- MISSING_LOCAL/MISSING_CHANNEL/STATUS_MISMATCH/AMOUNT_MISMATCH
  fixed BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_reconcile_fixed ON reconcile_result(fixed, created_at);
```

### 8.5 清结算批次表
```sql
CREATE TABLE settlement_batch (
  batch_id VARCHAR(64) PRIMARY KEY,
  merchant_id BIGINT NOT NULL,
  settle_date DATE NOT NULL,
  gross_amount BIGINT NOT NULL,
  fee_amount BIGINT NOT NULL,
  net_amount BIGINT NOT NULL,
  status VARCHAR(16) NOT NULL,          -- INIT/PROCESSING/SUCCESS/FAILED
  created_at TIMESTAMP NOT NULL
);
```

## 9. 核心流程（至少 3 条）
### 9.1 正常支付流程
1. 商户创建支付意图单，系统校验幂等键。
2. 风控通过后路由到最优通道（成功率/成本/限额）。
3. 通道返回同步结果或进入 `PENDING`。
4. 回调到达后状态机迁移到 `SUCCESS/FAILED`。
5. 支付成功触发双记账、商户通知、清分任务。

### 9.2 高峰流程（活动大促）
1. 流量突增，支付 API 启动分级限流。
2. 通道按容量动态路由（主通道+备通道）。
3. 回调处理集群扩容，确保状态收敛不积压。
4. 非核心异步（报表）降级，优先保障交易链路。

### 9.3 故障恢复流程（回调丢失）
1. 支付单长时间 `PENDING` 超阈值。
2. 状态轮询任务调用通道查询接口。
3. 若通道确认成功，本地补状态并补记账/补通知。
4. 若仍未知，进入人工核查队列并持续重试。

### 9.4 退款流程
1. 商户发起退款请求，校验支付单状态和可退额度。
2. 生成退款单并调用通道退款接口。
3. 回调成功后写退款账本分录并更新订单退款状态。
4. 对账任务校验退款结果是否一致。

## 10. 一致性与事务边界
### 10.1 一致性策略
- 支付状态、账本分录、事件外发在本地事务内尽量一致。
- 跨系统（渠道/商户）最终一致，通过回调+对账收敛。

### 10.2 状态机边界（示例）
- `CREATED -> PENDING -> SUCCESS/FAILED`
- `SUCCESS -> REFUNDED`（部分退款可多次）
- 禁止 `FAILED -> SUCCESS` 无补偿依据直接跳转

### 10.3 幂等策略
- 创建支付：`merchantId + idempotencyKey`
- 回调处理：`channelTxnId`
- 退款：`paymentId + refundIdempotencyKey`

### 10.4 面试可复述
“支付系统核心不是追求一次就完美，而是每一步都可幂等、可重试、可对账、可修复。”

## 11. 可用性与容错
### 11.1 常见故障
- 通道超时或短时不可用。
- 回调消息重复/乱序/丢失。
- 账本服务抖动导致入账延迟。
- 清结算批次失败。

### 11.2 容错策略
- 通道熔断 + 自动切路由。
- 回调幂等 + 延迟重试 + 轮询补偿。
- 账本写入失败进重试队列，不允许静默丢失。
- 批次任务失败自动重跑并报警。

### 11.3 RTO / RPO
- 支付主链路 RTO：`<= 5 分钟`
- 状态补偿 RTO：`<= 30 分钟`
- 对账差异 RPO：`T+1 收敛`

## 12. 可观测性（指标 + 告警阈值）
### 12.1 主链路指标
- `payment_create_qps`
- `payment_success_rate`
- `payment_latency_p95`
- `pending_timeout_count`

阈值示例：
- `payment_success_rate < 92%` 持续 5 分钟 -> P1
- `payment_latency_p95 > 800ms` 持续 10 分钟 -> P1
- `pending_timeout_count > 500/min` -> P1

### 12.2 回调与补偿指标
- `callback_delay_p95`
- `callback_duplicate_ratio`
- `status_poll_fix_count`

阈值示例：
- `callback_delay_p95 > 60s` 持续 10 分钟 -> P1
- `callback_duplicate_ratio > 20%` -> P2

### 12.3 对账与清结算指标
- `reconcile_diff_count`
- `reconcile_fix_success_rate`
- `settlement_batch_fail_count`

阈值示例：
- `reconcile_diff_count > baseline*2` -> P1
- `settlement_batch_fail_count > 0` -> P1

## 13. 安全与合规
- PCI-DSS：卡号敏感数据不落本地明文。
- 传输与存储加密（TLS + at-rest encryption）。
- 回调验签、防重放、防伪造。
- 风控策略：设备指纹、IP 地域异常、金额阈值、黑名单。
- 审计合规：关键操作（退款、通道切换、补偿）全量审计。
- AML/KYC：大额和可疑交易触发合规审查。

## 14. 成本与取舍
### 14.1 成本组成
- 多通道接入与维护成本。
- 风控与合规成本。
- 对账/清结算计算与存储成本。

### 14.2 关键取舍
- 通道多样化提高成功率但集成复杂度高。
- 风控越严，欺诈下降但支付转化可能受损。
- 强同步确认更稳但延迟高，需结合业务场景选异步收敛。

### 14.3 降本策略
- 智能路由：按成功率和费率动态选择通道。
- 对账分层：关键商户逐笔对账，长尾商户批量对账。
- 把非关键报表异步化，释放主链路资源。

## 15. 关键代码（Java 更细 + 前端功能代码）
### 15.1 Java：创建支付单幂等
```java
public class PaymentIntentService {
    public PaymentIntentResult createIntent(CreatePaymentIntentCmd cmd) {
        PaymentOrder existing = paymentRepo.findByMerchantAndIdem(cmd.getMerchantId(), cmd.getIdempotencyKey());
        if (existing != null) {
            return PaymentIntentResult.reused(existing.getPaymentId(), existing.getStatus());
        }

        String paymentId = idGen.nextPaymentId();
        transactionTemplate.executeWithoutResult(tx -> {
            paymentRepo.insert(PaymentOrder.created(paymentId, cmd));
            outboxRepo.append("PAYMENT_CREATED", paymentId, Map.of("merchantId", cmd.getMerchantId()));
        });
        return PaymentIntentResult.created(paymentId, "CREATED");
    }
}
```

### 15.2 Java：支付状态机迁移校验
```java
public class PaymentStateMachine {
    private static final Map<String, Set<String>> ALLOWED = Map.of(
        "CREATED", Set.of("PENDING", "FAILED"),
        "PENDING", Set.of("SUCCESS", "FAILED"),
        "SUCCESS", Set.of("REFUNDED"),
        "FAILED", Set.of(),
        "REFUNDED", Set.of()
    );

    public void transit(PaymentOrder order, String to) {
        String from = order.getStatus();
        if (!ALLOWED.getOrDefault(from, Set.of()).contains(to)) {
            throw new IllegalStateException("invalid transition: " + from + " -> " + to);
        }
    }
}
```

### 15.3 Java：回调处理幂等 + 双记账触发
```java
public class ChannelCallbackHandler {
    public void handle(ChannelCallback cb) {
        if (callbackRepo.exists(cb.getChannel(), cb.getChannelTxnId())) {
            return; // 幂等
        }

        transactionTemplate.executeWithoutResult(tx -> {
            PaymentOrder order = paymentRepo.findForUpdate(cb.getPaymentId());
            stateMachine.transit(order, cb.isSuccess() ? "SUCCESS" : "FAILED");
            paymentRepo.updateStatus(order.getPaymentId(), cb.isSuccess() ? "SUCCESS" : "FAILED", order.getVersion() + 1);
            callbackRepo.insert(cb);

            if (cb.isSuccess()) {
                outboxRepo.append("LEDGER_BOOK_PAY", order.getPaymentId(), Map.of("amount", order.getAmount()));
                outboxRepo.append("MERCHANT_NOTIFY_SUCCESS", order.getPaymentId(), Map.of());
            }
        });
    }
}
```

### 15.4 Java：双记账（借贷平衡校验）
```java
public class LedgerBookService {
    public void bookPay(String paymentId, long payerAccountId, long merchantPendingAccountId, long amount) {
        LedgerEntry debit = LedgerEntry.debit(paymentId, payerAccountId, amount, "PAY");
        LedgerEntry credit = LedgerEntry.credit(paymentId, merchantPendingAccountId, amount, "PAY");

        if (debit.getAmount() != credit.getAmount()) {
            throw new IllegalStateException("double-entry not balanced");
        }

        ledgerRepo.batchInsert(List.of(debit, credit));
    }
}
```

### 15.5 Java：对账差异自动修复
```java
public class ReconciliationService {
    public void reconcileDaily(LocalDate date) {
        List<ChannelBillItem> channelItems = channelBillClient.pull(date);
        for (ChannelBillItem item : channelItems) {
            PaymentOrder local = paymentRepo.findByPaymentId(item.getPaymentId());
            if (local == null) {
                recRepo.saveDiff(item.getPaymentId(), "MISSING_LOCAL");
                repairQueue.publish(new RepairTask(item.getPaymentId(), "CREATE_LOCAL_FROM_CHANNEL"));
                continue;
            }
            if (!Objects.equals(local.getStatus(), item.getStatus())) {
                recRepo.saveDiff(item.getPaymentId(), "STATUS_MISMATCH");
                repairQueue.publish(new RepairTask(item.getPaymentId(), "SYNC_STATUS"));
            }
        }
    }
}
```

### 15.6 Java：商户通知重试（指数退避）
```java
public class MerchantNotifyWorker {
    public void notifyMerchant(NotifyTask task) {
        int attempt = task.getAttempt();
        try {
            HttpResponse resp = httpClient.post(task.getNotifyUrl(), task.getPayload(), task.getSignHeaders());
            if (resp.getStatusCode() / 100 == 2) {
                notifyRepo.markSuccess(task.getTaskId());
                return;
            }
            throw new RuntimeException("non-2xx");
        } catch (Exception ex) {
            if (attempt >= 8) {
                notifyRepo.markFailed(task.getTaskId(), ex.getMessage());
                dlqRepo.save("MERCHANT_NOTIFY", task.getTaskId(), ex.getMessage());
                return;
            }
            long delaySec = (long) Math.min(300, Math.pow(2, attempt));
            retryQueue.delay(task.nextAttempt(), Duration.ofSeconds(delaySec));
        }
    }
}
```

### 15.7 前端（React + TypeScript）：收银台页面
```tsx
import { useState } from "react";

export function CheckoutPayPage() {
  const [loading, setLoading] = useState(false);
  const [paymentId, setPaymentId] = useState("");
  const [msg, setMsg] = useState("");

  const createAndPay = async () => {
    setLoading(true);
    const idempotencyKey = `pay_${Date.now()}`;
    const resp = await fetch("/api/v1/payments/intents", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        merchantId: 9001,
        bizOrderId: "O202602240001",
        amount: 19900,
        currency: "CNY",
        payMethod: "CARD",
        idempotencyKey
      })
    });
    setLoading(false);
    if (!resp.ok) {
      setMsg(`创建支付失败: ${resp.status}`);
      return;
    }
    const data = await resp.json();
    setPaymentId(data.paymentId);
    if (data.redirectUrl) {
      window.location.href = data.redirectUrl; // 跳转三方支付页
    } else {
      setMsg("已创建支付，请继续完成支付");
    }
  };

  return (
    <div>
      <h3>收银台</h3>
      <button disabled={loading} onClick={createAndPay}>
        {loading ? "请求中..." : "立即支付"}
      </button>
      {paymentId && <p>PaymentId: {paymentId}</p>}
      {msg && <p>{msg}</p>}
    </div>
  );
}
```

### 15.8 前端（React + TypeScript）：支付状态轮询页
```tsx
import { useEffect, useState } from "react";

type PaymentView = {
  paymentId: string;
  status: string;
  updatedAt: string;
};

export function PaymentStatusPage({ paymentId }: { paymentId: string }) {
  const [payment, setPayment] = useState<PaymentView | null>(null);

  useEffect(() => {
    let timer: number;
    const poll = async () => {
      const resp = await fetch(`/api/v1/payments/${paymentId}`);
      if (resp.ok) {
        const data = await resp.json();
        setPayment(data);
        if (data.status === "SUCCESS" || data.status === "FAILED") return;
      }
      timer = window.setTimeout(poll, 3000);
    };
    poll();
    return () => window.clearTimeout(timer);
  }, [paymentId]);

  if (!payment) return <div>正在查询支付状态...</div>;
  return (
    <div>
      <h3>支付状态</h3>
      <p>支付单号: {payment.paymentId}</p>
      <p>状态: {payment.status}</p>
      <p>更新时间: {payment.updatedAt}</p>
    </div>
  );
}
```

## 16. 测试策略
### 16.1 单元测试
- 状态机迁移合法性与非法迁移阻断。
- 幂等键重复请求行为。
- 双记账借贷平衡校验。

### 16.2 集成测试
- 创建支付 -> 通道请求 -> 回调 -> 记账 -> 通知全链路。
- 退款全链路（部分退款、多次退款边界）。
- 对账差异自动修复流程。

### 16.3 压测
- 主支付请求 80k QPS 压测。
- 回调 200k QPS 放大场景压测。
- 对账批处理窗口性能压测。

### 16.4 故障注入
- 通道超时/5xx。
- 回调重复、乱序、丢失。
- 账本库短时不可用。
- 清结算任务失败重跑。

## 17. 丰富例子（至少 10 个）
1. 用户双击支付按钮，幂等键保证只创建一个支付单。  
2. 通道超时后状态置 PENDING，轮询最终确认成功。  
3. 同一回调重复 5 次，系统只处理一次。  
4. 支付成功但商户通知失败，系统重试并最终送达。  
5. 支付成功但本地未记账，对账任务自动补账。  
6. 退款请求重复提交，通过退款幂等键防重复退。  
7. 通道 A 成功率下降，动态切路由到通道 B。  
8. 风控识别异常设备，支付请求被拒绝。  
9. 清结算批次失败，重跑后恢复成功。  
10. 对账发现状态不一致，自动触发修复并记录审计。  
11. 用户支付后页面超时，状态页轮询最终显示成功。  
12. 遇到拒付，系统生成冲正分录并进入争议流程。  

## 18. 面试追问 + 可复述回答
### Q1：如何避免重复扣款？
可复述：  
“支付创建和支付执行都要幂等，幂等键+唯一约束+回调幂等三层防护。”

### Q2：支付成功但业务没收到怎么办？
可复述：  
“先回调重试，再状态轮询补偿，最后通过对账发现并修复漏通知。”

### Q3：为什么要双记账？
可复述：  
“双记账保证每笔资金流入流出平衡，便于审计、对账和错误定位。”

### Q4：清分和结算有什么区别？
可复述：  
“清分是算账拆账，结算是打钱落账。一个是计算，一个是资金交收。”

### Q5：对账如何自动化？
可复述：  
“渠道账单拉取后逐笔比对差异类型，自动触发补单/补账/补通知，失败入人工队列。”

### Q6：支付系统如何兼顾成功率和成本？
可复述：  
“做智能通道路由：按成功率、费率、时延动态选路，持续 A/B 评估。”

## 19. 新手学习路线
### 第 1 周：支付基础链路
- 实现支付意图单、状态查询、简单回调处理。
- 学会幂等键和状态机设计。

### 第 2 周：账务与退款
- 实现双记账模型。
- 实现退款与部分退款边界处理。

### 第 3 周：对账与补偿
- 做渠道账单导入和差异检测。
- 做自动修复任务与 DLQ。

### 第 4 周：安全与运营
- 加验签、风控、审计。
- 做前端收银台和支付状态页。
- 练习面试话术：状态机+幂等+对账闭环。

## 20. 上场前 Checklist
- [ ] 我能画出支付状态机并解释每条迁移边界。  
- [ ] 我能讲清幂等键在创建、回调、退款三个位置的作用。  
- [ ] 我能解释双记账为什么是支付系统基础能力。  
- [ ] 我能说明清分、结算、对账三者关系。  
- [ ] 我能给出 3 个以上支付链路告警阈值。  
- [ ] 我能描述“回调丢失 -> 补偿 -> 对账修复”完整流程。  
- [ ] 我能解释风控和转化率之间的取舍。  
- [ ] 我能展示前端支付页和状态轮询如何避免用户误操作。  

## 21. 30 秒总结
在线支付系统高分答案是：  
“用状态机管理交易生命周期，用幂等保证不重复扣款，用双记账保证资金可审计，用回调+轮询+对账保证最终一致，再用清结算把资金准确结给商户。”  
把这句话落实到数据模型、异常流程、阈值和代码实现，你的面试表现会非常稳。  
