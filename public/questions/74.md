# Q74 Business Intelligence (商业智能)

## 1. 题目信息校验
- title：Business Intelligence (商业智能)
- tags：BI报表、指标看板、钻取分析、自助分析、权限
- keyPoints：指标定义与口径、看板搭建、多维钻取、权限隔离、性能与缓存
- learningCoreId：72
- 总分：98/100

## 2. 题目目标
设计一个 BI 系统，支持多角色看板、自助查询、指标治理、权限控制，并在高并发与故障场景下保持可用和可恢复。

## 3. 范围与非目标
- 范围：指标定义、查询服务、看板渲染、权限校验、任务调度、审计与告警。
- 非目标：跨区域强一致全局事务；实时链路替代离线全量修复。

## 4. 需求拆解
- 功能：指标创建/发布、维度钻取、看板管理、订阅告警、导出。
- 非功能：P95 查询延迟、可用性、数据正确性、审计可追溯。
- 运维：灰度、回滚、容量扩展、故障演练。

## 5. 容量估算
- 假设 DAU 200 万，峰值并发查询 1.5 万 QPS，写入任务峰值 8 千/s。
- 热指标缓存命中目标 > 92%，冷查询落数仓/OLAP。
- 存储：事实表日增 1.2TB，维表日增 80GB，保留 180 天热数据。

## 6. 架构总览
```text
Web/App -> API Gateway -> BI Query Service -> Cache/OLAP
                          -> Metric Metadata Service -> Meta DB
                          -> Permission Service -> IAM/RBAC
                          -> Scheduler -> ETL/Backfill Workers
                          -> Observability -> Metrics/Logs/Trace
```

## 7. 核心数据模型
- `metric_definition(id, code, version, owner, sql_text, status, created_at)`
- `metric_lineage(metric_id, source_table, transform_hash, updated_at)`
- `dashboard(id, name, owner, layout_json, status)`
- `dashboard_widget(id, dashboard_id, metric_id, query_template, sort_rule)`
- `query_audit(id, user_id, metric_id, filters_hash, duration_ms, result_rows, at)`

## 8. API 设计
- `POST /api/bi/metrics`：创建指标定义。
- `POST /api/bi/query`：执行查询（支持维度钻取）。
- `GET /api/bi/dashboards/:id`：拉取看板配置与数据。
- `POST /api/bi/backfill`：触发回填任务。
- `POST /api/bi/reconcile`：触发对账修复。

## 9. 关键流程
1. 指标发布：定义 -> 审批 -> 生效 -> 缓存预热。
2. 查询渲染：鉴权 -> 模板展开 -> 命中缓存或回源 -> 返回图表数据。
3. 口径修复：发现偏差 -> 回填 -> 对账 -> 审计记录。

## 10. 一致性与事务边界
- 元数据写入采用本地事务。
- 跨服务使用 Outbox + MQ + 幂等消费。
- 指标版本变更采用“新版本并行发布 + 流量切换 + 回滚开关”。

## 11. 阈值体系
- 查询 P95 阈值：`<= 800ms`；连续 5 分钟超阈触发 P1。
- 查询错误率阈值：`<= 0.5%`；连续 3 分钟超阈触发 P1。
- 回填积压阈值：`<= 100000`；超阈触发限流与降级。
- 缓存命中率阈值：`>= 92%`；低于阈值触发预热与热点保护。

## 12. 可用性与故障恢复路径（含 RTO/RPO）
- 可用性目标：99.95%。
- RTO：30 分钟（核心查询链路恢复时间上限）。
- RPO：5 分钟（可接受数据回退窗口）。
- 恢复路径：
1. 告警触发后 3 分钟内执行流量降级（关闭重型钻取、保留核心看板）。
2. 5 分钟内切换只读缓存快照，保障“可读不可写”核心能力。
3. 15 分钟内启动回填与对账任务，按指标优先级恢复。
4. 30 分钟内完成主链路恢复并逐步回切。

## 13. 安全与权限
- RBAC + ABAC：按角色、部门、数据域做细粒度授权。
- 行列级权限：SQL 模板自动注入策略。
- 审计：高敏指标查询全量留痕，支持追责与合规导出。

## 14. 成本与取舍
- 热数据走缓存与预聚合，冷数据走 OLAP 明细，平衡成本与时效。
- 高频看板做物化视图，长尾查询接受更高延迟。
- 查询并发采用分级队列，保障核心租户 SLA。

## 15. Java 关键代码（>=5）
```java
public class MetricPublishService {
    public PublishResult publish(MetricDefinition def, String operator) {
        String idem = def.getCode() + ":" + def.getVersion();
        if (idempotencyStore.exists(idem)) {
            return idempotencyStore.read(idem);
        }
        tx.begin();
        try {
            metricRepo.insert(def);
            outboxRepo.append("METRIC_PUBLISHED", def.getCode(), def.getVersion());
            PublishResult result = PublishResult.success(def.getCode(), def.getVersion(), operator);
            idempotencyStore.save(idem, result);
            tx.commit();
            return result;
        } catch (RuntimeException ex) {
            tx.rollback();
            throw ex;
        }
    }
}
```

```java
public class QueryGuard {
    public void validate(QueryRequest req) {
        if (req.getLimit() > 5000) {
            throw new IllegalArgumentException("limit too large");
        }
        if (req.getFilters().size() > 20) {
            throw new IllegalArgumentException("too many filters");
        }
        if (!permissionService.allowed(req.getUserId(), req.getMetricCode())) {
            throw new SecurityException("permission denied");
        }
    }
}
```

```java
public class RetryExecutor {
    public <T> T runWithRetry(Supplier<T> action) {
        int max = 3;
        RuntimeException last = null;
        for (int i = 1; i <= max; i++) {
            try {
                return action.get();
            } catch (RuntimeException ex) {
                last = ex;
                long backoffMs = (long) Math.pow(2, i) * 100L;
                sleep(backoffMs);
            }
        }
        throw last;
    }

    private void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("retry interrupted", e);
        }
    }
}
```

```java
public class ReconcileJob {
    public void execute(LocalDate date) {
        List<DiffRow> diffs = diffRepo.find(date);
        for (DiffRow row : diffs) {
            try {
                repairService.rebuild(row.getMetricCode(), row.getDimensionKey(), date);
                diffRepo.markFixed(row.getId(), Instant.now());
            } catch (Exception ex) {
                dlqRepo.push(row.getId(), ex.getMessage(), Instant.now());
            }
        }
    }
}
```

```java
public class HealthEvaluator {
    public HealthStatus evaluate(double errorRate, long p95Ms, long backlog) {
        boolean healthy = errorRate <= 0.005 && p95Ms <= 800 && backlog <= 100000;
        if (healthy) {
            return HealthStatus.green("stable");
        }
        if (errorRate > 0.02 || backlog > 300000) {
            return HealthStatus.red("degrade now");
        }
        return HealthStatus.yellow("watch closely");
    }
}
```

## 16. React JavaScript 代码（>=2）
```javascript
import React, { useEffect, useRef, useState } from "react";

export function DashboardPollingPanel({ dashboardId }) {
  const [status, setStatus] = useState("loading"); // loading | error | done
  const [data, setData] = useState(null);
  const [error, setError] = useState("");
  const timerRef = useRef(null);

  async function loadOnce() {
    setStatus("loading");
    setError("");
    try {
      const resp = await fetch(`/api/bi/dashboards/${dashboardId}`);
      if (!resp.ok) {
        throw new Error(`HTTP_${resp.status}`);
      }
      const body = await resp.json();
      setData(body);
      setStatus("done");
    } catch (e) {
      setStatus("error");
      setError("加载失败，进入降级：展示上次快照");
    }
  }

  useEffect(() => {
    loadOnce();
    timerRef.current = setInterval(loadOnce, 5000); // 轮询
    return () => clearInterval(timerRef.current);
  }, [dashboardId]);

  if (status === "loading") return <div>loading...</div>;
  if (status === "error") return <div>{error}</div>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

```jsx
import React, { useState } from "react";

export function MetricCreateForm() {
  const [status, setStatus] = useState("done"); // loading | error | done
  const [error, setError] = useState("");

  async function submitMetric(payload) {
    const idemKey = `metric-${payload.code}-${payload.version}`; // 幂等键
    setStatus("loading");
    setError("");
    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        const resp = await fetch("/api/bi/metrics", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Idempotency-Key": idemKey
          },
          body: JSON.stringify(payload)
        });
        if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
        setStatus("done");
        return;
      } catch (e) {
        if (attempt === 3) {
          setStatus("error");
          setError("提交失败，请稍后重试");
        }
      }
    }
  }

  return (
    <button onClick={() => submitMetric({ code: "gmv", version: "v2" })}>
      {status === "loading" ? "提交中..." : "提交指标"}
      {status === "error" ? ` (${error})` : ""}
    </button>
  );
}
```

## 17. 测试与演练
- 单测：口径函数、权限策略、幂等键处理。
- 集成：指标发布到查询全链路。
- 压测：峰值 1.5 万 QPS，验证阈值触发行为。
- 混沌演练：缓存失效、OLAP 超时、MQ 堆积、回填失败。

## 18. 丰富例子（>=10）
1. 新建 GMV 指标后 5 分钟内在销售看板可见。
2. 某部门用户只能看到本部门成本维度。
3. 钻取到城市维度时命中预聚合，P95 保持在 600ms。
4. 查询错误率突增到 1.2% 时触发降级并关闭重型明细。
5. 缓存命中跌到 85% 时自动预热 Top50 指标。
6. 回填任务积压 12 万时启动限流和优先级队列。
7. 指标版本 `v1->v2` 灰度 10%，异常后 1 分钟内回滚。
8. 审计发现越权查询后，自动冻结 token 并通知安全团队。
9. OLAP 集群节点故障时切只读快照，核心看板持续可读。
10. 某口径偏差 0.8% 时自动触发对账并生成修复报告。
11. 月末峰值流量下，核心经营看板仍满足 99.95% 可用性。
12. 重大故障后 25 分钟完成主链路恢复，满足 RTO 目标。

## 19. 面试追问
- 为什么要区分热查询与冷查询：因为成本和时效目标不同。
- 为什么要幂等键：避免重试导致重复发布或重复扣费。
- 为什么要对账：保证指标正确性可验证、可收敛、可审计。

## 20. 常见坑
- 只谈 SQL 不谈口径版本治理。
- 只谈缓存不谈权限隔离与审计。
- 只谈高可用不谈恢复顺序与回切标准。

## 21. 复盘模板
- 现象：哪条指标、哪个租户、何时劣化。
- 影响：错误率、延迟、业务损失。
- 根因：口径、缓存、权限、依赖故障中的哪一类。
- 行动：止血、修复、验证、预防。

## 22. 与母题差异
- 母题：Q72 Data Warehouse（数据仓库），偏“数仓分层与离线建模”。
- 本题：Q74 Business Intelligence，偏“指标消费层、交互分析层、权限治理层”。
- 差异点：
1. 母题强调建模与产数，本题强调消费体验与查询 SLA。
2. 母题关注 ETL 稳定，本题更强调看板渲染与交互钻取性能。
3. 母题权限多在数据域，本题权限要落到看板/控件/维度级。
4. 母题偏批处理一致性，本题要兼顾近实时与降级可读。
5. 母题聚焦数据生产链路，本题聚焦数据服务链路与运营闭环。
- 新增必补知识：
1. 指标语义层（Metric Layer）与版本治理。
2. 看板级缓存策略与失效广播机制。
3. 多维钻取下的查询路由与资源配额。
4. 前端状态机（loading/error/done）与降级展示策略。
5. BI 权限模型（RBAC+ABAC+行列级）的工程化实现。
6. 查询审计、归因分析、故障回切的值班 Runbook。
