# Q75：Design Smart Home System

## 1. 题目定义与元数据
- 题目：Design Smart Home System
- tags：IoT、设备管理、场景联动、语音控制、自动化
- keyPoints：MQTT协议、设备发现、场景自动化、语音集成、远程控制
- learningCoreId：60（母题：Design Task Management Application）
- 总分：98/100

## 2. 业务目标
- 支持家庭设备接入、状态上报、远程控制与场景自动化执行。
- 支持多端（App/音箱/中控屏）一致体验与权限隔离。
- 在设备离线、网络抖动、第三方语音平台异常时仍保证核心控制链路可用。

## 3. 需求澄清
- 功能：设备注册、设备发现、场景编排、联动执行、语音指令映射、告警通知。
- 非功能：控制指令 P95 < 300ms；核心链路可用性 >= 99.95%。
- 不做：复杂视频流安防分析、全屋能源优化算法。

## 4. 核心挑战
- 设备协议异构（MQTT/Zigbee/Wi-Fi 网关）。
- 设备在线状态不稳定，导致自动化触发抖动。
- 指令重复下发、乱序到达带来幂等与状态一致性问题。

## 5. 容量与SLO
- 100万家庭，户均20设备，总设备量约2000万。
- 峰值在线连接 300万，遥控指令峰值 12万 QPS，状态上报峰值 50万 QPS。
- SLO：指令成功率 >= 99.9%，场景执行成功率 >= 99.5%。

## 6. 总体架构
```text
Mobile/Web/Voice
   -> API Gateway
   -> Auth & Home ACL
   -> Device Command Service
   -> Rule Engine / Scene Engine
   -> MQTT Broker Cluster
   -> Device Gateway
   -> Device Digital Twin Store (Redis + DB)
   -> Event Bus + Retry/DLQ
```

## 7. API 设计
- `POST /api/v1/homes/{homeId}/devices/{deviceId}/commands`
- `POST /api/v1/homes/{homeId}/scenes/{sceneId}/execute`
- `GET /api/v1/homes/{homeId}/devices/{deviceId}/state`
- `POST /api/v1/voice/intents/dispatch`

## 8. 数据模型
- `device(id, home_id, product_key, status, fw_version, last_seen_at)`
- `device_command(cmd_id, idempotency_key, device_id, payload, status, created_at)`
- `scene(id, home_id, name, trigger_json, action_json, enabled)`
- `scene_execution(exec_id, scene_id, trigger_event_id, status, started_at, ended_at)`
- `voice_mapping(intent_id, slot_json, scene_id/device_action, version)`

## 9. 关键流程
1. 设备控制：App 下发指令 -> 鉴权 -> 幂等校验 -> Broker 投递 -> ACK 回写状态。
2. 场景联动：事件触发 -> 规则匹配 -> 动作编排 -> 并发执行 -> 聚合结果。
3. 语音控制：NLU 解析 -> 意图映射 -> 设备/场景执行 -> 结果播报。

## 10. 一致性与幂等
- 写路径采用 `idempotency_key = userId + clientReqId + deviceId`。
- 设备侧 ACK 使用 `cmd_id` 去重，重复 ACK 只更新幂等结果。
- 最终一致：控制主状态在 DB，实时态在 Redis Twin，异步补偿对齐。

## 11. 高可用与降级
- Broker 分区多副本，跨可用区部署；控制服务无状态水平扩容。
- 依赖故障时降级路径：语音入口失败 -> 回退 App 控制；自动化引擎异常 -> 保留手动控制。
- 阈值触发自动熔断：第三方语音 5xx > 8% 持续 3 分钟则切换本地模板命令。

## 12. 阈值、告警与故障恢复（含RTO/RPO）
- 阈值：
  - 指令超时率 > 2%（5分钟）触发 P1。
  - 场景执行失败率 > 5%（10分钟）触发 P1。
  - 设备离线率突增 > 基线 3 倍（10分钟）触发 P1。
- 故障恢复路径：
  - Step1 止血：限流 + 熔断 + 关闭非核心自动化。
  - Step2 切流：将控制流量切到健康 Broker 分区与备用网关。
  - Step3 修复：回放失败命令队列，按幂等键重放。
  - Step4 对账：`device_command` 与设备 ACK 日志比对，补发缺失命令。
- RTO：核心控制链路 15 分钟内恢复。
- RPO：命令与状态数据丢失不超过 60 秒。

## 13. 安全与权限
- 家庭维度 RBAC（owner/member/guest）+ 设备级 ACL。
- 全链路 TLS，设备证书双向认证。
- 高风险动作（二次确认）：门锁、燃气阀、安防布撤防。

## 14. 成本与取舍
- Redis Twin 保证读延迟，但增加内存成本；冷数据下沉 MySQL/对象存储。
- 场景执行实时性优先，复杂统计离线化。
- 语音平台多活会升成本，按区域热备而非全量强一致多活。

## 15. Java 关键代码（>=5段）
```java
public class IdempotencyService {
    public boolean tryAcquire(String key, Duration ttl) {
        return redis.setIfAbsent("idem:" + key, "1", ttl);
    }
}
```

```java
public class CommandController {
    public ApiResponse sendCommand(CommandRequest req) {
        String key = req.userId() + ":" + req.clientReqId() + ":" + req.deviceId();
        if (!idempotencyService.tryAcquire(key, Duration.ofMinutes(5))) {
            CommandResult cached = commandRepo.findByIdempotencyKey(key);
            return ApiResponse.ok(cached);
        }
        CommandResult result = commandService.dispatch(req, key);
        return ApiResponse.ok(result);
    }
}
```

```java
public class MqttDispatchService {
    public CommandResult dispatch(CommandRequest req, String idemKey) {
        long cmdId = snowflake.nextId();
        commandRepo.insert(cmdId, idemKey, req.deviceId(), "SENT");
        mqttClient.publish("home/" + req.homeId() + "/device/" + req.deviceId(), req.payload());
        return new CommandResult(cmdId, "SENT");
    }
}
```

```java
public class SceneEngine {
    public SceneExecResult execute(Scene scene, Event trigger) {
        List<Action> actions = planner.plan(scene, trigger);
        int success = 0;
        for (Action action : actions) {
            boolean ok = commandGateway.invoke(action);
            if (ok) {
                success++;
            } else {
                retryQueue.enqueue(action, 1);
            }
        }
        return new SceneExecResult(scene.getId(), success, actions.size());
    }
}
```

```java
public class RetryWorker {
    public void onMessage(RetryTask task) {
        int next = task.attempt() + 1;
        boolean ok = commandGateway.invoke(task.action());
        if (ok) {
            retryRepo.markDone(task.taskId());
        } else if (next <= 5) {
            long backoff = Math.min(300, 1L << next);
            retryRepo.requeue(task.taskId(), next, backoff);
        } else {
            dlqRepo.save(task.taskId(), task.action(), "max-attempt-exceeded");
        }
    }
}
```

## 16. 前端 React JavaScript 代码（>=2段）
```jsx
import React, { useEffect, useRef, useState } from "react";

export function DeviceControlPanel({ homeId, deviceId }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [done, setDone] = useState(false);
  const [status, setStatus] = useState("IDLE");
  const pollRef = useRef(null);

  const pollStatus = async () => {
    try {
      const res = await fetch(`/api/v1/homes/${homeId}/devices/${deviceId}/state`);
      if (!res.ok) throw new Error("poll_failed");
      const data = await res.json();
      setStatus(data.status);
    } catch (e) {
      setError("状态轮询失败，已降级为手动刷新");
      clearInterval(pollRef.current);
    }
  };

  useEffect(() => {
    pollRef.current = setInterval(pollStatus, 5000);
    return () => clearInterval(pollRef.current);
  }, [homeId, deviceId]);

  const sendCommand = async () => {
    setLoading(true);
    setDone(false);
    setError("");
    const idemKey = `${homeId}-${deviceId}-${Date.now()}`;
    try {
      const res = await fetch(`/api/v1/homes/${homeId}/devices/${deviceId}/commands`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "Idempotency-Key": idemKey },
        body: JSON.stringify({ command: "TURN_ON" })
      });
      if (!res.ok) throw new Error("send_failed");
      setDone(true);
    } catch (e) {
      setError("控制失败，请重试");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={sendCommand} disabled={loading}>
        {loading ? "发送中..." : "打开设备"}
      </button>
      <p>状态：{status}</p>
      {error && <p>{error}</p>}
      {done && <p>指令已受理</p>}
    </div>
  );
}
```

```javascript
import React, { useState } from "react";

export function SceneExecuteButton({ homeId, sceneId }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [done, setDone] = useState(false);

  const executeWithRetry = async (maxRetry = 2) => {
    setLoading(true);
    setDone(false);
    setError("");
    let attempt = 0;
    while (attempt <= maxRetry) {
      try {
        const res = await fetch(`/api/v1/homes/${homeId}/scenes/${sceneId}/execute`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ trigger: "MANUAL" })
        });
        if (res.ok) {
          setDone(true);
          setLoading(false);
          return;
        }
        attempt += 1;
      } catch (e) {
        attempt += 1;
      }
    }
    setError("场景执行失败，已触发降级：仅执行关键设备动作");
    setLoading(false);
  };

  return (
    <div>
      <button disabled={loading} onClick={() => executeWithRetry(2)}>
        {loading ? "执行中..." : "执行场景"}
      </button>
      {error && <div>{error}</div>}
      {done && <div>执行成功</div>}
    </div>
  );
}
```

## 17. 测试与演练
- 单测：幂等键冲突、重复 ACK、场景规则命中。
- 集成：控制链路端到端 + 语音入口到设备动作。
- 压测：12万 QPS 指令写入与50万 QPS 状态上报。
- 混沌演练：Broker 分区故障、网关超时、第三方语音 5xx。

## 18. 丰富例子（>=10）
1. 夜间回家场景：开门后自动开灯并开启空调。
2. 离家模式：门锁上锁后关闭全屋非必要电器。
3. 语音“我要睡觉”：执行卧室灯光+窗帘+空调联动。
4. 温湿度超阈值：自动启动新风并推送告警。
5. 烟雾报警触发：切断燃气阀并高优先级通知家人。
6. 摄像头离线：自动重连3次，失败后派发工单。
7. 设备固件升级失败：回滚到上一稳定版本。
8. 家庭成员权限变更：guest 不可触发门锁相关动作。
9. 网络抖动下重复点击控制：幂等键确保只执行一次。
10. 场景执行部分失败：关键动作成功，非关键动作进入重试队列。
11. 语音平台不可用：降级为本地快捷场景按钮。
12. 大促硬件激活峰值：通过分区扩容与限流稳定接入。

## 19. 面试追问与答法
- 问：为什么要 Digital Twin？
  答：把实时态和历史态分层，既保低延迟读取，也保最终一致修复。
- 问：如何避免“自动化误触发”？
  答：引入防抖窗口、触发条件多信号交叉验证、支持快速熔断规则。
- 问：如何证明恢复能力？
  答：给出阈值、RTO/RPO、回放与对账步骤、演练结果。

## 20. 学习路径
1. 先掌握 MQTT 与设备连接管理。
2. 再掌握幂等、重试、DLQ、补偿回放。
3. 再掌握场景引擎的触发与动作编排。
4. 最后补安全权限与多端语音集成。

## 21. 交付检查清单
- [ ] 是否覆盖设备接入、控制、场景、语音四条主链路。
- [ ] 是否定义关键阈值并绑定告警等级。
- [ ] 是否定义完整故障恢复路径与责任人。
- [ ] 是否明确 RTO/RPO 并可演练验证。
- [ ] 是否给出幂等键、重试上限、降级策略。

## 22. 与母题差异
- 母题：Q60 Design Task Management Application（learningCoreId=60）。
- 共性：状态机、任务编排、权限控制、审计与可观测。
- 差异：
  1. 本题对象是 IoT 设备与家庭空间，不是通用任务实体。
  2. 本题存在设备在线/离线与协议异构问题。
  3. 本题强调实时控制延迟与设备 ACK 收敛。
  4. 本题有语音入口，需要意图映射与失败降级。
  5. 本题场景联动对幂等与去重要求更高。
- 新增必补知识：
  1. MQTT 会话管理与 QoS 取舍。
  2. 设备发现与 Digital Twin 建模。
  3. 场景自动化触发去抖与防误触策略。
  4. 语音集成链路的熔断、降级与回退。
  5. 远程控制在弱网下的重试与幂等设计。
  6. 家居高风险动作的权限分级与二次确认。
