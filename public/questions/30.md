# Q30 评论区设计（Comment System）- 面试高分版

## 1. 三句话题目本质
1. 评论系统核心是“高并发写入 + 低延迟读取 + 可解释排序”。  
2. 难点不是存评论，而是树形回复、热评防刷、审核延迟和热点流量稳定性。  
3. 面试要讲清三条链路：写入发布链路、读取排序链路、审核与风控链路。

## 2. 真实场景故事（问题-方案-结果）
- 问题：热点视频下评论峰值每秒上万，列表查询超时，热评被刷赞污染。  
- 方案：写入走异步削峰，读侧采用根评论游标分页+子评论懒加载，热评分加入风控惩罚；审核采用自动+人工复核。  
- 结果：读取 P95 从 420ms 降到 150ms，热评异常率下降 70%，审核延迟稳定在 30 秒内。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Root Comment | 一级评论 | 每个楼层的起点 |
| Reply | 回复评论 | 挂在 root 或某条评论下 |
| Thread | 评论线程 | 一个 root 及其回复集合 |
| Hot Score | 热度分 | 决定热评排序 |
| Time Decay | 时间衰减 | 旧评论分数会自然下降 |
| Cursor Pagination | 游标分页 | 深分页更稳定 |
| Lazy Load | 懒加载 | 子评论按需拉取 |
| Moderation | 内容审核 | 自动+人工的合规链路 |
| Shadow Ban | 影子封禁 | 发了但别人看不到 |
| Counter Cache | 计数缓存 | 点赞/回复计数快速读 |
| Soft Delete | 软删除 | 逻辑删除可审计可恢复 |
| Anti-Spam | 反刷策略 | 防止机器人刷评论刷赞 |

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 发表评论、回复评论、删除评论。  
2. 点赞/取消点赞，展示点赞数与回复数。  
3. 支持“最新”“最热”排序。  
4. 支持举报与审核结果回写。  
5. 支持@通知与被回复通知。

### 4.2 非功能需求
1. 热点内容高可用。  
2. 读写分离，读延迟低。  
3. 审核策略实时生效。  
4. 行为可追溯（审计）。

### 4.3 不做范围
1. 不做直播弹幕系统。  
2. 不做富文本协同编辑。  
3. 不做复杂社交推荐排序（只做评论域排序）。

### 4.4 SLO/SLA
1. 发评论 P95 < 120ms。  
2. 评论列表读取 P95 < 180ms。  
3. 审核决策延迟 P95 < 60s。  
4. 服务可用性 >= 99.95%。

## 5. 容量估算（含数字推导）
1. 高峰写入：`10k comments/s`。  
2. 读写比：`20:1`，读取峰值可达 `200k qps`。  
3. 单评论 300B，日增 200M 评论，原文约 60GB/天。  
4. 点赞事件峰值 100k/s，必须事件化聚合。  
5. 热点内容前 1% 占 40% 读取流量，需热点隔离。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
Comment API -> Write Service -> Store
Comment API -> Read Service -> Cache/Rank -> Store
```

### 6.2 完整版
```text
Client
  -> Gateway
  -> Comment Write Service (idempotency, anti-spam)
  -> Comment Read Service (root page + reply lazy load)
  -> Rank Service (hot score + risk penalty)
  -> Counter Service (like/reply aggregation)
  -> Moderation Pipeline (rule + model + human review)
  -> Notification Service
  -> Cache Layer (hot content)
  -> Observability + Audit
```

## 7. API设计（请求/响应/错误码/幂等）
1. `POST /api/v1/comments`  
2. `POST /api/v1/comments/{id}/reply`  
3. `GET /api/v1/comments?contentId=&sort=&cursor=&limit=`  
4. `POST /api/v1/comments/{id}/like`  
5. `POST /api/v1/comments/{id}/report`

幂等：
- 写评论、点赞请求带 `Idempotency-Key`。  

错误码：
- `RATE_LIMITED`、`COMMENT_BLOCKED`、`MODERATION_PENDING`、`CURSOR_INVALID`

## 8. 数据模型（核心表/索引）
1. `comment(comment_id, content_id, user_id, parent_id, root_id, text, status, created_at)`  
2. `comment_counter(comment_id, like_count, reply_count, updated_at)`  
3. `comment_rank(comment_id, hot_score, risk_penalty, updated_at)`  
4. `moderation_case(comment_id, verdict, reason, reviewer_id)`  
5. `comment_event(event_id, type, comment_id, user_id, ts)`  
6. 索引：`(content_id, root_id, created_at desc)`、`(root_id, created_at)`、`(content_id, hot_score desc)`

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常链路
创建评论 -> 反刷校验 -> 入库 -> 审核状态写入 -> 异步更新计数与排序 -> 刷新缓存。

### 9.2 高峰链路
热点内容触发限流 -> 写入排队削峰 -> 读侧优先返回 root 评论，子评论延迟加载。

### 9.3 故障恢复链路
Rank 服务故障 -> 降级按时间排序 -> 异步补算热度 -> 服务恢复后回切热评排序。

## 10. 一致性与事务边界
1. 评论正文与状态变更在单事务内。  
2. 点赞/回复计数采用最终一致（事件聚合）。  
3. 软删除后读侧即时过滤，异步清理缓存。  
4. 通知与审核是异步链路，失败重试并可补偿。

## 11. 可用性与容错（含RTO/RPO）
1. 热点内容多级缓存和内容分片隔离。  
2. 写入服务限流+排队，防数据库雪崩。  
3. 审核链路异常时默认“待审核不展示”。  
4. RTO 15 分钟，RPO 5 分钟（依赖事件重放）。

## 12. 可观测性（指标 + 阈值 + 动作）
指标：
- `comment_write_p95_ms`
- `comment_read_p95_ms`
- `moderation_delay_sec`
- `hot_cache_hit_ratio`
- `spam_report_rate`

阈值与动作：
1. `comment_read_p95_ms > 250ms` 持续 10min -> P1，启用降级排序+扩容读集群。  
2. `moderation_delay_sec > 60` 持续 10min -> P1，扩审队列消费者。  
3. `hot_cache_hit_ratio < 75%` -> P2，热点预热和缓存TTL调整。  
4. `spam_report_rate` 激增 3 倍 -> P2，提升风控拦截阈值并人工抽检。

## 13. 安全与合规
1. 评论内容敏感词过滤。  
2. 反刷（设备指纹/IP/频率限制）。  
3. 审核操作审计与可追踪。  
4. 数据删除合规支持（软删+清理策略）。

## 14. 成本与取舍
1. 强实时计数准确但成本高，通常异步聚合。  
2. 热评复杂模型精度更好但算力高。  
3. 子评论一次性拉全体验好但带宽和延迟更差。  
4. 多级缓存省成本但一致性复杂度上升。

## 15. Java关键代码（>=5段）
### 15.1 评论写入与幂等
```java
public class CommentWriteService {
    public long create(CommentReq req) {
        String idem = "cmt:" + req.userId() + ":" + req.clientReqId();
        if (idemRepo.exists(idem)) return idemRepo.getResult(idem);
        antiSpam.check(req.userId(), req.text());
        long id = idGen.nextId();
        commentRepo.insert(id, req);
        eventBus.publish(new CommentCreated(id, req.contentId(), req.userId()));
        idemRepo.save(idem, id);
        return id;
    }
}
```

### 15.2 热评分计算（含时间衰减与风控惩罚）
```java
public class HotScoreService {
    public double score(long like, long reply, long ageSec, double riskPenalty) {
        double engage = Math.log1p(like) + 1.8 * Math.log1p(reply);
        double decay = Math.exp(-Math.max(ageSec, 0) / 86400.0);
        return engage * decay - riskPenalty;
    }
}
```

### 15.3 游标分页（根评论）
```java
public class CursorPager {
    public Page<Comment> pageRoot(long contentId, String cursor, int limit) {
        Cursor c = Cursor.parse(cursor); // createdAt + commentId
        List<Comment> rows = commentRepo.queryRoot(contentId, c.createdAt(), c.commentId(), limit);
        String next = rows.isEmpty() ? "" : Cursor.of(rows.get(rows.size() - 1)).encode();
        return new Page<>(rows, next);
    }
}
```

### 15.4 点赞幂等与计数异步聚合
```java
public class LikeService {
    public void like(long userId, long commentId, String reqId) {
        String key = "like:" + userId + ":" + commentId + ":" + reqId;
        if (idemRepo.exists(key)) return;
        likeRepo.insertIfAbsent(userId, commentId);
        eventBus.publish(new LikeEvent(commentId, 1));
        idemRepo.save(key, 1L);
    }
}
```

### 15.5 审核状态变更与读侧过滤
```java
public class ModerationService {
    public void applyVerdict(long commentId, Verdict v) {
        commentRepo.updateStatus(commentId, v == Verdict.PASS ? "VISIBLE" : "HIDDEN");
        cache.invalidate("comment:list:" + commentRepo.contentId(commentId));
    }

    public boolean visible(Comment c) {
        return "VISIBLE".equals(c.status());
    }
}
```

## 16. 前端功能代码（React JS >=2段，API协作）
### 16.1 评论列表 API 模块（游标分页 + 错误处理）
```javascript
export async function fetchComments({ contentId, sort = "hot", cursor = "", limit = 20 }) {
  try {
    const url = `/api/v1/comments?contentId=${encodeURIComponent(contentId)}&sort=${sort}&cursor=${encodeURIComponent(cursor)}&limit=${limit}`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    return { ok: true, items: data.items || [], nextCursor: data.nextCursor || "", error: "" };
  } catch (e) {
    return { ok: false, items: [], nextCursor: "", error: `拉取失败: ${String(e.message || e)}` };
  }
}

export async function postComment(payload, retry = 0) {
  try {
    const resp = await fetch("/api/v1/comments", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Idempotency-Key": `comment-${Date.now()}`
      },
      body: JSON.stringify(payload)
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, status: "CREATED", error: "" };
  } catch (e) {
    if (retry < 2) return postComment(payload, retry + 1);
    return { ok: false, status: "FAILED", error: `发布失败: ${String(e.message || e)}` };
  }
}
```

### 16.2 审核/举报 API 模块（状态轮询 + 失败分支）
```javascript
export async function reportComment(commentId, reason) {
  try {
    const resp = await fetch(`/api/v1/comments/${commentId}/report`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ reason })
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, status: "REPORTED", error: "" };
  } catch (e) {
    return { ok: false, status: "FAILED", error: `举报失败: ${String(e.message || e)}` };
  }
}

export async function pollModeration(commentId) {
  try {
    const resp = await fetch(`/api/v1/comments/${commentId}`);
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    return { ok: true, moderationStatus: data.status, done: data.status !== "PENDING", error: "" };
  } catch (e) {
    return { ok: false, moderationStatus: "UNKNOWN", done: false, error: `轮询失败: ${String(e.message || e)}` };
  }
}
```

## 17. 测试策略
1. 单测：热评分、游标分页、点赞幂等。  
2. 集成：写评论->审核->展示全链路。  
3. 压测：热点内容读写峰值。  
4. 故障注入：rank服务故障、审核积压、缓存失效。  
5. 回归：排序稳定性、重复评论率、举报处理时效。

## 18. 丰富例子（>=10）
1. 热点视频评论暴涨如何削峰。  
2. 深层回复为什么要懒加载。  
3. 热评被机器人刷赞如何降权。  
4. 软删除后缓存仍显示如何处理。  
5. 审核积压超过阈值如何扩容。  
6. 游标重复数据如何去重。  
7. 点赞接口重复提交如何幂等。  
8. 排序服务宕机后的降级路径。  
9. 举报风暴时如何优先处理高风险内容。  
10. 通知失败如何补偿。  
11. 多语言评论敏感词如何治理。  
12. 回滚审核误判如何恢复展示。

## 19. 面试追问 + 可复述回答
1. 为什么不用 offset 分页？  
可复述：深分页成本高、数据变动会导致重复或漏读，游标分页更稳定。  

2. 热评如何防刷？  
可复述：热评分里引入风险惩罚，并结合行为风控和举报信号。  

3. 树结构怎么建模最稳？  
可复述：`parent_id + root_id` 双字段，读侧分 root 分页、子评论懒加载。

## 20. 新手学习路线
1. 先学评论树建模。  
2. 再学游标分页。  
3. 再学热评排序和防刷。  
4. 最后学审核链路与降级。

## 21. 上场前Checklist
- [ ] 能画出评论写入、读取、审核三条链路。  
- [ ] 能解释热评分公式与风控惩罚。  
- [ ] 能说出至少3个告警阈值和动作。  
- [ ] 能讲清游标分页的必要性。  
- [ ] 能说明与母题的技术差异。

## 22. 与母题差异（对应 Q60）
### 22.1 对应母题
- Q60 Task Management Application

### 22.2 共性能力
1. 列表读写与状态管理。  
2. 通知与异步事件链路。  
3. 权限与审计。  
4. 高并发下的可用性治理。

### 22.3 关键差异（>=5条）
1. Q30 是 UGC 内容系统，Q60 是任务协作系统。  
2. Q30 有树形回复结构，Q60 多是平面任务结构。  
3. Q30 强调热评排序与防刷。  
4. Q60 强调状态机流转与协作权限。  
5. Q30 审核合规链路更关键。

### 22.4 本题新增必补知识（>=5条）
1. 树评论数据模型。  
2. 热评分与时间衰减。  
3. 游标分页与懒加载。  
4. 举报审核闭环。  
5. 点赞幂等与反刷策略。

### 22.5 面试差异话术（3条）
1. “Q30 我会重点讲评论树和热评防刷，不会套任务管理模板。”  
2. “Q60 核心是任务状态机，Q30 核心是UGC排序和审核。”  
3. “Q30 的工程难点在热点治理和内容风控，不在任务编排。”
