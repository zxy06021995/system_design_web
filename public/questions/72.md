# Q72：Data Warehouse（数据仓库）系统设计 - 95分面试版

## 1. 三句话题目本质
1. 数仓的核心不是“存很多数据”，而是“让全公司同一个指标有同一个口径”。  
2. 真正难点在于多源数据不一致、口径频繁变化、历史可追溯和查询性能。  
3. 面试高分关键：分层建模（ODS/DWD/DWS/ADS）、维度与事实设计、指标治理和数据质量闭环。  

## 2. 一个真实场景故事
周一早会，CEO 问“昨天 GMV 到底是多少”。  
财务说 `1.25 亿`，运营说 `1.31 亿`，增长团队说 `1.28 亿`。  
三方都不是瞎报，差异来自口径：
- 财务：剔除退款和取消单
- 运营：按支付成功算，暂不扣退款
- 增长：统计活动页支付转化，口径更窄

老板的要求很直接：
1. 同一指标必须“一处定义，全局复用”。
2. 任何报表数字都要追溯来源和计算逻辑。
3. 口径改动必须版本化、可回滚、可审计。

这就是数仓设计题的业务价值。

## 3. 术语白话表（至少 10 项）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| ODS | 原始层 | “几乎不加工，保留原始数据痕迹” |
| DWD | 明细标准层 | “清洗后可复用的标准明细” |
| DWS | 汇总主题层 | “按主题聚合的中间结果” |
| ADS | 应用指标层 | “给业务看板直接用的指标层” |
| Dimension Table | 维度表 | “描述对象属性，如用户、商品、门店” |
| Fact Table | 事实表 | “记录业务事件，如下单、支付、退款” |
| Grain | 粒度 | “一行数据代表什么最小业务单位” |
| SCD Type 2 | 慢变维二型 | “维度变化保留历史版本” |
| Conformed Dimension | 一致维度 | “多个主题共享同一维度定义” |
| Metric Dictionary | 指标字典 | “指标的唯一口径文档和版本” |
| Data Lineage | 数据血缘 | “指标从哪些表、哪些任务算出来” |
| Backfill | 历史回填 | “修复后重跑历史分区” |
| Partition Pruning | 分区裁剪 | “只扫需要的分区提升查询性能” |
| Late Arriving Data | 迟到数据 | “本应昨天到，今天才到的数据” |
| Semantic Layer | 语义层 | “给 BI/分析统一口径接口” |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 接入订单、支付、用户、营销、客服等多源数据。
- 统一清洗、去重、标准化，并建立维度与事实模型。
- 输出核心业务指标（GMV、订单转化、复购率、客单价等）。
- 支持离线批处理 + 近实时增量刷新。
- 支持指标字典、口径审批、版本管理、血缘追踪。
- 支持 BI 看板查询和自助分析。

### 4.2 非功能需求（SLO 示例）
- T+1 指标准确率：`>= 99.99%`。
- 实时核心指标延迟：`P95 <= 5 分钟`。
- 数仓任务成功率：`>= 99.9%`。
- BI 查询响应：`P95 <= 3s`（常用报表）。
- 口径变更发布可审计率：`100%`。

### 4.3 Out of Scope（首版不做）
- 不做全指标秒级实时化（成本过高）。
- 不做复杂预测建模平台（先做好稳定供数）。
- 不做跨区域强一致查询（先区域内一致）。

## 5. 容量估算（含数字推导）
### 5.1 假设
- 每日订单事件：`2.5B`
- 每日支付事件：`0.9B`
- 每日行为日志：`20B`
- 平均事件大小：`700B`
- 历史保留：`3 年`

### 5.2 数据量估算
- 每日原始数据：`(2.5+0.9+20)B * 700B ≈ 16TB/day`
- 年增量：`~5.8PB/year`（原始层）
- 3 年原始 + 清洗 + 汇总多副本，整体 PB 级起步

### 5.3 查询估算
- 高峰并发 BI 查询：`2,000`
- 常用看板每分钟刷新：`10,000 requests/min`

### 5.4 关键结论
- 必须用列式存储 + 分区 + 预聚合。
- 语义层必须做口径缓存和指标复用，避免每个报表都写复杂 SQL。
- 核心指标与长尾分析需分层服务，避免互相影响。

## 6. 架构（简版 + 完整版）
### 6.1 简版架构
```text
Sources -> ODS -> DWD -> DWS -> ADS -> BI
                    |       |
              Quality/Lineage/Metric Governance
```

### 6.2 完整版架构
```text
[Data Sources]
  -> OLTP DB CDC
  -> App/Event Logs
  -> Payment Gateway
  -> CRM/ERP

[Ingestion]
  -> Kafka / Batch Loader
  -> Schema Registry

[Warehouse Compute]
  -> ODS Load Jobs
  -> DWD Normalize Jobs
  -> DWS Aggregate Jobs
  -> ADS Metric Jobs
  -> Backfill Controller

[Storage]
  -> Data Lake (raw parquet/orc)
  -> Warehouse Engine (Hive/Spark/ClickHouse/Snowflake-like)

[Governance]
  -> Metric Registry
  -> Data Quality Rules
  -> Lineage Graph
  -> Data Catalog + Ownership

[Serving]
  -> Semantic API
  -> BI Dashboard
  -> Ad-hoc Query
```

## 7. API 设计（含请求/响应样例）
### 7.1 指标查询 API（语义层）
`POST /api/v1/metrics/query`

Request:
```json
{
  "metricCode": "GMV_NET",
  "timeRange": {"from": "2026-02-01", "to": "2026-02-24"},
  "dimensions": ["dt", "biz_line"],
  "filters": {"channel": ["app", "web"]}
}
```

Response:
```json
{
  "metricCode": "GMV_NET",
  "definitionVersion": 7,
  "rows": [
    {"dt": "2026-02-24", "biz_line": "retail", "value": 125003210.52}
  ],
  "dataFreshness": "2026-02-24T10:25:00Z"
}
```

### 7.2 指标定义注册 API
`POST /api/v1/metrics/definitions`

Request:
```json
{
  "metricCode": "GMV_NET",
  "name": "净成交额",
  "owner": "finance-data",
  "sqlLogic": "SUM(pay_amount) - SUM(refund_amount)",
  "grain": "day,biz_line",
  "effectiveFrom": "2026-03-01"
}
```

### 7.3 口径审批 API
`POST /api/v1/metrics/{metricCode}/approve`

### 7.4 回填 API
`POST /api/v1/backfill/jobs`

Request:
```json
{
  "dataset": "dwd_order",
  "fromDt": "2026-02-01",
  "toDt": "2026-02-07",
  "reason": "fix duplicate order dedup bug"
}
```

### 7.5 错误码语义
- `409_METRIC_VERSION_CONFLICT`：定义版本冲突。
- `422_INVALID_METRIC_GRAIN`：粒度定义不合法。
- `503_PIPELINE_DELAYED`：数据延迟超阈，返回旧快照。

## 8. 数据模型（核心表/索引）
### 8.1 维度表（SCD2 示例：用户维度）
```sql
CREATE TABLE dim_user_scd2 (
  user_sk BIGINT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  city STRING,
  level STRING,
  valid_from TIMESTAMP NOT NULL,
  valid_to TIMESTAMP NOT NULL,
  is_current BOOLEAN NOT NULL
);
CREATE INDEX idx_dim_user_current ON dim_user_scd2(user_id, is_current);
```

### 8.2 订单事实表（DWD）
```sql
CREATE TABLE dwd_order_fact (
  order_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  item_id BIGINT NOT NULL,
  biz_line STRING NOT NULL,
  pay_amount DECIMAL(18,2) NOT NULL,
  refund_amount DECIMAL(18,2) NOT NULL DEFAULT 0,
  order_status STRING NOT NULL,
  pay_time TIMESTAMP,
  dt DATE NOT NULL,
  PRIMARY KEY(order_id, dt)
) PARTITIONED BY (dt);
```

### 8.3 汇总事实表（DWS）
```sql
CREATE TABLE dws_gmv_day (
  dt DATE NOT NULL,
  biz_line STRING NOT NULL,
  channel STRING NOT NULL,
  gmv_gross DECIMAL(18,2) NOT NULL,
  gmv_net DECIMAL(18,2) NOT NULL,
  paid_order_cnt BIGINT NOT NULL,
  PRIMARY KEY(dt, biz_line, channel)
);
```

### 8.4 指标定义表
```sql
CREATE TABLE metric_definition (
  metric_code VARCHAR(64) NOT NULL,
  version INT NOT NULL,
  name VARCHAR(128) NOT NULL,
  owner VARCHAR(64) NOT NULL,
  grain VARCHAR(128) NOT NULL,
  sql_logic TEXT NOT NULL,
  status VARCHAR(16) NOT NULL, -- DRAFT/APPROVED/DEPRECATED
  effective_from DATE NOT NULL,
  created_at TIMESTAMP NOT NULL,
  PRIMARY KEY(metric_code, version)
);
```

### 8.5 血缘表
```sql
CREATE TABLE lineage_edge (
  edge_id BIGINT PRIMARY KEY,
  upstream_asset VARCHAR(128) NOT NULL,
  transform_job VARCHAR(128) NOT NULL,
  downstream_asset VARCHAR(128) NOT NULL,
  created_at TIMESTAMP NOT NULL
);
```

## 9. 核心流程（至少 3 条）
### 9.1 正常日常供数流程
1. ODS 接收前一天订单、支付、退款原始数据。
2. DWD 统一字段、去重、补全业务主键。
3. DWS 按主题聚合（如日 GMV、渠道转化）。
4. ADS 输出给 BI 主题数据集。
5. 指标服务按定义版本返回统一口径。

### 9.2 高峰流程（大促）
1. 大促当天数据量飙升，ETL 延迟上升。
2. 核心指标链路优先调度，长尾任务延后。
3. 看板优先展示“实时快照 + 延迟标识”。
4. 低峰时自动补齐精确结果。

### 9.3 故障恢复流程（口径 bug）
1. 发现 `GMV_NET` 口径 SQL 漏减某类退款。
2. 修复指标定义版本（v6 -> v7），发审批。
3. 触发历史分区 backfill（受影响日期范围）。
4. 回填完成后自动对比新旧差异并公告变更。

### 9.4 迟到数据流程
1. 支付回执延迟到达（+1 天）。
2. DWD 打迟到标记并写补偿分区。
3. DWS 在重算窗口内补聚合。
4. 指标层更新“最新修正时间”。

## 10. 一致性与事务边界
### 10.1 一致性级别
- 数仓指标通常追求“最终一致 + 可重算收敛”。
- 财务结算口径需 T+1 强校验，不允许长期偏差。

### 10.2 事务边界
- 单个 ETL 任务内可保证原子提交分区。
- 跨层任务靠调度依赖和版本戳保证有序发布。

### 10.3 口径版本化
- 指标变更必须新版本，不覆盖旧版本。
- 报表查询可指定版本或默认最新 approved 版本。

### 10.4 面试可复述
“数仓的‘一致性’不是实时强一致，而是有版本、有追溯、可重算后收敛的一致性。”

## 11. 可用性与容错
### 11.1 常见故障
- 上游缺数导致分区不完整。
- ETL 任务失败导致下游指标缺口。
- 口径变更误发布导致全公司报表偏差。
- BI 查询高峰拖垮集群。

### 11.2 容错策略
- 分区就绪检查（watermark + completeness gate）。
- 关键任务失败自动重试 + 人工兜底。
- 指标定义变更必须审批 + 灰度生效。
- 查询分级：核心看板优先，Ad-hoc 限流。

### 11.3 RTO / RPO
- 核心指标 RTO：`<= 30 分钟`
- 口径修复 RTO：`<= 4 小时`
- 历史回填 RPO：天级范围内可修复

## 12. 可观测性（指标 + 告警阈值）
### 12.1 ETL 指标
- `etl_success_rate`
- `pipeline_delay_min`
- `partition_missing_count`

阈值示例：
- `etl_success_rate < 99%` -> P1
- `pipeline_delay_min > 30` 持续 15 分钟 -> P1

### 12.2 质量指标
- `quality_fail_count`
- `row_count_diff_ratio`
- `null_ratio_by_field`

阈值示例：
- `row_count_diff_ratio > 1%` -> P1
- 核心字段空值率 `> 0.1%` -> P1

### 12.3 指标治理指标
- `metric_definition_unapproved_count`
- `metric_diff_alert_count`
- `lineage_coverage_ratio`

阈值示例：
- `lineage_coverage_ratio < 95%` -> P2
- `metric_diff_alert_count > baseline*2` -> P1

## 13. 安全与权限
- 行级权限：按租户/区域过滤可见数据。
- 列级权限：敏感字段（手机号、身份证）掩码或不可见。
- 指标权限：核心财务指标只对授权角色开放。
- 审计：口径变更、任务重跑、权限调整必须留痕。
- 数据脱敏：开发测试环境自动脱敏或采样子集。

## 14. 成本与取舍
### 14.1 成本构成
- 存储成本（明细 + 汇总 + 历史）。
- 计算成本（ETL + 回填 + 查询）。
- BI 并发成本（交互式分析）。

### 14.2 关键取舍
- 全量实时 vs 分层实时：全量实时成本高且复杂。
- 预聚合多：查询快但存储和更新成本高。
- 分区粒度细：查询快但元数据管理复杂。

### 14.3 降本策略
- 核心指标近实时，长尾指标离线批处理。
- 热数据列式高性能存储，冷数据归档。
- 指标计算复用（公共中间层），避免重复算。

## 15. 关键代码（Java 更细 + 前端功能代码）
### 15.1 Java：指标定义注册与版本控制
```java
public class MetricDefinitionService {
    public MetricDefinition createNewVersion(String metricCode, String sqlLogic, String grain, String owner) {
        MetricDefinition latest = metricRepo.findLatest(metricCode);
        int newVersion = latest == null ? 1 : latest.getVersion() + 1;

        MetricDefinition def = new MetricDefinition(
            metricCode, newVersion, owner, grain, sqlLogic, "DRAFT", LocalDate.now()
        );
        metricRepo.insert(def);
        auditRepo.log("METRIC_DEF_CREATE", metricCode, newVersion, owner);
        return def;
    }

    public void approve(String metricCode, int version, String approver) {
        MetricDefinition def = metricRepo.find(metricCode, version);
        if (!"DRAFT".equals(def.getStatus())) {
            throw new IllegalStateException("only draft can be approved");
        }
        metricRepo.updateStatus(metricCode, version, "APPROVED");
        auditRepo.log("METRIC_DEF_APPROVE", metricCode, version, approver);
    }
}
```

### 15.2 Java：SCD2 维度更新（保留历史）
```java
public class DimUserScd2Service {
    public void upsertUser(long userId, String city, String level, Instant eventTs) {
        DimUser current = dimRepo.findCurrent(userId);
        if (current == null) {
            dimRepo.insertNew(userId, city, level, eventTs, Instant.parse("9999-12-31T00:00:00Z"), true);
            return;
        }
        if (Objects.equals(current.getCity(), city) && Objects.equals(current.getLevel(), level)) {
            return; // 无变化不新增版本
        }
        dimRepo.closeCurrent(userId, eventTs.minusSeconds(1));
        dimRepo.insertNew(userId, city, level, eventTs, Instant.parse("9999-12-31T00:00:00Z"), true);
    }
}
```

### 15.3 Java：数据质量规则执行（行数对账 + 空值率）
```java
public class QualityCheckService {
    public QualityReport runDailyChecks(LocalDate dt) {
        long odsCount = statsRepo.count("ods_order", dt);
        long dwdCount = statsRepo.count("dwd_order_fact", dt);
        double diffRatio = odsCount == 0 ? 0 : Math.abs(odsCount - dwdCount) * 1.0 / odsCount;

        double nullRatio = statsRepo.nullRatio("dwd_order_fact", "order_id", dt);
        boolean pass = diffRatio <= 0.01 && nullRatio <= 0.001;

        QualityReport report = new QualityReport(dt, diffRatio, nullRatio, pass);
        qualityRepo.save(report);
        if (!pass) alertService.raiseP1("warehouse_quality_failed", report.toMap());
        return report;
    }
}
```

### 15.4 Java：历史回填控制器（分区任务编排）
```java
public class BackfillController {
    public BackfillResult backfill(String dataset, LocalDate from, LocalDate to, String reason) {
        int submitted = 0;
        for (LocalDate d = from; !d.isAfter(to); d = d.plusDays(1)) {
            BackfillTask task = new BackfillTask(dataset, d, reason);
            scheduler.submit(task);
            submitted++;
        }
        auditRepo.log("BACKFILL_SUBMIT", dataset, submitted, reason);
        return new BackfillResult(dataset, submitted);
    }
}
```

### 15.5 Java：语义层查询服务（统一口径路由）
```java
public class MetricQueryService {
    public MetricQueryResult query(MetricQueryRequest req) {
        MetricDefinition def = metricRepo.findApprovedLatest(req.getMetricCode());
        if (def == null) throw new IllegalArgumentException("metric not found");

        String sql = sqlBuilder.build(def.getSqlLogic(), req.getTimeRange(), req.getDimensions(), req.getFilters());
        List<Map<String, Object>> rows = warehouseClient.query(sql);

        return new MetricQueryResult(
            req.getMetricCode(),
            def.getVersion(),
            rows,
            freshnessService.currentFreshness(req.getMetricCode())
        );
    }
}
```

### 15.6 前端（React + TypeScript）：指标目录与口径详情页
```tsx
import { useEffect, useState } from "react";

type MetricDef = {
  metricCode: string;
  version: number;
  name: string;
  owner: string;
  grain: string;
  status: string;
};

export function MetricCatalogPage() {
  const [metrics, setMetrics] = useState<MetricDef[]>([]);
  const [selected, setSelected] = useState<MetricDef | null>(null);

  useEffect(() => {
    fetch("/api/v1/metrics/definitions?status=APPROVED")
      .then((r) => r.json())
      .then((d) => setMetrics(d.items || []));
  }, []);

  return (
    <div>
      <h3>指标目录</h3>
      <ul>
        {metrics.map((m) => (
          <li key={`${m.metricCode}_${m.version}`}>
            <button onClick={() => setSelected(m)}>
              {m.metricCode} v{m.version} - {m.name}
            </button>
          </li>
        ))}
      </ul>
      {selected && (
        <div>
          <h4>口径详情</h4>
          <p>指标: {selected.metricCode}</p>
          <p>版本: {selected.version}</p>
          <p>粒度: {selected.grain}</p>
          <p>Owner: {selected.owner}</p>
          <p>状态: {selected.status}</p>
        </div>
      )}
    </div>
  );
}
```

### 15.7 前端（React + TypeScript）：指标查询看板（带延迟提示）
```tsx
import { useState } from "react";

type QueryRow = Record<string, string | number>;

export function MetricQueryPanel() {
  const [metricCode, setMetricCode] = useState("GMV_NET");
  const [from, setFrom] = useState("2026-02-01");
  const [to, setTo] = useState("2026-02-24");
  const [rows, setRows] = useState<QueryRow[]>([]);
  const [freshness, setFreshness] = useState("");
  const [msg, setMsg] = useState("");

  const query = async () => {
    const resp = await fetch("/api/v1/metrics/query", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        metricCode,
        timeRange: { from, to },
        dimensions: ["dt", "biz_line"],
        filters: {}
      })
    });
    if (!resp.ok) {
      setMsg(`查询失败: ${resp.status}`);
      return;
    }
    const data = await resp.json();
    setRows(data.rows || []);
    setFreshness(data.dataFreshness || "");
    setMsg("");
  };

  return (
    <div>
      <h3>指标查询</h3>
      <input value={metricCode} onChange={(e) => setMetricCode(e.target.value)} />
      <input value={from} onChange={(e) => setFrom(e.target.value)} />
      <input value={to} onChange={(e) => setTo(e.target.value)} />
      <button onClick={query}>查询</button>
      {msg && <p>{msg}</p>}
      {freshness && <p>数据新鲜度: {freshness}</p>}
      <pre>{JSON.stringify(rows, null, 2)}</pre>
    </div>
  );
}
```

## 16. 测试策略
### 16.1 单元测试
- 指标 SQL 模板拼接正确性。
- SCD2 更新边界（变更/不变更）。
- 质量规则阈值判断。

### 16.2 集成测试
- ODS -> DWD -> DWS -> ADS 全链路产出一致性。
- 指标版本切换后查询口径正确性。
- 回填任务对历史分区修复能力。

### 16.3 压测
- BI 2k 并发查询压测（热点指标）。
- 大促日批处理窗口压力测试。
- 回填并发执行时资源隔离测试。

### 16.4 故障注入
- 上游缺数/重复数据注入。
- ETL 任务失败重试与告警。
- 指标口径误发布回滚演练。

## 17. 丰富例子（至少 10 个）
1. GMV 是否扣退款口径争议，通过指标字典统一。  
2. 用户城市变更，SCD2 保留历史，历史报表不被污染。  
3. 同一订单重复入库，通过主键去重避免 GMV 虚高。  
4. 大促当天延迟增大，核心指标优先保障。  
5. 迟到支付回执次日到达，触发补算修复昨日报表。  
6. 口径变更审批后生效，旧报表仍可按旧版本回看。  
7. BI 查询超时，自动切换到预聚合表。  
8. 某字段空值率飙升，质量规则立即告警。  
9. 回填 7 天历史分区后，指标误差从 3% 降到 0.2%。  
10. 新业务线接入时复用 conformed dimension 减少重复建设。  
11. 审计日志能追到“谁改了 GMV 口径 SQL”。  
12. 冷数据归档后存储成本下降 35%。  

## 18. 面试追问 + 可复述回答
### Q1：星型和雪花模型怎么选？
可复述：  
“查询性能优先常用星型；维度层级复杂且复用高可考虑雪花。实战里会混用。”

### Q2：口径变化怎么避免全员混乱？
可复述：  
“指标定义版本化 + 审批流 + 生效日期 + 全链路公告，不能直接覆盖旧逻辑。”

### Q3：如何处理迟到数据？
可复述：  
“定义补算窗口和迟到策略，迟到数据进入补偿分区，按规则重算 DWS/ADS。”

### Q4：为什么要分 ODS/DWD/DWS/ADS？
可复述：  
“分层可以隔离责任、提高复用、便于治理和回溯，避免‘一锅粥 SQL’不可维护。”

### Q5：如何证明指标可信？
可复述：  
“有质量校验、有血缘追溯、有口径版本、有审计记录，出现异常能定位和回滚。”

### Q6：实时和离线口径冲突怎么处理？
可复述：  
“实时给快数，离线给准数，设定偏差阈值并自动对账修复。”

## 19. 新手学习路线
### 第 1 周：最小数仓链路
- 跑通 ODS -> DWD -> ADS 一个指标（如 GMV）。
- 理解粒度、维度、事实的基本概念。

### 第 2 周：模型与治理
- 建一个维度 SCD2 + 一个事实表。
- 做指标字典和简单血缘登记。

### 第 3 周：质量与回填
- 上线质量规则（行数、空值率、唯一性）。
- 实现分区回填并验证结果一致。

### 第 4 周：服务化与前端
- 做语义查询 API。
- 做指标目录和查询看板页面。
- 练面试讲解：口径治理与故障修复。

## 20. 上场前 Checklist
- [ ] 我能解释数仓分层为何必要。  
- [ ] 我能讲清维度表与事实表的粒度定义。  
- [ ] 我能说清 SCD2 在什么场景必须用。  
- [ ] 我能说明指标口径如何版本化管理。  
- [ ] 我能给出 3 个质量告警阈值。  
- [ ] 我能描述一次“口径 bug -> 回填修复”的完整流程。  
- [ ] 我能解释实时快数与离线准数如何并存。  
- [ ] 我能展示前端如何查看口径与查询指标。  

## 21. 30 秒总结
数仓系统高分答案是：  
“通过分层建模把原始数据变成可复用数据资产，用指标字典和版本管理统一口径，用质量和血缘保障可信，用回填能力保障可修复。”  
只要你能把这句话落实到表设计、作业链路、告警阈值和前后端功能，你就具备面试里的系统化表达能力。  
