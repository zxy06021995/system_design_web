# Q44 Feature Flag (功能开关)

> 来源校验（questions.ts）  
> `title`: Feature Flag (功能开关)  
> `tags`: 灰度发布, A/B测试, 开关管理, 动态配置, 回滚  
> `keyPoints`: 规则引擎, 实时开关下发, 实验分流, 审计日志, 故障兜底  
> `learningCoreId`: 60（母题：Design Task Management Application）

## 1. 三句话题目本质
1. Feature Flag 题本质是“把发布风险从代码发布转为配置发布”。
2. 难点在于规则正确性、实时生效、回滚速度和误操作控制。
3. 面试高分点是讲清：规则模型、下发链路、评估性能、审计与故障兜底。

## 2. 一个真实场景故事
某支付团队上线“新优惠逻辑”，原本要全量发版。改为功能开关后，先对 1% 用户灰度，发现转化下降 8%，3 分钟内一键回滚，避免了全量损失。后续加入按渠道、地区、设备粒度分流，成为所有高风险功能的标准发布路径。

## 3. 术语白话表（>=10）
1. Flag：功能开关项（开/关或多变体）。
2. Targeting Rule：命中规则（用户属性、设备、地区）。
3. Rollout：灰度放量比例。
4. Variant：实验版本（A/B/n）。
5. Sticky Bucketing：稳定分桶，用户不会频繁变组。
6. Kill Switch：紧急总开关。
7. Config Snapshot：客户端本地配置快照。
8. Evaluation Engine：规则计算引擎。
9. Exposure Event：曝光日志，用于实验分析。
10. Guardrail Metric：护栏指标（错误率、支付成功率）。
11. Blast Radius：故障影响范围。
12. Change Freeze：变更冻结机制。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持开关创建、发布、暂停、回滚。
2. 支持按用户属性与百分比灰度。
3. 支持 A/B 多版本实验分流。
4. 支持实时下发与本地快照兜底。
5. 支持变更审计与审批流。

### 4.2 非功能需求
1. 规则评估低延迟（P95 <= 5ms）。
2. 开关配置高可用（>=99.95%）。
3. 发布可回滚且可追溯。
4. 支持千级开关和万级规则条目。

### 4.3 不做范围
1. 不做完整统计归因平台（仅输出曝光事件）。
2. 不做业务代码自动生成。
3. 不做跨云强一致实时同步。

### 4.4 SLO
1. 配置下发延迟 P95 <= 3s。
2. 评估错误率 <= 0.1%。
3. 紧急回滚生效 P95 <= 10s。

## 5. 容量估算（数字推导）
1. 300 个服务接入，每服务 2000 RPS，总评估 60 万 RPS。
2. 平均每次评估读取 3 条规则，计算压力约 180 万 rule-check/s。
3. 开关总量 5000，平均每个开关 6 条规则，规则总数 3 万。
4. 配置快照 40MB/服务，300 服务约 12GB 分发数据。
5. 曝光日志峰值 12 万条/s，入 Kafka 后保留 7 天。
6. 结论：评估必须本地化，配置走推拉结合，控制中心不能在线承载每次请求。

## 6. 架构（简版+完整版）
### 6.1 简版
`Console -> Flag Control Plane -> SDK Cache -> App`

### 6.2 完整版
1. 管控台：创建规则、审批发布、回滚操作。
2. Control Plane：版本管理、规则编译、配置存储。
3. Distribution：推送通道（SSE/WebSocket）+ 拉取兜底。
4. SDK：本地快照、规则评估、曝光上报。
5. Exposure Pipeline：曝光日志 -> Kafka -> 分析仓库。
6. Guardrail Monitor：指标异常自动触发 kill switch。
7. Audit Service：全量变更与操作留痕。
8. Break-glass：紧急冻结与批量关闭能力。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 创建开关
`POST /api/flag/v1/flags`

### 7.2 发布版本
`POST /api/flag/v1/flags/{flagKey}/publish`

请求：
```json
{
  "version": 17,
  "changeId": "flag-pub-20260224-001",
  "rules": [{"if":"country=US","rollout":10,"variant":"B"}]
}
```

### 7.3 SDK 拉取
`GET /api/flag/v1/snapshots?service=checkout`

错误码：
1. `409_VERSION_CONFLICT`
2. `422_INVALID_RULE`
3. `403_APPROVAL_REQUIRED`
4. `503_DISTRIBUTION_BUSY`

幂等规则：
1. `changeId` 全局唯一，重复发布返回同结果。
2. 同版本禁止覆盖写，必须创建新版本。

## 8. 数据模型（实体/索引/分片）
1. `flag_meta(flag_key, owner, status, created_at)`。
2. `flag_version(flag_key, version, payload, checksum, created_by)`。
3. `flag_publish(change_id, flag_key, version, state, ts)`。
4. `flag_exposure(event_id, flag_key, variant, user_hash, ts)`。
5. `flag_audit(audit_id, actor, action, detail, ts)`。

索引设计：
1. `flag_key + version` 唯一索引。
2. `change_id` 唯一索引（幂等）。
3. `flag_exposure` 按日期分区，按 `flag_key, ts` 建索引。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 开发在 Console 提交规则，审批通过后发布。
2. Control Plane 生成版本快照并推送到 SDK。
3. SDK 本地评估命中规则并返回变体。

### 9.2 高峰流程
1. 大促期间推送风暴，SDK 优先用本地缓存版本。
2. 曝光上报异步批量发送，失败重试不阻塞主请求。
3. 高频评估开关启用预编译表达式降低 CPU 开销。

### 9.3 故障恢复流程
1. 分发通道故障时，SDK 退化为周期拉取。
2. 指标异常触发全局 kill switch。
3. 回滚到上一稳定版本并冻结变更 30 分钟。

## 10. 一致性与事务边界
1. 控制面版本一致性强，数据面（SDK）最终一致。
2. 发布事务边界：版本入库 + 发布记录原子提交。
3. 推送失败不回滚版本，靠重试与拉取补偿。
4. 曝光日志至少一次投递，下游按 `event_id` 去重。
5. 紧急关停优先保证“快速生效”，允许少量短暂不一致。

## 11. 可用性与容错（含 RTO/RPO）
1. 控制面多副本部署，配置存储主从容灾。
2. SDK 本地快照支持离线运行。
3. 发布失败自动回滚到 last-known-good。
4. RTO：控制面故障 10 分钟恢复。
5. RPO：配置版本不丢；曝光日志可秒级补偿。

## 12. 可观测性（指标+阈值+处置动作）
1. `flag_eval_p95_ms` > 5ms（5m）：排查规则复杂度并启用预编译。
2. `push_delivery_success_rate` < 99%：切换拉取模式+重试队列扩容。
3. `rollback_latency_p95` > 10s：检查分发通道健康。
4. `exposure_drop_rate` > 0.5%：开启本地磁盘缓冲与回补任务。
5. `guardrail_error_rate` > 阈值：触发自动 kill switch。
6. `invalid_rule_publish_count` 增长：收紧发布校验与审批门槛。

## 13. 安全与合规
1. 关键开关（支付、风控）发布必须双人审批。
2. 权限最小化：读写分离、按项目隔离。
3. 操作审计不可篡改，支持追责回放。
4. 规则表达式沙箱执行，防注入风险。
5. 用户标识做哈希脱敏上报。

## 14. 成本与取舍
1. 实时推送体验更好，但通道成本高。
2. 规则灵活性越高，评估性能越差。
3. 曝光全量上报分析精度高，但存储成本高。
4. 取舍：核心 flag 全量曝光，普通 flag 抽样。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法/状态转移：发布状态机
```java
public void transitPublishState(String changeId, PublishState from, PublishState to) {
    if (!stateMachine.canTransit(from, to)) {
        throw new IllegalStateException("invalid publish transition");
    }
    publishRepo.updateState(changeId, to.name());
}
```

### 15.2 幂等去重：changeId 防重复发布
```java
public PublishResult publish(PublishRequest req) {
    PublishRecord existing = publishRepo.findByChangeId(req.changeId());
    if (existing != null) return PublishResult.duplicate(existing.version());
    validate(req);
    versionRepo.insert(req.flagKey(), req.version(), req.payload());
    publishRepo.insert(req.changeId(), req.flagKey(), req.version(), "PUBLISHED");
    return PublishResult.ok(req.version());
}
```

### 15.3 重试退避/失败处理：分发重试
```java
public void distributeWithRetry(DistributionTask task) {
    long delay = 100;
    for (int i = 0; i < 4; i++) {
        try {
            distributor.push(task);
            return;
        } catch (RuntimeException ex) {
            if (i == 3) {
                dlqRepo.save(task.changeId(), ex.getMessage());
                throw ex;
            }
            sleep(delay);
            delay = Math.min(delay * 2, 800);
        }
    }
}
```

### 15.4 一致性边界：版本写入与审计同事务
```java
@Transactional
public void saveVersionAndAudit(String flagKey, int version, String payload, String actor) {
    versionRepo.insert(flagKey, version, payload);
    auditRepo.insert(actor, "PUBLISH_VERSION", flagKey + ":" + version);
}
```

### 15.5 观测触发/回滚判定
```java
public void guardrailAutoRollback(String flagKey, int version) {
    double err = metrics.gauge("guardrail_error_rate", flagKey).value();
    if (err > 0.03) {
        rollbackService.rollback(flagKey, version - 1);
        alerting.fire("FLAG_AUTO_ROLLBACK", "flag=" + flagKey + ",v=" + version);
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 发布动作 API（loading/error/done）
```javascript
import { useState } from "react";

export function useFlagPublish() {
  const [state, setState] = useState({ phase: "idle", msg: "", error: "" });

  async function publish(payload) {
    setState({ phase: "loading", msg: "", error: "" });
    try {
      const res = await fetch(`/api/flag/v1/flags/${payload.flagKey}/publish`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      setState({ phase: "done", msg: "publish_ok", error: "" });
    } catch (e) {
      setState({ phase: "error", msg: "", error: String(e.message || e) });
    }
  }

  return { state, publish };
}
```

### 16.2 回滚 API（幂等键 + 重试）
```javascript
export async function rollbackFlag(flagKey, targetVersion) {
  const reqId = `rollback-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 150;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch(`/api/flag/v1/flags/${flagKey}/rollback`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Idempotency-Key": reqId },
        body: JSON.stringify({ targetVersion, changeId: reqId })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 1000);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：规则命中、稳定分桶、状态转移。
2. 集成测试：发布->下发->SDK评估->曝光上报全链路。
3. 压测：60 万 RPS 评估性能与延迟。
4. 故障测试：推送中断、规则错误、回滚失败。
5. 回归测试：护栏指标触发自动回滚准确性。

## 18. 丰富例子（>=10）
1. 新支付页仅对 iOS 10% 用户开启。
2. 某渠道转化下降触发自动回滚。
3. 规则误写导致全量命中，被审批拦截。
4. 推送失败时 SDK 继续用本地快照。
5. 高频开关规则编译后 CPU 降 30%。
6. 曝光日志积压后自动限流低优先级上报。
7. 冻结窗口内禁止高风险 flag 发布。
8. 双人审批避免单点误操作。
9. kill switch 在 5 秒内关闭实验功能。
10. 版本 diff 支持一键对比问题规则。
11. 跨区域延迟升高时切换本地配置源。
12. 回滚事件通过审计可完整追溯。

## 19. 面试追问 + 可复述回答
1. 为什么开关系统会成为稳定性系统？
回答：它直接控制线上行为，误配会立刻放大影响。
2. A/B 分流如何保证稳定？
回答：使用稳定分桶哈希，确保用户长期命中同一变体。
3. 推送和拉取怎么选？
回答：推送保证实时，拉取保证兜底，生产一般混合。
4. 如何防误操作？
回答：审批、变更冻结、护栏指标和自动回滚。
5. 与普通配置中心有什么差别？
回答：Flag 更强调规则评估、实验分流、曝光分析与快速回滚。

## 20. 新手学习路线
1. 先做最小开关：开/关 + 本地缓存。
2. 增加规则引擎与百分比分流。
3. 做版本化发布、回滚、审批。
4. 接曝光事件与护栏指标。
5. 最后补故障演练和自动回滚。

## 21. 上场前 Checklist
1. 能讲清发布、评估、回滚三条链路。
2. 能解释规则复杂度与性能关系。
3. 能给出 3 个以上告警阈值与动作。
4. 能说明 push/pull 混合下发方案。
5. 能清晰对比本题与母题边界。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q60 Design Task Management Application。

### 22.2 共性能力
1. 都是平台型系统，强调权限、流程、审计。
2. 都需要状态机和可观测治理。
3. 都有多角色协作和回滚需求。

### 22.3 关键差异
1. Q60 关注任务协作流程；Q44 关注线上行为控制。
2. Q44 需要毫秒级评估，Q60 通常不需要。
3. Q44 强调实验分流与护栏指标，Q60 强调任务生命周期。
4. Q44 故障影响更即时，需 kill switch。
5. Q44 需要规则引擎与稳定分桶机制。

### 22.4 本题新增知识点（>=5）
1. 稳定分桶算法与变体一致性。
2. 规则表达式编译优化。
3. push/pull 混合下发架构。
4. 护栏指标自动回滚机制。
5. 变更冻结与审批治理。
6. 曝光日志与实验分析闭环。

### 22.5 面试差异话术
“Q60 是通用流程平台题；Q44 是线上发布风险控制题，核心在规则评估、灰度放量、告警联动和秒级回滚。”

---

## 单题自审（Q44）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦功能开关平台，不模板化：通过。
2. 规则分流、实时下发、回滚审计完整：通过。

### D. 工程落地检查
1. 阈值与动作绑定：通过。
2. 含 RTO/RPO 与兜底：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端满足 API/状态流转/重试幂等：通过。

### F. 母题差异检查
1. 与 Q60 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过）
