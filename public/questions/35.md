# Q35 Design Memcached（分布式内存缓存）- 面试高分版

## 1. 三句话题目本质
1. Memcached 的目标是“极低延迟读写”，本质是用内存换数据库压力。  
2. 真正难点不在 get/set，而在热点 key、失效风暴、扩容迁移和一致性边界。  
3. 面试高分要讲清：分片路由、淘汰策略、回源保护、故障降级。

## 2. 真实场景故事（问题-方案-结果）
- 问题：商品详情接口读峰值 200k QPS，数据库被读爆，且缓存同秒过期引发雪崩。  
- 方案：引入 Memcached 分片集群 + 一致性哈希；对热点 key 做单飞与本地短缓存；TTL 加随机抖动。  
- 结果：命中率从 45% 提升到 86%，数据库读QPS下降 70%，高峰期间 P95 稳定在 6ms。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Slab | 按对象大小分桶内存 | 减少内存碎片 |
| LRU | 最近最少使用淘汰 | 内存满时淘汰冷数据 |
| TTL | 过期时间 | 控制新鲜度与回源压力 |
| Cache Miss | 缓存未命中 | 需要回源数据库 |
| Cache Stampede | 击穿风暴 | 大量请求同时回源 |
| Consistent Hash | 一致性哈希 | 扩缩容减少迁移量 |
| CAS | Compare-And-Set | 并发更新保护 |
| Multi-get | 批量读取 | 降低网络往返 |
| Hot Key | 热点键 | 单键流量过高 |
| Eviction | 淘汰 | 内存不足时剔除数据 |
| Warm-up | 预热 | 发布前提前写入热点 |
| Fallback | 降级回源 | 缓存异常时保服务可用 |

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 提供 get/set/delete/incr/decr。  
2. 支持 multi-get。  
3. 支持 CAS 并发更新。  
4. 提供节点扩缩容和统计指标。  
5. 支持热点 key 保护策略。

### 4.2 非功能需求
1. 超低延迟。  
2. 高吞吐。  
3. 可水平扩展。  
4. 节点故障可降级。

### 4.3 不做范围
1. 不做持久化数据库。  
2. 不做复杂事务。  
3. 不做复杂数据结构服务（如 Redis Streams）。

### 4.4 SLO
1. get P95 < 5ms。  
2. set P95 < 8ms。  
3. 缓存服务可用性 >= 99.9%。  
4. 回源突增保护触发时间 < 30s。

## 5. 容量估算（含数字推导）
1. 键值规模：5 亿条，均值 200B -> 约 100GB 纯数据。  
2. 加元数据、slab开销后按 1.5 倍估算，约 150GB。  
3. 读峰值 200k QPS，写峰值 20k QPS。  
4. 热 key 占流量 30%，需要单独保护。  
5. 若命中率跌破 70%，数据库读压力会成倍增长。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
App SDK -> Hash Router -> Memcached Cluster
```

### 6.2 完整版
```text
Client SDK
  -> Hash Ring Router
  -> Memcached Node Pool
  -> SingleFlight Guard
  -> Local Tiny Cache (milliseconds ttl)
  -> Fallback DB Client
  -> Metrics Reporter

Ops
  -> Node Health Checker
  -> Rebalance Controller
  -> Warm-up Job
  -> Alerting
```

## 7. API设计（请求/响应/错误码/幂等）
1. `GET /api/v1/cache/{key}`  
2. `POST /api/v1/cache/{key}`  
3. `DELETE /api/v1/cache/{key}`  
4. `POST /api/v1/cache/cas`

错误码：
- `CACHE_NODE_DOWN`、`CAS_CONFLICT`、`KEY_TOO_LARGE`、`FALLBACK_LIMITED`

幂等：
- set/delete 通过请求幂等键避免重复写放大。

## 8. 数据模型（核心结构）
1. `cache_item(key, value, flags, expire_at)`  
2. `slab_class(class_id, chunk_size, used_chunks, free_chunks)`  
3. `node_stat(node_id, qps, hit_ratio, eviction_rate)`  
4. `hotkey_stat(key, qps, fallback_qps)`  
5. `warm_task(task_id, key, status, ts)`  
6. 路由：一致性哈希环 + 虚拟节点。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常链路
请求 -> hash 路由 -> get 命中直接返回；未命中回源 DB 并 set 回填。

### 9.2 高峰链路
热点 key 未命中 -> singleflight 仅一个请求回源 -> 其余请求等待/降级。

### 9.3 故障恢复链路
节点故障 -> 客户端剔除节点重算路由 -> 回源限流 -> 节点恢复后逐步回切。

## 10. 一致性与事务边界
1. 缓存与数据库是最终一致。  
2. 更新策略可选“先写库后删缓存”或“延迟双删”。  
3. CAS 只保证单 key 并发安全，不保证跨 key 事务。  
4. 关键链路允许短时间旧值读取。

## 11. 可用性与容错（含RTO/RPO）
1. 节点故障快速摘除（客户端感知）。  
2. 回源链路限流防止数据库被打爆。  
3. 随机TTL降低同秒过期风险。  
4. RTO 10 分钟，RPO 可重建（缓存可丢）。

## 12. 可观测性（指标 + 阈值 + 动作）
指标：
- `cache_hit_ratio`
- `eviction_rate`
- `get_p95_ms`
- `hotkey_qps`
- `fallback_qps`

阈值与动作：
1. `cache_hit_ratio < 70%` 持续10分钟 -> P1，触发预热与TTL策略调整。  
2. `get_p95_ms > 20ms` -> P1，排查慢节点并剔除。  
3. `fallback_qps` 超基线 2 倍 -> P1，启动回源限流与降级。  
4. `eviction_rate` 激增 2 倍 -> P2，检查内存不足与热key分布。

## 13. 安全与合规
1. 仅内网访问，禁止公网暴露。  
2. 敏感信息不缓存或加密缓存。  
3. 运维接口鉴权与审计。  
4. 防缓存投毒（key 规范校验）。

## 14. 成本与取舍
1. 更高命中率降低DB成本，但内存成本上升。  
2. 多副本更稳但内存翻倍。  
3. TTL 更短数据更新但回源更高。  
4. 热点保护复杂度上升但能显著提升稳定性。

## 15. Java关键代码（>=5段）
### 15.1 一致性哈希路由（虚拟节点）
```java
public class ConsistentHashRouter {
    private final SortedMap<Integer, String> ring = new TreeMap<>();
    public void addNode(String node, int virtualCount) {
        for (int i = 0; i < virtualCount; i++) {
            ring.put(hash(node + "#" + i), node);
        }
    }
    public String route(String key) {
        if (ring.isEmpty()) throw new IllegalStateException("empty ring");
        int h = hash(key);
        SortedMap<Integer, String> tail = ring.tailMap(h);
        int idx = tail.isEmpty() ? ring.firstKey() : tail.firstKey();
        return ring.get(idx);
    }
    private int hash(String s) { return Math.abs(s.hashCode()); }
}
```

### 15.2 读路径（命中/回源/回填）
```java
public class CacheReadService {
    public String get(String key) {
        String v = memcached.get(key);
        if (v != null) return v;
        return singleFlight.load(key, () -> {
            String db = dbClient.load(key);
            if (db != null) memcached.set(key, db, ttlWithJitter(300));
            return db;
        });
    }
    private int ttlWithJitter(int baseSec) {
        return baseSec + ThreadLocalRandom.current().nextInt(0, 60);
    }
}
```

### 15.3 单飞防击穿
```java
public class SingleFlight {
    private final ConcurrentHashMap<String, CompletableFuture<String>> inflight = new ConcurrentHashMap<>();
    public String load(String key, Supplier<String> loader) {
        CompletableFuture<String> f = inflight.computeIfAbsent(key, k ->
            CompletableFuture.supplyAsync(() -> {
                try { return loader.get(); }
                finally { inflight.remove(k); }
            })
        );
        return f.join();
    }
}
```

### 15.4 CAS 更新
```java
public class CasUpdateService {
    public boolean casUpdate(String key, long token, String newValue, int ttlSec) {
        CasResult r = memcached.cas(key, token, newValue, ttlSec);
        if (r == CasResult.EXISTS) return false; // token过期，需重读后重试
        if (r == CasResult.NOT_FOUND) return false;
        return true;
    }
}
```

### 15.5 慢节点熔断与降级回源
```java
public class NodeGuard {
    public String safeGet(String node, String key) {
        if (circuitBreaker.open(node)) return fallbackGet(key);
        try {
            return client.get(node, key, 5); // 5ms timeout
        } catch (Exception e) {
            circuitBreaker.markFailure(node);
            return fallbackGet(key);
        }
    }
    private String fallbackGet(String key) {
        return fallbackLimiter.allow() ? dbClient.load(key) : null;
    }
}
```

## 16. 前端功能代码（React JS >=2段，API协作）
### 16.1 缓存观测 API 模块（拉取指标 + 失败分支）
```javascript
export async function fetchCacheMetrics() {
  try {
    const resp = await fetch("/api/v1/cache/metrics");
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    return { ok: true, metrics: data.metrics || {}, error: "" };
  } catch (e) {
    return { ok: false, metrics: {}, error: `指标获取失败: ${String(e.message || e)}` };
  }
}

export function startMetricsPolling(onData, onError, intervalMs = 3000) {
  const timer = setInterval(async () => {
    const res = await fetchCacheMetrics();
    if (res.ok) onData(res.metrics);
    else onError(res.error);
  }, intervalMs);
  return () => clearInterval(timer);
}
```

### 16.2 热点 key 治理 API 模块（预热 + 限流配置）
```javascript
export async function triggerWarmup(keys, retry = 0) {
  try {
    const resp = await fetch("/api/v1/cache/warmup", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Idempotency-Key": `warm-${Date.now()}` },
      body: JSON.stringify({ keys })
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, status: "SUBMITTED", error: "" };
  } catch (e) {
    if (retry < 2) return triggerWarmup(keys, retry + 1);
    return { ok: false, status: "FAILED", error: `预热失败: ${String(e.message || e)}` };
  }
}

export async function updateHotKeyPolicy(policy) {
  try {
    const resp = await fetch("/api/v1/cache/hotkey/policy", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(policy)
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, status: "UPDATED", error: "" };
  } catch (e) {
    return { ok: false, status: "FAILED", error: `策略更新失败: ${String(e.message || e)}` };
  }
}
```

## 17. 测试策略
1. 单测：路由一致性、CAS 更新、singleflight。  
2. 集成：命中/未命中回填全链路。  
3. 压测：热点 key、节点故障、TTL集中失效。  
4. 故障演练：节点下线、回源限流触发。  
5. 回归：命中率、回源率、延迟指标趋势。

## 18. 丰富例子（>=10）
1. 热 key 打爆单节点如何拆分。  
2. 同秒过期雪崩如何随机TTL止血。  
3. 扩容后迁移抖动如何平滑。  
4. CAS 冲突频繁怎么处理。  
5. 大 value 导致 slab 浪费如何优化。  
6. 命中率下降如何定位 key 设计问题。  
7. 节点网络抖动导致 P95 上升如何熔断。  
8. 回源限流触发后如何保核心接口。  
9. 预热任务何时触发最有效。  
10. 多级缓存（本地+分布式）边界如何划分。  
11. 发布期间缓存污染如何隔离。  
12. 冷启动时如何避免DB瞬时洪峰。

## 19. 面试追问 + 可复述回答
1. Memcached 和 Redis 怎么选？  
可复述：Memcached 更轻量、更纯缓存，超高吞吐场景成本更低；Redis 功能更丰富。  

2. 怎么防击穿和雪崩？  
可复述：singleflight、随机TTL、热点预热、回源限流四件套。  

3. 一致性怎么讲？  
可复述：缓存是最终一致，关键写路径采用删缓存/双删补偿。

## 20. 新手学习路线
1. 先学缓存命中与回源模型。  
2. 再学一致性哈希和分片。  
3. 再学击穿/雪崩/穿透治理。  
4. 最后学监控阈值和故障演练。

## 21. 上场前 Checklist
- [ ] 能画出读路径（命中/未命中/回填）。  
- [ ] 能解释热点 key 保护策略。  
- [ ] 能给出至少3个告警阈值和动作。  
- [ ] 能讲清 CAS 的作用边界。  
- [ ] 能说明与 Q34 的区别。

## 22. 与母题差异（对应 Q34）
### 22.1 对应母题
- Q34 Design Redis

### 22.2 共性能力
1. 缓存分片与热点治理。  
2. 失效策略与一致性边界。  
3. 可观测与容量规划。  
4. 高可用故障处理。

### 22.3 关键差异（>=5条）
1. Q35 是纯缓存组件题，Q34 是内存数据库平台题。  
2. Q35 重点在简单极致性能（slab/LRU/CAS）。  
3. Q34 还包含丰富数据结构、持久化、复制与集群治理。  
4. Q35 不强调复杂事务语义。  
5. Q35 更偏“读优化与稳定性细节”。

### 22.4 本题新增必补知识（>=5条）
1. Slab 分配机制。  
2. LRU 淘汰行为。  
3. CAS 并发更新模型。  
4. 一致性哈希扩缩容。  
5. 热 key 防护策略。

### 22.5 面试差异话术（3条）
1. “Q35 我会重点讲缓存性能与抗峰值，不展开持久化平台能力。”  
2. “Q34 是能力更全的内存数据库，Q35 是更轻的缓存组件。”  
3. “Q35 高分在细节：路由、淘汰、击穿治理。”
