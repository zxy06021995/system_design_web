# Q86 - Design Music Streaming Service (Spotify)

## 1. 题目元数据（先读 questions.ts）
- 题号：86
- title：Design Music Streaming Service (Spotify)
- tags：音频流、推荐系统、播放列表、DRM、CDN
- keyPoints：音频流传输、DRM保护、推荐算法、播放列表、离线下载
- learningCoreId：未配置（`questions.ts` 中该字段对 Q86 缺省）

## 2. 需求澄清与范围
- 核心：在线播放、搜索、播放列表、收藏、推荐、离线下载、多端同步。
- 非目标：音频制作工具、版权结算财务系统全细节、社交直播。
- 用户对象：普通听众、付费会员、版权方、运营。
- 终端：iOS/Android/Web/车机。

## 3. 功能清单（MVP 到增强）
- MVP：注册登录、曲库浏览、按需播放、播放列表管理、基础推荐。
- 增强：每日推荐、电台模式、歌词、播客、跨设备无缝续播。
- 会员特性：高码率、无广告、离线下载、多设备上限管理。

## 4. 非功能目标与SLA/SLO
- 可用性：核心播放链路月可用性 >= 99.95%。
- 延迟：`play/start` P95 < 300ms（不含首段下载）。
- 首段时间：首包音频 P95 < 800ms（4G/WiFi）。
- 推荐接口：P95 < 200ms，超时降级到缓存推荐。
- 一致性：播放进度最终一致（秒级）；订阅与扣费强一致。

## 5. 容量估算与带宽预算
- DAU：3000万；峰值并发播放：300万。
- 平均码率：160kbps（免费），320kbps（会员高音质）。
- 峰值出口带宽粗估：300万 * 160kbps ≈ 480Gbps（多CDN分摊）。
- 曲库：1亿首，平均压缩后 6MB，冷/热分层存储。
- 事件流：播放埋点峰值 200万 events/s（Kafka 多分区）。

## 6. 高层架构
- Client：播放器 SDK、缓存管理、DRM 模块、重试与回退。
- API Gateway：鉴权、限流、灰度、路由。
- 控制面服务：用户、订阅、目录、搜索、推荐、播放列表。
- 数据面服务：签发播放令牌、CDN URL、分段清单、密钥服务。
- 数据平台：埋点采集、特征计算、召回排序、AB 实验。

## 7. 数据模型设计
- `User(id, tier, region, device_limit, status)`
- `Track(id, album_id, artist_id, duration, codec, loudness, rights_region_set)`
- `Playlist(id, owner_id, is_public, version, updated_at)`
- `PlaylistItem(playlist_id, track_id, pos, added_at)`
- `PlaybackSession(session_id, user_id, device_id, track_id, position_ms, quality, ts)`
- `DownloadLicense(user_id, track_id, expire_at, device_id, key_ref)`

## 8. API 设计
- `POST /v1/play/start`：输入 `trackId/deviceId/qualityHint`，返回 `sessionId/manifestUrl/token`。
- `POST /v1/play/heartbeat`：上报进度，幂等键 `sessionId+seq`。
- `POST /v1/play/end`：结束会话，触发结算事件。
- `POST /v1/playlists/{id}/items`：批量增删，CAS 版本控制。
- `GET /v1/recommendations/home`：可降级到缓存榜单。
- `POST /v1/download/license`：签发离线许可，受设备配额和DRM约束。

## 9. 存储与索引策略
- 元数据：MySQL 分库分表（按 `track_id`、`playlist_id`）。
- 检索：Elasticsearch（曲名/艺人/专辑/拼写纠错）。
- 关系图：Redis + KV 缓存热播放列表与推荐结果。
- 音频文件：对象存储（热层 + 冷层），CDN 回源。
- 事件：Kafka -> Flink -> Feature Store -> OLAP。

## 10. 缓存/CDN/边缘优化
- 多CDN智能调度：按地区、ISP、实时RTT择优。
- 首段预取：清单 + 首2段预热，降低首包时间。
- 热歌分层缓存：边缘常驻 + 区域回源保护。
- 缓存键：`trackId:quality:drmProfile:region`。
- 防击穿：singleflight + 短TTL抖动 + 熔断回退。

## 11. DRM与安全设计
- 鉴权令牌：短时 JWT（1-3分钟）+ 设备绑定 + IP 风险校验。
- DRM：Widevine/FairPlay/PlayReady，多平台适配。
- 密钥服务：KMS 托管主密钥，分环境分租户隔离。
- 防盗链：签名URL、时间窗、Referer/UA 校验。
- 风控：异常并发设备、区域越权、脚本化抓流检测。

## 12. 推荐系统与排序链路
- 召回：协同过滤、内容向量、热门趋势、新歌冷启动。
- 排序：多目标（完播率、跳过率、时长、多样性）。
- 实时反馈：近期行为 5-10 分钟入特征。
- AB 平台：实验隔离、指标看板、自动停劣。
- 降级：模型超时 -> 规则榜单 -> 本地缓存候选。

## 13. 离线下载与多设备同步
- 下载加密：分段加密存储在端侧安全区。
- 许可策略：到期自动失效，订阅取消触发吊销。
- 设备上限：例如最多 5 台，超限需踢旧设备。
- 同步策略：播放进度 LWW（last-write-win）+ 冲突日志。
- 弱网策略：后台续传、断点续下、质量自适应。

## 14. 可观测性、阈值与告警
- RED 指标：请求率、错误率、延迟，按接口和地域分桶。
- 业务阈值：
  - `play/start` 5分钟错误率 > 1.5% 触发 P1。
  - 首包时间 P95 > 1.2s 且持续 10 分钟触发扩容与切 CDN。
  - DRM 授权失败率 > 0.8% 触发密钥服务故障流程。
- 系统阈值：
  - Kafka consumer lag > 120s 触发自动扩消费者。
  - DB CPU > 75% 持续 15 分钟触发读流量降级。
- 看板：播放成功率、卡顿率、平均码率、推荐点击率、下载成功率。

## 15. Java 实现要点（>=5 代码块）
```java
public final class IdempotencyGuard {
    private final ConcurrentHashMap<String, Long> seen = new ConcurrentHashMap<>();
    private final long ttlMs = 5 * 60_000L;

    public boolean firstSeen(String key, long nowMs) {
        cleanup(nowMs);
        return seen.putIfAbsent(key, nowMs) == null;
    }

    private void cleanup(long nowMs) {
        for (Map.Entry<String, Long> e : seen.entrySet()) {
            if (nowMs - e.getValue() > ttlMs) {
                seen.remove(e.getKey(), e.getValue());
            }
        }
    }
}
```

```java
public class PlaybackTokenService {
    public String issueToken(long userId, long trackId, String deviceId, long nowEpochSec) {
        long exp = nowEpochSec + 120;
        String payload = userId + ":" + trackId + ":" + deviceId + ":" + exp;
        String sig = hmacSha256(payload, "play-secret-v1");
        return Base64.getUrlEncoder().withoutPadding().encodeToString((payload + "." + sig).getBytes());
    }

    private String hmacSha256(String data, String secret) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(secret.getBytes(), "HmacSHA256"));
            return HexFormat.of().formatHex(mac.doFinal(data.getBytes()));
        } catch (Exception ex) {
            throw new IllegalStateException("sign failed: " + ex.getMessage());
        }
    }
}
```

```java
public class RetryExecutor {
    public <T> T execute(Callable<T> task, int maxAttempts, long baseBackoffMs) throws Exception {
        Exception last = null;
        for (int i = 1; i <= maxAttempts; i++) {
            try {
                return task.call();
            } catch (Exception ex) {
                last = ex;
                if (i < maxAttempts) {
                    long sleep = (long) (baseBackoffMs * Math.pow(2, i - 1));
                    Thread.sleep(Math.min(sleep, 1500));
                }
            }
        }
        throw new RuntimeException("all retries failed", last);
    }
}
```

```java
public class PlaylistVersionService {
    private final Map<Long, Integer> versionMap = new ConcurrentHashMap<>();

    public synchronized boolean applyUpdate(long playlistId, int expectedVersion) {
        int current = versionMap.getOrDefault(playlistId, 0);
        if (current != expectedVersion) return false;
        versionMap.put(playlistId, current + 1);
        return true;
    }

    public int currentVersion(long playlistId) {
        return versionMap.getOrDefault(playlistId, 0);
    }
}
```

```java
public class CircuitBreaker {
    private final int failureThreshold;
    private final long openMs;
    private int failures = 0;
    private long openUntil = 0;

    public CircuitBreaker(int failureThreshold, long openMs) {
        this.failureThreshold = failureThreshold;
        this.openMs = openMs;
    }

    public synchronized <T> T call(Callable<T> primary, Supplier<T> fallback) {
        long now = System.currentTimeMillis();
        if (now < openUntil) return fallback.get();
        try {
            T result = primary.call();
            failures = 0;
            return result;
        } catch (Exception ex) {
            failures++;
            if (failures >= failureThreshold) openUntil = now + openMs;
            return fallback.get();
        }
    }
}
```

## 16. React 前端实现要点（>=2 代码块）
```javascript
import { useEffect, useRef, useState } from "react";

export function usePlaybackStart(trackId) {
  const [state, setState] = useState({ loading: false, error: null, done: false, data: null });
  const retryRef = useRef(0);

  async function start() {
    setState({ loading: true, error: null, done: false, data: null });
    try {
      const idempotencyKey = `${trackId}-${Date.now()}`;
      const res = await fetch("/v1/play/start", {
        method: "POST",
        headers: { "Content-Type": "application/json", "Idempotency-Key": idempotencyKey },
        body: JSON.stringify({ trackId, qualityHint: "auto" })
      });
      if (!res.ok) throw new Error(`start failed: ${res.status}`);
      const data = await res.json();
      setState({ loading: false, error: null, done: true, data });
    } catch (e) {
      if (retryRef.current < 2) {
        retryRef.current += 1;
        setTimeout(start, 300 * retryRef.current);
      } else {
        setState({ loading: false, error: String(e), done: false, data: null });
      }
    }
  }

  return { ...state, start };
}
```

```jsx
import React, { useEffect, useState } from "react";

export function ProgressHeartbeat({ sessionId, positionMs }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [done, setDone] = useState(false);

  useEffect(() => {
    if (!sessionId) return;
    let stop = false;
    const timer = setInterval(async () => {
      if (stop) return;
      setLoading(true);
      setError(null);
      try {
        const res = await fetch("/v1/play/heartbeat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sessionId, positionMs, ts: Date.now() })
        });
        if (!res.ok) throw new Error(`heartbeat ${res.status}`);
        setDone(true);
      } catch (e) {
        setError(String(e));
      } finally {
        setLoading(false);
      }
    }, 5000); // 轮询上报

    return () => {
      stop = true;
      clearInterval(timer);
    };
  }, [sessionId, positionMs]);

  if (loading) return <div>syncing...</div>;
  if (error) return <div>degraded mode: local queue enabled, error={error}</div>;
  if (done) return <div>synced</div>;
  return <div>idle</div>;
}
```

## 17. 一致性、事务与幂等
- 播放开始与心跳：最终一致，允许秒级延迟。
- 订阅扣费与权限开通：强一致，事务外发事件走 outbox。
- 幂等：
  - `play/start` 使用 `Idempotency-Key`。
  - `heartbeat` 使用 `sessionId+seq/ts` 去重。
  - `playlist update` 使用版本号 CAS。
- 去重窗口：5分钟内重复请求只记一次业务写。

## 18. 丰富例子（>=10）
1. 用户点播热门歌曲，首包 450ms，命中边缘缓存成功播放。  
2. 某地域 CDN 抖动，网关切换次优 CDN，首包从 700ms 回落到 520ms。  
3. DRM license 服务瞬时超时，客户端重试 2 次后成功拿到许可。  
4. 用户在地铁弱网，播放器从 320kbps 自动降到 96kbps 保持不断流。  
5. 播放列表并发编辑冲突，CAS 失败方拉取新版本后重放变更。  
6. 推荐服务 P95 超 200ms，触发降级返回缓存榜单，页面可用。  
7. 离线下载许可证过期，客户端提示续订并刷新许可。  
8. 用户超出设备上限，第6台登录被拒并引导解绑旧设备。  
9. 埋点队列积压 3 分钟，自动扩容消费者后 lag 恢复到 20 秒。  
10. 版权区域限制命中，返回不可播放并推荐可替代曲目。  
11. 数据库主库故障，读流量切只读副本，写入进入补偿队列。  
12. 推荐模型发布后 CTR 下滑，AB 平台自动回滚至上一版本。  

## 19. 故障恢复路径（含RTO/RPO）
- 故障场景A：单区域 API 集群不可用。
  - 恢复路径：GSLB 切流 -> 只读模式 -> 重建写服务 -> 回放 outbox。
  - 目标：RTO <= 15 分钟，RPO <= 1 分钟（依赖跨区日志复制）。
- 故障场景B：主数据库不可用。
  - 恢复路径：提升只读副本为主 -> 应用连接串切换 -> 校验 GTID -> 补偿重放。
  - 目标：RTO <= 10 分钟，RPO <= 30 秒。
- 故障场景C：推荐链路大面积超时。
  - 恢复路径：熔断模型服务 -> 降级规则榜单 -> 限流非关键接口 -> 逐步恢复。
  - 目标：RTO <= 5 分钟，RPO 不适用（可重算）。
- 故障演练：每月一次 region failover，验证 runbook 与自动化脚本。

## 20. 成本与扩展策略
- 成本大头：CDN 流量费、对象存储、推荐算力、日志分析。
- 优化：
  - 热歌缓存提升命中，降低回源与出口成本。
  - 音质策略按网络动态选档。
  - 冷门曲目延迟加载与冷存储归档。
- 扩展：按地域/租户拆分服务集群，统一控制面。

## 21. 评审清单与打分
- 需求覆盖（功能+非功能）：20/20
- 架构完整性（控制面+数据面）：20/20
- 可靠性（阈值+告警+恢复+RTO/RPO）：20/20
- 一致性与幂等：18/20
- 工程落地（Java/React/可观测性）：20/20
- 总分：98/100

## 22. 与母题差异
- 相比通用“视频流媒体”母题，本题更强调音频低带宽、版权限制、推荐留存和离线许可管理。
- 与“纯 CDN 下载系统”不同，本题需要会话级播放控制、进度同步和多端一致体验。
- 与“推荐系统母题”不同，本题必须把推荐结果直接绑定播放可用性（版权、地区、设备、DRM）。
- 新增必补知识：
  1. 音频编码与自适应码率策略（AAC/Opus、切档策略）。
  2. DRM 多生态实现差异（Widevine/FairPlay/PlayReady）。
  3. 离线下载许可证生命周期与吊销机制。
  4. 多CDN调度与边缘缓存键设计。
  5. 播放埋点到推荐特征的近实时链路（Kafka/Flink/Feature Store）。
  6. 跨设备续播冲突处理（LWW + 审计日志）。
  7. 版权区域限制与替代内容推荐策略。
