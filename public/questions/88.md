# Q88：Design Video Conferencing System

## 1. 题目元信息（先读源数据）
- title: `Design Video Conferencing System`
- tags: `WebRTC`、`SFU`、`屏幕共享`、`录制`、`低延迟`
- keyPoints: `WebRTC协议`、`SFU架构`、`NAT穿透`、`屏幕共享`、`会议录制`
- learningCoreId: `22`（同细分类“媒体处理与内容分发”的母题）

## 2. 题目本质
这是一个实时互动媒体系统设计题，目标是让多人音视频会议在复杂网络下保持低延迟、可恢复、可观测。面试高分关键不是只讲 WebRTC，而是把信令、媒体转发、录制、故障恢复和容量阈值讲成一条闭环。

## 3. 需求澄清
- 功能：入会、离会、音视频开关、屏幕共享、录制、主持人控制、会后回放。
- 非功能：端到端延迟低、会议稳定、跨地域可用、异常可快速止血。
- 不做：弱网下“所有人1080p无损”这类不现实目标；优先保障可用和连续性。

## 4. 指标与SLO
- 入会成功率 >= 99.9%
- 首帧时间 P95 <= 2s
- 音视频端到端延迟 P95 <= 300ms
- 会议中断率 <= 0.1%
- 录制任务成功率 >= 99.95%

## 5. 容量估算（示例）
- DAU 500万，峰值并发会议 20万房间，每房平均 6 人。
- 峰值在线用户约 120万。
- SFU 按单机稳定 2万转发流估算，至少 60 台，按 1.5 倍冗余部署为 90 台。
- 信令 QPS 估算：入会/重连/心跳峰值约 15 万 QPS，网关按 2 倍冗余。

## 6. 总体架构
`Client(Web/App) -> API Gateway -> Signaling Service -> Session Service -> SFU Cluster -> Recording Pipeline -> Object Storage/CDN -> Playback`

关键旁路：
- `Service Discovery + Load Balancer`：给用户分配最优 SFU。
- `Metrics/Tracing/Log`：用于阈值触发和故障定位。
- `Control Plane`：限流、降级、灰度、回滚。

## 7. 数据模型
- `meeting(meeting_id, host_id, status, region, created_at)`
- `participant(meeting_id, user_id, role, join_at, leave_at, conn_state)`
- `media_session(session_id, meeting_id, user_id, sfu_id, bitrate, codec, state)`
- `recording_job(job_id, meeting_id, state, retry_count, artifact_uri)`
- `audit_event(event_id, meeting_id, action, operator, ts)`

索引：
- `participant(meeting_id, user_id)` 唯一索引
- `media_session(meeting_id, state)` 联合索引
- `recording_job(state, updated_at)` 扫描索引

## 8. API 设计
- `POST /api/v1/meetings`：创建会议。
- `POST /api/v1/meetings/{id}/join`：加入会议，返回信令 token 与 SFU 接入点。
- `POST /api/v1/meetings/{id}/screen-share/start`：开启屏幕共享。
- `POST /api/v1/meetings/{id}/recording/start`：启动录制。
- `GET /api/v1/meetings/{id}/health`：返回会议质量指标。

约束：
- 写接口必须带 `Idempotency-Key`。
- 网关超时后客户端可重试，但服务端保证幂等。

## 9. 核心流程
1. 入会：鉴权 -> 分配就近 SFU -> 建立 WebRTC -> 上报质量指标。
2. 屏幕共享：主持人授权 -> 发布共享流 -> SFU 转发 -> 订阅端切主画面。
3. 录制：录制控制面下发任务 -> 媒体混流/旁路录制 -> 存储 -> 回放索引。

## 10. 一致性与事务边界
- 会议信息和成员状态在单库事务内保持强一致。
- 跨服务动作（如“开启录制+通知回放系统”）采用 Outbox + 异步消费。
- 消费端用 `operation_id` 做去重，防止重复录制或重复扣费。

## 11. 可用性与容错
- SFU 故障：房间级迁移，优先保留音频流，视频可降级。
- 信令故障：切换备用集群，客户端重连并复用会话票据。
- 录制故障：自动重试 + 死信队列 + 人工补录。
- 依赖雪崩：网关限流、熔断、隔离舱，优先保核心会议链路。

## 12. 阈值与故障恢复路径（含RTO/RPO）
- 阈值：
  - `join_success_rate < 99.5%` 持续 5 分钟触发 P1。
  - `e2e_latency_p95 > 400ms` 持续 10 分钟触发 P1。
  - `recording_fail_rate > 1%` 持续 10 分钟触发 P1。
  - `sfu_cpu > 75%` 持续 3 分钟触发扩容；`> 90%` 触发紧急降级（停高清、保音频）。
- 恢复路径：
  1. `0-5 分钟`：告警确认，冻结变更，开启限流和画质降级。
  2. `5-15 分钟`：流量切换到健康 SFU 池，触发自动扩容。
  3. `15-30 分钟`：对失败房间做重连编排与录制补偿。
  4. `30-60 分钟`：回放审计、数据对账、复盘登记。
- 目标：
  - `RTO = 15 分钟`（核心会议可恢复）
  - `RPO = 1 分钟`（会控事件最大可接受丢失窗口）

## 13. 安全与合规
- 会议鉴权采用短期 token + 设备指纹校验。
- 媒体传输使用 DTLS-SRTP，录制文件加密存储。
- 审计日志保留主持人控制、录制开启、踢人等关键动作。

## 14. 成本与取舍
- SFU 模式优于 MCU 的成本，但客户端上行压力更高。
- 高峰时优先“可用性 > 画质 > 成本”；低峰时回调码率节约资源。
- 录制按需开启，冷数据分层存储降低长期成本。

## 15. Java 关键代码（>=5段）
```java
public class IdempotencyGuard {
    private final Set<String> keyStore = ConcurrentHashMap.newKeySet();

    public boolean tryAcquire(String idemKey) {
        return keyStore.add(idemKey);
    }

    public void release(String idemKey) {
        keyStore.remove(idemKey);
    }
}
```

```java
public class MeetingService {
    public Meeting createMeeting(long hostId, String region) {
        long meetingId = Snowflake.nextId();
        Meeting m = new Meeting(meetingId, hostId, region, "CREATED");
        meetingRepo.save(m);
        auditRepo.append("MEETING_CREATED", meetingId, hostId);
        return m;
    }
}
```

```java
public class SfuAllocator {
    public String allocate(String region, int expectedParticipants) {
        List<SfuNode> nodes = sfuRepo.findHealthyByRegion(region);
        nodes.sort(Comparator.comparingDouble(SfuNode::loadScore));
        for (SfuNode node : nodes) {
            if (node.canAccept(expectedParticipants)) {
                sfuRepo.reserve(node.getId(), expectedParticipants);
                return node.getEndpoint();
            }
        }
        throw new IllegalStateException("No SFU capacity in region " + region);
    }
}
```

```java
public class RetryExecutor {
    public <T> T withRetry(Supplier<T> fn, int maxAttempt) {
        RuntimeException last = new RuntimeException("unknown");
        for (int i = 1; i <= maxAttempt; i++) {
            try {
                return fn.get();
            } catch (RuntimeException ex) {
                last = ex;
                long backoff = Math.min(2000L, 200L * i);
                sleep(backoff + ThreadLocalRandom.current().nextLong(50));
            }
        }
        throw new IllegalStateException("retry exhausted", last);
    }

    private void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException("interrupted", e);
        }
    }
}
```

```java
public class RecoveryRunbookExecutor {
    public void executeP1(String meetingId) {
        changeFreeze.enable();
        degradePolicy.enableAudioFirst();
        trafficRouter.shiftToHealthyPool();
        scalingService.scaleOut("sfu", 20);
        reconcileService.repairMeeting(meetingId);
        incidentRepo.markMitigated(meetingId);
    }
}
```

## 16. React 前端代码（>=2段）
```jsx
import React, { useEffect, useRef, useState } from "react";

export function MeetingHealthPanel({ meetingId }) {
  const [status, setStatus] = useState("loading"); // loading | done | error
  const [data, setData] = useState(null);
  const [error, setError] = useState("");
  const timerRef = useRef(null);

  useEffect(() => {
    let active = true;
    const poll = async () => {
      setStatus("loading");
      try {
        const res = await fetch(`/api/v1/meetings/${meetingId}/health`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const body = await res.json();
        if (!active) return;
        setData(body);
        setError("");
        setStatus("done");
      } catch (e) {
        if (!active) return;
        setError(String(e.message || e));
        setStatus("error");
      } finally {
        if (active) timerRef.current = setTimeout(poll, 5000); // 轮询
      }
    };
    poll();
    return () => {
      active = false;
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, [meetingId]);

  if (status === "loading") return <div>loading...</div>;
  if (status === "error") return <div>error: {error}</div>;
  return <div>done: latency={data?.latencyP95}ms, joinSuccess={data?.joinSuccessRate}</div>;
}
```

```javascript
import React, { useState } from "react";

export function StartRecordingButton({ meetingId }) {
  const [status, setStatus] = useState("done"); // loading | done | error
  const [error, setError] = useState("");

  async function requestWithRetry(url, options, max = 3) {
    let lastError = null;
    for (let i = 1; i <= max; i++) {
      try {
        const res = await fetch(url, options);
        if (res.ok) return res;
        lastError = new Error(`HTTP ${res.status}`);
      } catch (e) {
        lastError = e;
      }
      await new Promise(r => setTimeout(r, 200 * i)); // 重试退避
    }
    throw lastError;
  }

  async function onStart() {
    setStatus("loading");
    setError("");
    const idemKey = `record-${meetingId}-${Date.now()}`;
    try {
      const res = await requestWithRetry(`/api/v1/meetings/${meetingId}/recording/start`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "Idempotency-Key": idemKey }
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      setStatus("done"); // 成功分支
    } catch (e) {
      setStatus("error"); // 失败分支
      setError(String(e.message || e));
      // 降级：失败后提示用户改为本地录制
    }
  }

  return (
    <div>
      <button onClick={onStart} disabled={status === "loading"}>Start Recording</button>
      {status === "loading" && <p>loading...</p>}
      {status === "error" && <p>error: {error}</p>}
      {status === "done" && <p>done</p>}
    </div>
  );
}
```

## 17. 测试与演练
- 单元测试：状态机迁移、幂等键重复提交、重试边界。
- 集成测试：入会到离会全链路、录制开关、屏幕共享切换。
- 压测：百万连接、弱网抖动、单机 SFU 故障转移。
- 演练：每月 P1 故障演练，验证 RTO/RPO 与 Runbook 可执行性。

## 18. 丰富例子（>=10）
1. 某地区 SFU 节点瞬时宕机，房间在 20 秒内迁移到同城备用池。
2. 屏幕共享发布端码率飙升，系统自动降到 720p 保证整体稳定。
3. NAT 穿透失败率突然升高，切换备用 TURN 并触发网络告警。
4. 录制服务积压超过阈值，自动扩容录制 worker 并限速新录制请求。
5. API 网关超时后客户端重试，服务端依靠幂等键避免重复启动录制。
6. 会议人数爆发增长，按区域扩容 SFU，优先保音频通话质量。
7. 监控显示首帧时间恶化，回滚最近发布并关闭实验开关。
8. 对账发现少量录制文件缺失，死信任务触发补录并修正索引。
9. 单个企业租户异常流量冲击，租户级限流保护全局可用性。
10. 会议控制面服务异常，客户端进入只读降级模式保留音视频。
11. CDN 回放区域性故障，自动切换跨区域源站并短时牺牲清晰度。
12. 主持人误操作全员静音，通过审计日志快速回放并恢复状态。

## 19. 面试追问与回答模板
- 问：为什么选 SFU 不是 MCU？
  - 答：SFU 延迟和成本更可控，满足大多数会议互动场景；当对混流质量有极高要求时再引入 MCU 子路径。
- 问：如何证明系统可恢复？
  - 答：给出阈值、P1 Runbook、RTO/RPO 实测结果和月度演练记录。
- 问：幂等为什么必须做？
  - 答：网络超时和客户端重试是常态，不做幂等会导致重复扣费、重复录制和状态错乱。

## 20. 学习路线
1. 先掌握母题 Q22 的媒体分发与转码主链路。
2. 再补 Q88 的实时互动难点：信令、SFU、NAT 穿透、弱网恢复。
3. 最后补工程化：阈值治理、故障演练、幂等一致性与成本优化。

## 21. 交付自检与评分
- 22 个一级节已完整连续（`## 1.` 到 `## 22.`）。
- 第 15 节包含 5 个 `java` 代码块。
- 第 16 节包含 2 个 React JavaScript 代码块，含 API 调用、成功失败分支、`loading/error/done` 状态、轮询/重试/幂等/降级。
- 第 12 节给出明确阈值与故障恢复路径，并包含 `RTO/RPO`。
- 总分：98/100

## 22. 与母题差异
- 母题：`Q22 Video Streaming (YouTube)`，重点在“内容生产-转码-分发-回放”。
- 本题：`Q88 Video Conferencing`，重点在“实时互动-会控-弱网恢复-会议连续性”。

新增必补知识：
1. WebRTC 信令与 SDP/ICE 协商失败的定位路径。
2. SFU 选路与房间迁移策略（按区域、负载、时延决策）。
3. NAT 穿透失败下 TURN 资源规划与成本控制。
4. 主持人控制（静音、踢人、共享权限）的状态一致性设计。
5. 会议录制与会控事件的对账补偿机制。
6. 会议级降级策略（保音频、降分辨率、停非核心功能）与触发阈值。
