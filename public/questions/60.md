# Q60：Task Management Application（任务管理系统）- 95分面试版

## 1. 三句话题目本质
1. 任务管理系统本质不是“增删改查页面”，而是“多人协作下的状态机系统”。  
2. 真正难点是并发修改、权限边界、通知链路、搜索一致性和审计追溯。  
3. 面试高分关键：讲清任务生命周期、角色权限矩阵、异步事件（通知/索引）和故障降级。  

## 2. 一个真实场景故事
一个项目里有 5 类角色：产品、研发、测试、项目经理、外部客户。  
同一个任务在 10 分钟内发生了这些操作：
- 产品把优先级从 `P2` 改成 `P0`
- 研发把状态从 `TODO` 改成 `IN_PROGRESS`
- 测试加了“阻塞”标签并 @项目经理
- PM 把截止时间提前到今晚

如果系统设计不好，会出现：
- 后提交覆盖先提交（丢更新）
- 外部客户看到了不该看的内部字段（越权）
- 搜索里还是旧状态（异步延迟无感知）

任务系统要解决的就是这类“协作复杂性”，不是单纯表单系统。

## 3. 术语白话表（至少 10 项）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Backlog | 待办池 | “还没开始但要做的任务集合” |
| Kanban | 看板 | “按状态分列展示任务” |
| Workflow | 工作流 | “任务状态能怎么走、谁能走” |
| Transition | 状态迁移 | “从一个状态跳到另一个状态” |
| Assignee | 负责人 | “当前谁来处理这个任务” |
| Watcher | 关注人 | “任务变更时要通知的人” |
| SLA | 服务时限 | “多久要响应、多久要完成” |
| Optimistic Lock | 乐观锁 | “用版本号避免并发覆盖” |
| Soft Delete | 软删除 | “逻辑删除，可恢复可审计” |
| Outbox | 事务外发箱 | “主事务成功后异步发事件，防双写不一致” |
| ACL | 访问控制列表 | “精确到项目或任务级权限” |
| Audit Trail | 审计轨迹 | “谁在什么时候改了什么” |
| Search Index Lag | 搜索索引延迟 | “列表和搜索出现短暂不一致” |
| Mention | @提及 | “评论里点名某人触发通知” |
| Burn-down | 燃尽统计 | “剩余工作量随时间变化” |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 任务创建、编辑、状态流转、批量操作。
- 看板视图、列表视图、筛选和全文搜索。
- 评论、附件、@提及、关注人通知。
- 任务依赖（阻塞关系）和子任务。
- 审计日志、变更历史、软删除恢复。
- 支持多项目、多团队、多租户。

### 4.2 非功能需求（SLO 示例）
- 读取延迟：`任务列表 P95 <= 250ms`。
- 写入延迟：`任务更新 P95 <= 200ms`。
- 可用性：`>= 99.95%`。
- 通知送达延迟：`P95 <= 10s`。
- 搜索索引延迟：`P95 <= 30s`。

### 4.3 Out of Scope（首版不做）
- 不做复杂甘特图排期引擎。
- 不做实时协同富文本编辑（先评论级别协作）。
- 不做自动资源排班算法（先人工排期）。

## 5. 容量估算（含数字推导）
### 5.1 假设
- 总租户：`50,000`
- 总任务量：`80,000,000`
- 活跃任务：`12,000,000`
- 日任务变更：`40,000,000`
- 日评论：`10,000,000`
- 日查询请求：`3,000,000,000`

### 5.2 QPS 估算
- 平均查询 QPS：`3B / 86400 ≈ 34,722`
- 峰值查询（6x）：`~208,000`
- 平均写 QPS（变更+评论）：`50M / 86400 ≈ 579`
- 峰值写 QPS（5x）：`~2,900`

### 5.3 存储估算
- 任务主表平均 1KB：`80M ≈ 80GB`
- 审计记录按每任务 20 次变更、每条 600B：`80M*20*600B ≈ 960GB`
- 评论按 10M/day、每条 500B：`~5GB/day`

### 5.4 关键结论
- 读多写少，查询层需缓存 + 索引优化。
- 审计日志体量大，必须冷热分层。
- 搜索与主库异步是必要取舍，要接受秒级索引延迟。

## 6. 架构（简版 + 完整版）
### 6.1 简版架构
```text
Web/Mobile -> API -> Task Service -> DB
                      -> Event Bus -> Notification / Search Index / Audit
```

### 6.2 完整版架构
```text
[Client Web/Mobile]
  -> [API Gateway]
  -> [Auth Service + RBAC/ACL]
  -> [Task Command Service] (write path)
  -> [Task Query Service] (read path)
  -> [Comment Service]
  -> [Attachment Service]
  -> [Workflow Engine]
  -> [Outbox Publisher]
  -> [Event Bus (Kafka)]
      -> [Notification Service]
      -> [Search Indexer (ES/OpenSearch)]
      -> [Audit Service]
      -> [Metrics Aggregator]
  -> [Task DB + Comment DB + Audit DB]
  -> [Cache Layer (Redis)]
```

### 6.3 设计要点
- 写模型和读模型分离（CQRS 轻量化），优化读性能。
- 事件驱动异步更新搜索和通知，避免主流程被拖慢。
- 权限校验前置到网关+服务层双重校验。

## 7. API 设计（含请求/响应样例）
### 7.1 创建任务
`POST /api/v1/projects/{projectId}/tasks`

Request:
```json
{
  "title": "修复支付回调超时",
  "description": "排查第三方支付回调 5xx",
  "priority": "P1",
  "assigneeId": 10023,
  "dueAt": "2026-02-26T18:00:00Z",
  "labels": ["payment", "incident"]
}
```

Response:
```json
{
  "taskId": 9002311,
  "status": "TODO",
  "version": 1
}
```

### 7.2 更新任务（带版本号防并发覆盖）
`PATCH /api/v1/tasks/{taskId}`

Request:
```json
{
  "version": 5,
  "priority": "P0",
  "assigneeId": 10088
}
```

Response:
```json
{
  "taskId": 9002311,
  "version": 6
}
```

### 7.3 状态流转
`POST /api/v1/tasks/{taskId}/transition`

Request:
```json
{
  "from": "IN_PROGRESS",
  "to": "IN_REVIEW",
  "reason": "开发完成，待测试"
}
```

### 7.4 添加评论并 @提及
`POST /api/v1/tasks/{taskId}/comments`

Request:
```json
{
  "content": "@u10088 请今天前完成回归",
  "mentions": [10088]
}
```

### 7.5 查询列表（筛选+分页+排序）
`GET /api/v1/tasks?projectId=88&status=TODO,IN_PROGRESS&assigneeId=10023&page=1&pageSize=50&sort=priority_desc`

### 7.6 错误码语义
- `409_VERSION_CONFLICT`：并发更新冲突，需要刷新后重试。
- `403_PERMISSION_DENIED`：无任务编辑权限。
- `422_INVALID_TRANSITION`：非法状态迁移。
- `503_SEARCH_DEGRADED`：搜索降级到数据库简化查询。

## 8. 数据模型（核心表/索引）
### 8.1 任务主表
```sql
CREATE TABLE task (
  task_id BIGINT PRIMARY KEY,
  tenant_id BIGINT NOT NULL,
  project_id BIGINT NOT NULL,
  title VARCHAR(256) NOT NULL,
  description TEXT,
  status VARCHAR(32) NOT NULL,         -- TODO/IN_PROGRESS/IN_REVIEW/DONE/BLOCKED/CANCELED
  priority VARCHAR(16) NOT NULL,       -- P0/P1/P2/P3
  assignee_id BIGINT,
  reporter_id BIGINT NOT NULL,
  due_at TIMESTAMP,
  is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
  version BIGINT NOT NULL DEFAULT 1,   -- 乐观锁版本号
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_task_project_status ON task(project_id, status, updated_at DESC);
CREATE INDEX idx_task_assignee_status ON task(assignee_id, status, updated_at DESC);
```

### 8.2 评论表
```sql
CREATE TABLE task_comment (
  comment_id BIGINT PRIMARY KEY,
  task_id BIGINT NOT NULL,
  tenant_id BIGINT NOT NULL,
  author_id BIGINT NOT NULL,
  content TEXT NOT NULL,
  mentions JSON,
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_comment_task_time ON task_comment(task_id, created_at DESC);
```

### 8.3 审计表
```sql
CREATE TABLE task_audit (
  audit_id BIGINT PRIMARY KEY,
  task_id BIGINT NOT NULL,
  tenant_id BIGINT NOT NULL,
  actor_id BIGINT NOT NULL,
  action VARCHAR(64) NOT NULL,       -- CREATE/UPDATE/TRANSITION/DELETE/RESTORE
  before_json JSON,
  after_json JSON,
  request_id VARCHAR(64),
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_audit_task_time ON task_audit(task_id, created_at DESC);
```

### 8.4 权限表（简化）
```sql
CREATE TABLE project_member_role (
  tenant_id BIGINT NOT NULL,
  project_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  role VARCHAR(32) NOT NULL,         -- OWNER/MAINTAINER/MEMBER/GUEST
  PRIMARY KEY(tenant_id, project_id, user_id)
);
```

## 9. 核心流程（至少 3 条）
### 9.1 正常流程：任务从创建到完成
1. 用户创建任务，写 `task` 表，写审计日志。
2. 任务被指派给开发，状态从 `TODO -> IN_PROGRESS`。
3. 开发完成后转 `IN_REVIEW`，测试通过转 `DONE`。
4. 每次状态变化触发通知和搜索索引异步更新。

### 9.2 高峰流程：大团队批量操作
1. 项目经理批量调整 5000 个任务优先级。
2. 写服务分批提交，事件按租户分区写入队列。
3. 通知与索引消费者按速率控制防止雪崩。
4. 前端显示“批量处理中”状态避免用户误判失败。

### 9.3 故障恢复流程：搜索服务不可用
1. ES 集群异常，搜索 API 错误率升高。
2. 系统熔断搜索服务，降级到 DB 过滤（功能受限）。
3. 后台继续重试索引同步，恢复后自动切回搜索引擎。
4. 对用户提示“高级筛选暂不可用”。

### 9.4 并发冲突流程
1. 两人同时编辑任务标题与优先级。
2. 第一个提交成功，版本号从 5->6。
3. 第二个提交携带 version=5，返回 `409_VERSION_CONFLICT`。
4. 前端弹出冲突对比，用户选择合并后重提。

## 10. 一致性与事务边界
### 10.1 主流程一致性
- 任务更新和审计记录需要同事务提交。
- 任务更新成功后写 outbox 事件，再异步通知/索引。

### 10.2 异步一致性
- 通知和搜索属于最终一致，允许秒级延迟。
- 对用户展示“刚更新，搜索可能稍后同步”提示。

### 10.3 幂等策略
- 更新请求带 `requestId`，重复提交只执行一次。
- 通知消费按 `eventId` 去重。

### 10.4 面试可复述
“任务主数据强一致，外围能力（通知、搜索）最终一致，这是性能与一致性的工程平衡。”

## 11. 可用性与容错
### 11.1 常见故障
- DB 慢查询导致写超时。
- 通知队列积压。
- 搜索索引消费中断。
- 评论服务高峰写冲突。

### 11.2 容错策略
- 命令服务限流 + 熔断 + 降级策略。
- 通知服务独立消费者组，可水平扩容。
- 索引服务支持断点续传和批量重建。
- 关键接口超时后提供重试建议与幂等保证。

### 11.3 RTO / RPO
- 主任务写服务 RTO：`<= 5 分钟`
- 通知服务 RTO：`<= 15 分钟`（不影响主流程）
- 搜索索引 RPO：`<= 5 分钟`（可接受短暂滞后）

## 12. 可观测性（指标 + 告警阈值）
### 12.1 核心接口指标
- `task_write_p95_ms`
- `task_read_p95_ms`
- `version_conflict_rate`
- `transition_fail_rate`

阈值示例：
- `task_write_p95_ms > 200` 持续 10 分钟 -> P1
- `version_conflict_rate > 2%` 持续 30 分钟 -> P2（需排查并发热点）

### 12.2 异步链路指标
- `notification_lag_sec`
- `search_index_lag_sec`
- `event_outbox_backlog`

阈值示例：
- `notification_lag_sec > 30` 持续 10 分钟 -> P1
- `search_index_lag_sec > 60` 持续 10 分钟 -> P1
- `event_outbox_backlog > 100000` -> P1

### 12.3 业务指标
- `tasks_done_per_day`
- `overdue_task_ratio`
- `task_cycle_time_p95`

## 13. 安全与合规
- 多租户隔离：所有查询必须带 `tenant_id` 条件。
- RBAC + ACL：角色权限 + 任务细粒度权限（如仅负责人可转状态）。
- 字段级权限：访客不可查看内部备注字段。
- 审计不可篡改：关键审计日志写入 WORM/追加存储。
- 附件安全：病毒扫描、下载权限签名、短时 URL。

## 14. 成本与取舍
### 14.1 成本组成
- 主库成本（任务+评论+审计）。
- 搜索集群成本（索引存储与查询）。
- 通知系统成本（推送、邮件、短信）。

### 14.2 关键取舍
- 搜索强一致成本高，通常接受秒级延迟。
- 审计全量保留利于合规，但存储成本高，需要冷热分层。
- 即时通知体验好，但成本高，可按优先级分渠道。

### 14.3 降本策略
- 老评论与审计归档冷存。
- 非关键通知改为站内聚合推送。
- 热项目走缓存，冷项目直接查库。

## 15. 关键代码（Java 更细 + 前端功能代码）
### 15.1 Java：任务更新（乐观锁 + Outbox）
```java
public class TaskCommandService {
    public Task updateTask(UpdateTaskCmd cmd, long actorId) {
        Task oldTask = taskRepo.findById(cmd.taskId());
        if (oldTask == null || oldTask.isDeleted()) {
            throw new NotFoundException("task not found");
        }

        permissionService.checkCanEdit(actorId, oldTask.getProjectId(), oldTask.getTaskId());

        Task newTask = oldTask.apply(cmd);
        boolean ok = taskRepo.updateWithVersion(
            newTask.getTaskId(),
            cmd.expectedVersion(),
            newTask,
            cmd.expectedVersion() + 1
        );
        if (!ok) {
            throw new ConflictException("VERSION_CONFLICT");
        }

        auditRepo.append(AuditEvent.update(oldTask, newTask, actorId));
        outboxRepo.append(Event.taskUpdated(newTask.getTaskId(), newTask.getVersion()));
        return newTask;
    }
}
```

### 15.2 Java：状态流转校验（工作流引擎）
```java
public class WorkflowEngine {
    private static final Map<String, Set<String>> ALLOWED = Map.of(
        "TODO", Set.of("IN_PROGRESS", "CANCELED"),
        "IN_PROGRESS", Set.of("IN_REVIEW", "BLOCKED", "TODO"),
        "IN_REVIEW", Set.of("DONE", "IN_PROGRESS"),
        "BLOCKED", Set.of("IN_PROGRESS", "CANCELED"),
        "DONE", Set.of(),
        "CANCELED", Set.of()
    );

    public void validateTransition(Task task, String toStatus, long actorId) {
        String from = task.getStatus();
        if (!ALLOWED.getOrDefault(from, Set.of()).contains(toStatus)) {
            throw new IllegalArgumentException("INVALID_TRANSITION");
        }
        if ("DONE".equals(toStatus) && task.getAssigneeId() == null) {
            throw new IllegalArgumentException("ASSIGNEE_REQUIRED_BEFORE_DONE");
        }
        permissionService.checkCanTransition(actorId, task.getProjectId(), task.getTaskId(), from, toStatus);
    }
}
```

### 15.3 Java：评论 @提及 通知（幂等消费）
```java
public class CommentService {
    public void addComment(AddCommentCmd cmd, long authorId) {
        Task task = taskRepo.findById(cmd.taskId());
        permissionService.checkCanComment(authorId, task.getProjectId(), task.getTaskId());

        Comment c = commentRepo.insert(task.getTaskId(), authorId, cmd.content(), cmd.mentions());
        outboxRepo.append(Event.commentAdded(c.getCommentId(), task.getTaskId(), cmd.mentions()));
    }
}

public class NotificationConsumer {
    public void onEvent(Event e) {
        if (dedupRepo.exists(e.getEventId())) return;
        for (Long uid : e.getMentionUserIds()) {
            notificationRepo.insertInApp(uid, "你被@了", "taskId=" + e.getTaskId());
        }
        dedupRepo.save(e.getEventId(), 86400);
    }
}
```

### 15.4 Java：搜索索引器（异步最终一致）
```java
public class TaskSearchIndexer {
    public void onTaskUpdated(Event e) {
        Task task = taskRepo.findById(e.getTaskId());
        if (task == null || task.isDeleted()) {
            searchClient.delete("task_index", String.valueOf(e.getTaskId()));
            return;
        }
        SearchDoc doc = SearchDoc.fromTask(task);
        searchClient.upsert("task_index", String.valueOf(task.getTaskId()), doc);
    }
}
```

### 15.5 Java：批量迁移状态（带并发控制）
```java
public class BatchTransitionService {
    public BatchResult batchTransition(List<Long> taskIds, String toStatus, long actorId) {
        int success = 0, failed = 0;
        for (Long taskId : taskIds) {
            try {
                Task t = taskRepo.findById(taskId);
                workflowEngine.validateTransition(t, toStatus, actorId);
                taskRepo.updateStatusWithVersion(taskId, t.getVersion(), toStatus, t.getVersion() + 1);
                outboxRepo.append(Event.taskTransitioned(taskId, toStatus));
                success++;
            } catch (Exception ex) {
                failed++;
            }
        }
        return new BatchResult(success, failed);
    }
}
```

### 15.6 前端（React + TypeScript）：看板拖拽改状态（带冲突处理）
```tsx
import { useState } from "react";

type TaskCard = { taskId: number; title: string; status: string; version: number };

export function KanbanColumn({ status, tasks, onUpdated }: {
  status: string;
  tasks: TaskCard[];
  onUpdated: (taskId: number, newVersion: number, toStatus: string) => void;
}) {
  const [loadingTaskId, setLoadingTaskId] = useState<number | null>(null);

  const onDropTask = async (task: TaskCard) => {
    if (task.status === status) return;
    setLoadingTaskId(task.taskId);
    const resp = await fetch(`/api/v1/tasks/${task.taskId}/transition`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ from: task.status, to: status, expectedVersion: task.version })
    });
    setLoadingTaskId(null);

    if (resp.status === 409) {
      alert("任务已被他人修改，请刷新后重试");
      return;
    }
    if (!resp.ok) {
      alert("状态变更失败");
      return;
    }
    const data = await resp.json();
    onUpdated(task.taskId, data.version, status);
  };

  return (
    <div>
      <h4>{status}</h4>
      {tasks.map((t) => (
        <div key={t.taskId}>
          <span>{t.title}</span>
          <button disabled={loadingTaskId === t.taskId} onClick={() => onDropTask(t)}>
            移到当前列
          </button>
        </div>
      ))}
    </div>
  );
}
```

### 15.7 前端（React + TypeScript）：任务详情页（评论 + @提及）
```tsx
import { useState } from "react";

export function TaskCommentBox({ taskId }: { taskId: number }) {
  const [content, setContent] = useState("");
  const [sending, setSending] = useState(false);
  const [msg, setMsg] = useState("");

  const submit = async () => {
    setSending(true);
    const mentions = Array.from(content.matchAll(/@u(\d+)/g)).map((m) => Number(m[1]));
    const resp = await fetch(`/api/v1/tasks/${taskId}/comments`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ content, mentions })
    });
    setSending(false);
    if (!resp.ok) {
      setMsg("评论发送失败");
      return;
    }
    setContent("");
    setMsg("评论已发送并通知相关人员");
  };

  return (
    <div>
      <textarea value={content} onChange={(e) => setContent(e.target.value)} placeholder="输入评论，@u10088 提及同事" />
      <button disabled={sending} onClick={submit}>发送评论</button>
      {msg && <p>{msg}</p>}
    </div>
  );
}
```

## 16. 测试策略
### 16.1 单元测试
- 状态机合法迁移和非法迁移校验。
- 乐观锁冲突处理。
- 权限矩阵：不同角色不同操作结果。

### 16.2 集成测试
- 创建任务 -> 转状态 -> 评论 -> 通知 -> 搜索同步全链路。
- Outbox 事件重复消费幂等验证。
- 搜索服务不可用时降级路径验证。

### 16.3 压测
- 看板查询 20 万 QPS 压测。
- 批量状态变更峰值写入压测。
- 评论高峰写入和通知队列积压压测。

### 16.4 故障注入
- 强制 ES 不可达，验证回退查询。
- 让通知消费者下线，验证主流程不受影响。
- 模拟 DB 慢查询，验证熔断与限流策略。

## 17. 丰富例子（至少 10 个）
1. 两人同时改任务，后提交收到版本冲突提示。  
2. 任务从 `DONE` 误改回 `TODO` 被工作流拒绝。  
3. 评论里 @负责人，10 秒内收到站内通知。  
4. 外部客户尝试修改内部字段被权限拒绝。  
5. 批量把 300 个任务从 `TODO` 移到 `IN_PROGRESS`。  
6. 搜索短暂查不到新状态，30 秒后索引追平。  
7. 任务误删后通过软删除恢复。  
8. 审计日志显示“谁在何时把优先级改成 P0”。  
9. 大促期间通知队列积压，系统先保证任务写成功。  
10. 超期任务每日自动汇总推送给项目经理。  
11. 看板拖拽触发状态变更，失败时 UI 回滚。  
12. 新员工加入项目后自动获得 MEMBER 权限可看不可删。  

## 18. 面试追问 + 可复述回答
### Q1：并发编辑冲突怎么处理？
可复述：  
“用版本号乐观锁。冲突时返回 409，前端提示用户合并后重试。”

### Q2：为什么通知和搜索不走同步事务？
可复述：  
“同步会拖慢主流程并扩大故障域。主数据强一致，通知和搜索最终一致更实用。”

### Q3：怎么保证任务状态合法？
可复述：  
“状态机白名单 + 权限校验 + 前后置条件（如 DONE 前必须有负责人）。”

### Q4：看板性能怎么做？
可复述：  
“热点查询走缓存，按项目和状态做索引，分页与增量加载，复杂搜索走 ES。”

### Q5：审计日志有什么价值？
可复述：  
“能回答‘谁改了什么’，用于排障、合规和责任追踪。”

### Q6：搜索和数据库不一致用户会投诉吗？
可复述：  
“会，所以要明确提示‘同步中’，并控制索引延迟在 SLA 内。”

## 19. 新手学习路线
### 第 1 周：先做核心 CRUD
- 创建任务、更新任务、列表查询。
- 加上状态字段和基础迁移规则。

### 第 2 周：补协作能力
- 评论、@提及、关注人通知。
- 加审计日志。

### 第 3 周：补工程能力
- 乐观锁、权限校验、Outbox 事件。
- 接入搜索索引异步同步。

### 第 4 周：补可运维能力
- 告警看板、故障降级、压测与回滚演练。
- 整理面试讲稿：状态机+权限+异步一致性。

## 20. 上场前 Checklist
- [ ] 我能画出写路径和读路径分离架构。  
- [ ] 我能解释版本冲突如何被检测和处理。  
- [ ] 我能讲清状态机规则和权限矩阵。  
- [ ] 我能说明通知和搜索为何走异步。  
- [ ] 我能给出 3 个以上告警阈值。  
- [ ] 我能描述一次搜索降级处置流程。  
- [ ] 我能展示前端看板拖拽和冲突提示逻辑。  
- [ ] 我能讲清审计日志在合规与排障中的作用。  

## 21. 30 秒总结
任务管理系统高分答案是：  
“把任务当成有生命周期的状态机对象来设计，用乐观锁和权限模型保证多人协作正确，用异步事件解耦通知与搜索，用审计和告警保证可追溯和可运维。”  
如果你能把这句话展开成数据模型、流程、阈值和代码点位，面试官会认为你能做真实协作平台。  
