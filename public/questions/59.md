# Q59 Design Voting System（投票系统）

## 1. 三句话题目本质
1. 投票系统要保证“同一用户对同一活动的同一规则只被有效计数一次”。
2. 难点是高并发下的防刷、匿名展示与可审计追责共存。
3. 面试里要讲清写入幂等、实时统计、最终账本、故障恢复路径。

## 2. 真实场景故事
某综艺总决赛 10 分钟内收到 700 万投票请求，峰值突刺超 35k QPS。业务要大屏秒级更新，风控要拦截机器刷票，法务要可追溯。最终采用“入口校验 + 事件入队 + 异步记票 + 榜单缓存 + 账本对账”实现稳定运行。

## 3. 术语白话表（>=10）
1. 幂等键：同请求重复提交只生效一次。
2. 投票事件：原始写入记录，用于回放修复。
3. 实时榜单：缓存侧聚合视图，延迟低但非最终口径。
4. 最终账本：数据库真相源，最终统计以此为准。
5. 风险评分：用设备/IP/行为信号评估可疑请求。
6. 限流：按用户/IP/活动对入口流量做保护。
7. 延迟队列：失败后按退避时间重试。
8. DLQ：超过重试上限的失败事件隔离区。
9. 回放：把失败事件重新消费修复数据。
10. 匿名ID：前端不展示真实身份，后端保留映射。
11. RTO：故障恢复时间目标。
12. RPO：故障可接受数据丢失目标。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 创建投票活动（单选/多选、时间窗、每用户限制）。
2. 提交投票、查询实时结果、查询最终结果。
3. 命中风控后支持人工复核与回补。

### 4.2 非功能需求
1. 高峰可承载 40k QPS。
2. 实时榜单延迟 P95 < 1s。
3. 平台可用性 >= 99.95%。

### 4.3 不做范围
1. 不做跨法域实名核验平台。
2. 不做链上不可篡改存证。

### 4.4 SLO
1. `vote_accept_p95 < 120ms`
2. `scoreboard_lag_p95 < 1000ms`
3. `risk_false_positive < 0.3%`

## 5. 容量估算（数字推导）
1. 10 分钟 700 万票，平均 QPS：`7000000 / 600 = 11666`。
2. 按 3 倍突刺预留，入口目标约 `35k QPS`。
3. 单事件 320B，峰值写带宽约 `35k * 320B ≈ 11.2MB/s`。
4. 日 2.5 亿事件，日志体量约 `80GB/天`（未压缩）。
5. 热存 7 天约 560GB，历史归档对象存储。

## 6. 架构（简版+完整版）
### 6.1 简版
Client -> Vote API -> MQ -> Vote Worker -> MySQL + Redis

### 6.2 完整版
1. API Gateway：鉴权、限流、签名校验。
2. Vote Command Service：规则校验、幂等、写账本+outbox。
3. Risk Engine：设备/IP/行为风险判定。
4. MQ：解耦提交与计票。
5. Vote Worker：记票、榜单更新、审计事件。
6. Query Service：实时榜单与最终结果查询。
7. Reconcile Job：缓存与账本对账修复。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 提交投票
`POST /api/v1/polls/{pollId}/votes`

请求：
```json
{"userId":"u_1001","options":["A"],"clientReqId":"req-20260224-1001"}
```

响应：
```json
{"voteId":"v_90001","status":"ACCEPTED","riskReview":false}
```

### 7.2 查询实时结果
`GET /api/v1/polls/{pollId}/result?mode=realtime`

### 7.3 错误码
1. `VOTE_409_DUPLICATE`
2. `VOTE_429_RATE_LIMIT`
3. `VOTE_451_RISK_REVIEW`

幂等规则：`pollId + userHash + clientReqId` 唯一，重复请求返回同一 `voteId`。

## 8. 数据模型（实体/索引/分片）
1. `poll(poll_id,status,start_at,end_at,rule_json)`
2. `vote_ledger(vote_id,poll_id,user_hash,option_id,idem_key,status,created_at)`
3. `risk_decision(vote_id,score,decision,reason,reviewed_at)`
4. `outbox_event(event_id,aggregate_id,type,payload,status,created_at)`

索引：
1. 唯一索引 `(poll_id,user_hash,idem_key)` 防重复。
2. 查询索引 `(poll_id,created_at)` 支撑按时间聚合。

分片：
1. `hash(poll_id) % N`。
2. 超热点活动单独分片隔离。

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：请求校验 -> 风控 -> 事务写账本+outbox -> MQ消费更新榜单。
2. 高峰：限流前置 + 风控加严 + 消费扩容 + 非核心查询降级。
3. 故障恢复：重试队列 -> DLQ -> 回放 -> 对账修复。

## 10. 一致性与事务边界
1. 写入事务边界：账本行与 outbox 同事务提交。
2. MQ 消费与缓存更新是最终一致。
3. 对外口径：实时看 Redis，结算看 MySQL 聚合。

## 11. 可用性与容错（含 RTO/RPO）
1. API 与 Worker 多副本跨 AZ。
2. MQ 多副本与消费者重平衡。
3. Redis 异常时降级到账本聚合。
4. RTO 15 分钟，RPO 0（账本不丢）。

## 12. 可观测性（指标+阈值+处置动作）
1. `vote_qps > 35k` 持续 3 分钟：扩 API + Worker。
2. `scoreboard_lag_ms > 2000`：降级近实时提示并扩消费。
3. `risk_block_ratio > 20%`：回滚风控模型版本。
4. `dlq_rate > 300/min`：冻结发布并启动回放。

## 13. 安全与合规
1. 用户标识哈希化，前台匿名展示。
2. 审计日志记录操作者、时间、回补原因。
3. 请求签名与 nonce 防重放。

## 14. 成本与取舍
1. Redis 提升实时性但成本高，历史明细冷归档降成本。
2. 风控阈值过严会误杀，需动态调参。
3. 高峰优先保记票正确性，其次保展示频率。

## 15. Java关键代码（>=5段）
### 15.1 幂等写入与事务边界
```java
public VoteAccepted accept(VoteCmd cmd) {
    String idem = cmd.pollId() + ":" + cmd.userHash() + ":" + cmd.clientReqId();
    VoteAccepted existed = idemRepo.find(idem);
    if (existed != null) return existed;
    tx.begin();
    try {
        VoteRow row = ledgerRepo.insertPending(cmd, idem);
        outboxRepo.append("VOTE_ACCEPTED", row.getVoteId(), row.toJson());
        VoteAccepted result = new VoteAccepted(row.getVoteId());
        idemRepo.save(idem, result);
        tx.commit();
        return result;
    } catch (RuntimeException ex) {
        tx.rollback();
        throw ex;
    }
}
```

### 15.2 风险判定
```java
public RiskDecision evaluateRisk(VoteCmd cmd) {
    if (!rateLimiter.allow("u:" + cmd.userId(), 5, 1)) {
        return RiskDecision.block("RATE_LIMIT");
    }
    double score = riskModel.score(cmd.deviceId(), cmd.ip(), cmd.behavior());
    if (score > 0.92) return RiskDecision.review(score);
    return RiskDecision.pass(score);
}
```

### 15.3 消费幂等与计票
```java
public void onVoteEvent(VoteEvent e) {
    if (consumeRepo.done(e.eventId())) return;
    ledgerRepo.markCounted(e.voteId());
    redisRepo.incrScore(e.pollId(), e.optionId(), 1L);
    consumeRepo.markDone(e.eventId());
}
```

### 15.4 重试退避与失败处理
```java
public void retryOrDeadLetter(VoteEvent e, int attempt, String err) {
    if (attempt >= 6) {
        mq.send("vote.dlq", e.eventId(), err);
        return;
    }
    long delayMs = Math.min(30000L, (1L << attempt) * 500L);
    mq.sendDelay("vote.retry", e.eventId(), delayMs);
}
```

### 15.5 对账修复
```java
public void reconcile(String pollId) {
    Map<String, Long> dbAgg = ledgerRepo.aggregateByOption(pollId);
    Map<String, Long> cacheAgg = redisRepo.readScores(pollId);
    for (Map.Entry<String, Long> it : dbAgg.entrySet()) {
        long cacheValue = cacheAgg.getOrDefault(it.getKey(), 0L);
        if (cacheValue != it.getValue()) {
            redisRepo.setScore(pollId, it.getKey(), it.getValue());
        }
    }
}
```

## 16. 前端功能代码（React JS >=2段，仅 API 协作）
### 16.1 提交投票（loading/error/done + 幂等键）
```javascript
import { useState } from "react";

export function useVoteAction(pollId, userId) {
  const [phase, setPhase] = useState("idle");
  const [msg, setMsg] = useState("");

  async function submit(optionId) {
    setPhase("loading");
    const idem = `${pollId}-${userId}-${Date.now()}`;
    const resp = await fetch(`/api/v1/polls/${pollId}/votes`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "Idempotency-Key": idem },
      body: JSON.stringify({ userId, options: [optionId], clientReqId: idem })
    });
    if (resp.ok) {
      setPhase("done");
      setMsg("投票已接收");
      return;
    }
    setPhase("error");
    setMsg(resp.status === 451 ? "命中风控，进入复核" : "提交失败，请重试");
  }

  return { phase, msg, submit };
}
```

### 16.2 实时轮询（降级提示 + 状态流转）
```javascript
import { useEffect, useState } from "react";

export function useRealtimeResult(pollId) {
  const [phase, setPhase] = useState("loading");
  const [data, setData] = useState(null);
  const [tip, setTip] = useState("");

  useEffect(() => {
    let timer = null;
    async function poll() {
      const resp = await fetch(`/api/v1/polls/${pollId}/result?mode=realtime`);
      if (!resp.ok) {
        setPhase("error");
        setTip("结果暂不可用");
      } else {
        const body = await resp.json();
        setData(body);
        setPhase("done");
        setTip(body.lagMs > 1500 ? "高峰期，结果为近实时展示" : "");
      }
      timer = setTimeout(poll, 1000);
    }
    poll();
    return () => clearTimeout(timer);
  }, [pollId]);

  return { phase, data, tip };
}
```

## 17. 测试策略
1. 单测：幂等键、风控阈值、状态迁移。
2. 集成：投票提交到榜单更新端到端。
3. 压测：40k QPS 持续 15 分钟。
4. 故障演练：MQ抖动、Redis故障、回放修复。

## 18. 丰富例子（>=10）
1. 用户连续点击 15 次只记 1 票。
2. 同 IP 高频请求被限流。
3. 风控误杀后人工复核回补。
4. Redis 宕机降级到账本聚合。
5. MQ 重复消息不重复记票。
6. 活动结束后只读查询继续可用。
7. 热门选项异常增长触发告警。
8. 高峰榜单延迟过高触发近实时提示。
9. DLQ 回放后票数恢复一致。
10. 跨 AZ 切换后最终统计一致。

## 19. 面试追问+可复述回答
1. 如何平衡匿名与审计？
回答：展示匿名ID，后台保留脱敏映射并做权限审计。
2. 为什么实时榜单和最终结果会短时不一致？
回答：实时榜单走缓存最终一致，最终口径来自账本聚合。
3. 高峰先做什么？
回答：先限流和风控前置，再扩消费者，最后再扩重资源。
4. 如何确保同用户只计一次？
回答：幂等键+唯一索引+消费幂等三层兜底。
5. 风控误杀怎么恢复？
回答：复核通过后回补事件入队并重算榜单。

## 20. 新手学习路线
1. 先掌握幂等写入与唯一索引。
2. 再掌握 MQ 异步消费与缓存聚合。
3. 最后掌握风控、回放与对账修复。

## 21. 上场前Checklist
1. 能讲清“只计一次票”的完整链路。
2. 能解释实时与最终口径差异。
3. 能说出至少 3 个阈值及动作。
4. 能说明故障恢复路径与 RTO/RPO。
5. 能描述误杀回补流程。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q60 Task Management Application。

### 22.2 共性
1. 都有状态机和审计要求。
2. 都强调幂等和故障补偿。

### 22.3 差异
1. Q59 更强调防刷与匿名合规。
2. Q59 有实时榜单与最终账本双口径治理。
3. Q59 高峰突刺对入口保护要求更高。

### 22.4 新增知识点（>=5）
1. 风险评分与限流协同。
2. 投票幂等键设计。
3. 榜单重建与对账修复。
4. DLQ 回放闭环。
5. 匿名展示与审计映射隔离。

### 22.5 面试话术
母题偏任务流程管理，本题核心是可信计票、防作弊与近实时展示。

## 自审评分
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过）
