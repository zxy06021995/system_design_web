# Q95：Design Secure Identity Management System

## 1. 题目卡片与目标分
- title：Design Secure Identity Management System
- tags：身份管理、SSO、OAuth、RBAC、认证
- keyPoints：SSO设计、OAuth2.0、RBAC权限、多因素认证、审计日志
- learningCoreId：93（Design Fraud Detection System）
- 总分：97/100

## 2. 业务背景与边界
企业有多个业务系统（Web、App、管理后台、第三方集成），需要统一登录、统一授权、统一审计。目标是“安全优先、体验可接受、可扩展”。不做自研密码学算法，不做跨国多法域合规细节。

## 3. 需求澄清
1. 支持账号登录、SSO、OAuth2.0 授权码模式、MFA、RBAC。
2. 支持会话管理、Token 刷新、Token 撤销、设备风险控制。
3. 支持审计日志与追溯，管理员权限变更全量留痕。
4. 支持租户隔离与策略配置。

## 4. 非功能目标与SLO
1. 登录接口 `p95 < 200ms`，授权接口 `p95 < 150ms`。
2. 可用性 `99.95%`，关键认证链路错误率 `< 0.1%`。
3. 审计日志落库成功率 `>= 99.99%`。
4. 会话一致性最终收敛时间 `< 60s`。

## 5. 容量估算
1. 日活 500 万，峰值并发登录 4 万 QPS，令牌校验 20 万 QPS。
2. 平均 JWT 1.2KB，日签发 8000 万，日新增 Token 数据约 96GB（含索引前估算）。
3. 审计日志平均 1.5KB，日 2 亿条，冷温热分层后月存储约 9TB。
4. 容量冗余按 `N+2`，突发流量按 3 倍峰值预留。

## 6. 高层架构
```text
Client -> API Gateway -> Auth Service -> Policy Engine -> User/Role Store
                         |               |
                         |               -> Risk Adapter (device/ip/geo)
                         -> Token Service (JWT/Opaque + revoke)
                         -> Session Store (Redis Cluster)
                         -> Audit Bus (Kafka) -> Audit Sink (OLAP/Object Storage)
```

## 7. 核心API设计
1. `POST /v1/auth/login`：用户名密码 + MFA 验证，返回 access_token/refresh_token。
2. `POST /v1/oauth/authorize`：发放授权码。
3. `POST /v1/oauth/token`：授权码换 token，要求 `Idempotency-Key`。
4. `POST /v1/token/introspect`：服务端校验 token 状态。
5. `POST /v1/token/revoke`：主动撤销 token 与会话。

## 8. 数据模型
1. `user(id, tenant_id, status, password_hash, mfa_secret_ref, created_at)`
2. `role(id, tenant_id, role_name)` / `permission(id, action, resource)`
3. `user_role(user_id, role_id)` / `role_permission(role_id, permission_id)`
4. `oauth_client(client_id, secret_hash, redirect_uri, scope)`
5. `token_jti(jti, user_id, exp_at, revoked, version)`
6. `audit_log(trace_id, actor_id, action, target, result, ts)`

## 9. 关键流程
1. 登录：凭证验证 -> 风险评估 -> MFA -> 签发 token -> 写审计。
2. SSO：主站登录态换取各子系统短期 token，统一登出联动撤销。
3. OAuth：授权码一次性消费，换 token 必带幂等键，重复请求返回同结果。

## 10. 一致性与事务边界
1. 登录成功写入会话、token 元信息、审计日志采用“本地事务 + outbox”。
2. 审计落库异步消费，消费端按 `trace_id + seq` 幂等去重。
3. Token 撤销采用“强实时黑名单 + 异步全量同步”，保证秒级生效与最终收敛。

## 11. 阈值、告警与扩缩容
1. `auth_login_p95 > 200ms` 持续 5 分钟触发 P1。
2. `token_issue_error_rate > 0.2%` 持续 3 分钟触发 P1。
3. `session_store_cpu > 75%` 持续 10 分钟自动扩容 2 分片。
4. `audit_consumer_lag > 500000` 触发降级：先保认证，审计改批量写。

## 12. 故障恢复路径（含RTO/RPO）
1. 身份服务单AZ故障：30 秒内流量切换，RTO=5 分钟，RPO=0（多副本同步）。
2. Session Redis 主分片故障：自动故障转移 + 连接池重建，RTO=3 分钟，RPO<=5 秒。
3. 审计链路 Kafka 积压：临时降采样 + 批量回放，RTO=30 分钟，RPO<=1 分钟。
4. 签名密钥泄露：立即轮换 kid、撤销高风险会话、强制二次登录，RTO=15 分钟，RPO=0（控制面操作）。

## 13. 安全与合规
1. 认证相关密钥放 HSM/KMS，密钥轮换按 30 天自动化。
2. 关键接口启用 mTLS、WAF、IP 信誉与设备指纹。
3. 管理员操作双人审批，敏感查询最小权限与脱敏。
4. 审计日志不可篡改存储，保留期和删除策略可配置。

## 14. 取舍分析
1. JWT 读性能好，但撤销复杂；高风险域可用 Opaque Token + introspection。
2. 强一致会话成本高，采用“核心写强一致 + 非核心最终一致”。
3. MFA 覆盖率提升会增加登录摩擦，分层策略按风险触发更均衡。

## 15. Java 关键实现（>=5）
```java
public final class IdempotencyService {
    private final IdempotencyRepo repo;
    public IdempotencyResult begin(String key, String payloadHash) {
        IdempotencyRecord rec = repo.find(key);
        if (rec != null && rec.payloadHash().equals(payloadHash)) {
            return IdempotencyResult.replay(rec.responseBody());
        }
        if (rec != null) {
            throw new IllegalArgumentException("same key with different payload");
        }
        repo.insert(new IdempotencyRecord(key, payloadHash, "PROCESSING"));
        return IdempotencyResult.accepted();
    }
}
```

```java
public class OAuthTokenController {
    private final OAuthTokenService service;
    public HttpResponse exchange(TokenRequest req, String idemKey) {
        TokenResponse resp = service.exchangeWithIdempotency(req, idemKey);
        return HttpResponse.ok(resp);
    }
}
```

```java
public class OAuthTokenService {
    public TokenResponse exchangeWithIdempotency(TokenRequest req, String idemKey) {
        String payloadHash = DigestUtil.sha256(req.clientId() + "|" + req.code());
        IdempotencyResult check = idem.begin(idemKey, payloadHash);
        if (check.isReplay()) {
            return JsonUtil.fromJson(check.responseBody(), TokenResponse.class);
        }
        TokenResponse issued = issuer.issue(req);
        idem.finish(idemKey, JsonUtil.toJson(issued));
        audit.publish("TOKEN_ISSUED", issued.userId(), issued.jti());
        return issued;
    }
}
```

```java
public class TokenRevocationService {
    public void revoke(String jti, long expAtEpochSec) {
        blacklist.put(jti, expAtEpochSec);
        outbox.append("TOKEN_REVOKED", jti, expAtEpochSec);
    }
    public boolean isRevoked(String jti) {
        return blacklist.contains(jti);
    }
}
```

```java
public class LoginRiskOrchestrator {
    public Decision evaluate(LoginContext ctx) {
        RiskScore score = riskClient.score(ctx.deviceId(), ctx.ip(), ctx.geo());
        if (score.value() >= 90) {
            return Decision.block("high risk");
        }
        if (score.value() >= 60) {
            return Decision.challenge("require_mfa");
        }
        return Decision.allow();
    }
}
```

```java
public class AuditConsumer {
    public void onMessage(AuditEvent e) {
        String dedupeKey = e.traceId() + ":" + e.seq();
        if (dedupeRepo.exists(dedupeKey)) {
            return;
        }
        sink.write(e);
        dedupeRepo.save(dedupeKey, e.ts());
    }
}
```

## 16. React 前端代码（>=2，含状态与恢复）
```jsx
import React, { useEffect, useState } from "react";

export function LoginHealthPanel() {
  const [status, setStatus] = useState("loading"); // loading|error|done
  const [data, setData] = useState(null);
  const [error, setError] = useState("");

  useEffect(() => {
    let timerId;
    let stopped = false;
    const poll = async () => {
      try {
        setStatus("loading");
        const resp = await fetch("/api/v1/auth/health");
        if (!resp.ok) throw new Error("health api failed");
        const body = await resp.json();
        if (stopped) return;
        setData(body);
        setError("");
        setStatus("done");
      } catch (e) {
        if (stopped) return;
        setError(e.message);
        setStatus("error");
      } finally {
        timerId = window.setTimeout(poll, 5000); // 轮询
      }
    };
    poll();
    return () => {
      stopped = true;
      window.clearTimeout(timerId);
    };
  }, []);

  if (status === "loading") return <div>loading...</div>;
  if (status === "error") return <div>error: {error}</div>;
  return <div>done: p95={data.p95Ms} err={data.errorRate}</div>;
}
```

```javascript
import { useState } from "react";

export function OAuthExchangeButton({ code }) {
  const [status, setStatus] = useState("done"); // loading|error|done
  const [error, setError] = useState("");
  const [token, setToken] = useState("");

  async function exchangeWithRetry() {
    setStatus("loading");
    setError("");
    const idemKey = `exchange-${code}`; // 幂等键
    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        const resp = await fetch("/api/v1/oauth/token", {
          method: "POST",
          headers: { "Content-Type": "application/json", "Idempotency-Key": idemKey },
          body: JSON.stringify({ grant_type: "authorization_code", code })
        });
        if (!resp.ok) throw new Error(`http_${resp.status}`);
        const body = await resp.json();
        setToken(body.access_token);
        setStatus("done"); // success branch
        return;
      } catch (e) {
        if (attempt === 3) {
          setStatus("error"); // failure branch
          setError("token exchange failed, fallback to manual login");
          return; // 降级到手动重新登录
        }
        await new Promise((r) => setTimeout(r, attempt * 400)); // 重试退避
      }
    }
  }

  return (
    <div>
      <button onClick={exchangeWithRetry}>Exchange Token</button>
      <div>status: {status}</div>
      {error && <div>{error}</div>}
      {token && <div>token ready</div>}
    </div>
  );
}
```

## 17. 测试与演练
1. 单测：密码校验、RBAC 判权、MFA 分支、幂等分支。
2. 集成：登录到鉴权到审计全链路，含撤销与强制下线。
3. 压测：登录峰值 3 倍、授权码并发换 token、缓存抖动。
4. 演练：Redis 主从切换、KMS 不可用、Kafka 积压、跨AZ网络抖动。

## 18. 丰富例子（>=10）
1. 企业员工从门户登录后，10 个子系统免登访问。
2. 外部合作方通过 OAuth2.0 授权码获取短期访问令牌。
3. 检测到新设备异地登录，触发 MFA 二次认证。
4. 管理员角色被误赋权，审计平台秒级告警并回滚。
5. Token 泄露后按 `kid` 批量撤销并强制重登。
6. Redis 分片故障后 3 分钟内会话恢复可用。
7. 审计消费者积压时，先保障登录链路再异步补写。
8. 同一授权码被重复提交，幂等层返回同一结果。
9. 规则发布异常导致误拦截，切换降级策略只拦高风险。
10. 业务并购后新增租户，复用统一身份平台完成隔离上线。
11. 某地区网络波动时，客户端重试 + 服务端幂等保持一致。
12. 合规审计抽查时，按 trace_id 追溯完整登录与授权行为。

## 19. 面试追问与回答
1. 为什么要学习核心母题再做本题：母题 93 解决实时风控与规则模型，本题在其上叠加 SSO/OAuth/RBAC/MFA 的身份闭环。
2. 为什么不用全 JWT：撤销与强制下线成本高，所以高风险域引入 introspection。
3. 如何证明可恢复：给出 RTO/RPO、演练频率、回放耗时、最近一次演练结果。

## 20. 学习路线
1. 先掌握 OAuth2.0、OIDC、SSO 基础流程图。
2. 再实现 RBAC 与会话撤销的工程化细节。
3. 最后补故障演练、阈值治理、审计与合规证据链。

## 21. 复盘清单
1. 我能在 1 分钟内讲完登录/授权/撤销三条主链路。
2. 我能明确 3 个关键阈值及触发动作。
3. 我能说明至少 2 条降级路径和对应副作用。
4. 我能说清 RTO/RPO 与恢复步骤的对应关系。
5. 我能解释性能、安全、成本三角取舍。

## 22. 与母题差异
1. 母题：Q93 Design Fraud Detection System；本题：Q95 Design Secure Identity Management System（learningCoreId=93）。
2. 共性：都需要实时决策、规则管理、审计追踪、可观测告警、故障恢复。
3. 差异一：本题以身份生命周期为主线（注册/登录/授权/撤销），母题以风险识别为主线。
4. 差异二：本题必须覆盖协议层（SSO、OAuth2.0、OIDC）与令牌治理，母题不强调协议兼容。
5. 差异三：本题重点是权限模型正确性（RBAC/ABAC 边界）与会话一致性。
6. 差异四：本题需要处理“用户体验 vs 安全强度”动态平衡，如 MFA 触发策略。
7. 差异五：本题对密钥管理、token 撤销、单点登出要求更高。
8. 新增必补知识一：OIDC 与 OAuth2.0 差异及落地场景。
9. 新增必补知识二：SSO 单点登录与单点登出的协议链路。
10. 新增必补知识三：RBAC/ABAC 组合授权与冲突解算策略。
11. 新增必补知识四：Refresh Token 轮换与重放攻击防护。
12. 新增必补知识五：会话撤销传播机制与秒级生效设计。
13. 新增必补知识六：审计日志防篡改与合规留存策略。
