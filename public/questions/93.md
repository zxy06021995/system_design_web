# Q93：Design Fraud Detection System（反欺诈系统）- 95分面试版

## 1. 三句话题目本质
1. 反欺诈系统的核心是“在几十毫秒内判断一笔行为是否可疑，并做出业务可承受的决策”。  
2. 最大难点是平衡：拦截太松会漏判造成资金损失，拦截太严会误伤正常用户导致转化下滑。  
3. 面试高分关键：规则引擎 + 模型评分协同决策、人审闭环、反馈学习、可解释与合规。  

## 2. 一个真实场景故事
某电商支付场景在 10 分钟内出现异常：
- 同一设备指纹绑定了 30 个新账号。
- 多个账号在凌晨集中发起小额多笔支付。
- 支付成功后很快申请退款，且收货地址高度相似。

如果你一刀切全拦，会伤害正常用户。  
如果你全放行，坏账会爆炸。  
正确做法是分层决策：
- 极高风险：直接拒绝
- 中风险：二次验证（短信、人脸、3DS）
- 低风险：放行但增强监控

这就是反欺诈系统要实现的“动态风险控制”。

## 3. 术语白话表（至少 10 项）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Rule Engine | 规则引擎 | “显式 if-then 规则，解释性强，见效快” |
| Risk Model | 风险模型 | “基于历史样本打风险分，捕捉复杂模式” |
| Risk Score | 风险分 | “0~1 或 0~100，分越高风险越大” |
| Threshold | 阈值 | “分数大于多少就挑战/拒绝” |
| False Positive | 误杀 | “好用户被错拦” |
| False Negative | 漏判 | “坏用户被放过” |
| Challenge | 挑战 | “二次验证，不直接拒绝” |
| Chargeback | 拒付 | “用户争议导致资金被银行退回” |
| Case Review | 人工复核 | “风险边界样本交给审核员判断” |
| Feature Store | 特征仓库 | “在线/离线共用特征来源” |
| Drift | 数据漂移 | “线上数据分布变化导致模型退化” |
| Explainability | 可解释性 | “告诉业务为什么判高风险” |
| Whitelist/Blacklist | 白名单/黑名单 | “强规则优先决策” |
| Velocity Rule | 频次规则 | “短时间内异常高频行为” |
| Graph Risk | 图关系风险 | “账号、设备、地址关联网络风险” |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 支持多场景实时风控：登录、注册、支付、提现、退款。
- 支持规则配置、规则灰度、规则回滚。
- 支持模型在线评分与版本管理。
- 支持决策结果：`ALLOW / CHALLENGE / REJECT / MANUAL_REVIEW`。
- 支持案件中心：人工审核、申诉处理、复判。
- 支持反馈闭环：拒付、申诉结果回流训练和规则优化。

### 4.2 非功能需求（SLO 示例）
- 决策时延：`P95 <= 50ms`，`P99 <= 120ms`。
- 服务可用性：`>= 99.99%`（核心支付风控）。
- 决策日志落地成功率：`>= 99.999%`。
- 模型超时降级成功率：`100%`（必须有兜底规则）。
- 误杀率（按业务线控制）：例如 `< 0.2%`。

### 4.3 Out of Scope（首版不做）
- 不做全自动黑产画像平台（先规则+模型+人审）。
- 不做实时图数据库全量推理（先部分场景图特征）。
- 不做跨行业联合风控联盟接入。

## 5. 容量估算（含数字推导）
### 5.1 假设
- 峰值风控请求：`120,000 qps`
- 每请求在线特征读取：`40~80` 项
- 单次评分预算：`< 15ms`
- 决策日志：`120,000 qps` 持续高峰 2 小时

### 5.2 吞吐估算
- 峰值请求数据面：若每请求上下文 2KB，约 `240MB/s`
- 日事件日志（平均 25k qps）：`25,000 * 2KB * 86400 ≈ 4.3TB/day`

### 5.3 计算预算
- 总预算 50ms 例子：
  - 特征拉取 15ms
  - 规则执行 5ms
  - 模型打分 12ms
  - 决策合成与日志 8ms
  - 网络抖动余量 10ms

### 5.4 关键结论
- 特征访问必须缓存化/本地化，不然延迟不可控。
- 模型必须有超时降级策略，不能卡死主链路。
- 决策日志必须异步且可靠，否则无法复盘和对账。

## 6. 架构（简版 + 完整版）
### 6.1 简版架构
```text
Risk API -> Feature Service -> Rule Engine -> Model Service -> Decision Engine
                              -> Case Queue -> Manual Review
                              -> Feedback Loop -> Rule/Model Update
```

### 6.2 完整版架构
```text
[Business Gateway]
  -> [Risk Decision API]
  -> [Context Builder] (user/device/ip/order)
  -> [Feature Service]
      -> Online Feature Store (Redis/RocksDB)
      -> Real-time Aggregator (Kafka/Flink)
  -> [Rule Engine]
  -> [Model Scoring Service]
  -> [Decision Orchestrator]
      -> allow/challenge/reject/manual_review
  -> [Decision Log + Outbox]
      -> [Case Management]
      -> [Alert & Monitoring]
      -> [Feedback Ingestor]
      -> [Training Pipeline]
  -> [Rule Config Center + A/B]
  -> [Model Registry + Shadow Eval]
```

### 6.3 组件职责
- Rule Engine：秒级调整策略，紧急止血优先。
- Model Service：识别复杂组合欺诈模式。
- Decision Orchestrator：融合规则与模型，输出最终动作。
- Case Management：处理边界样本和申诉纠错。

## 7. API 设计（含请求/响应样例）
### 7.1 风险评估接口
`POST /api/v1/risk/evaluate`

Request:
```json
{
  "eventId": "evt_20260224_9001",
  "scene": "PAYMENT",
  "userId": 10001,
  "deviceId": "dev_xxx",
  "ip": "1.2.3.4",
  "amount": 19900,
  "currency": "CNY",
  "merchantId": 9001
}
```

Response:
```json
{
  "decision": "CHALLENGE",
  "riskScore": 0.83,
  "ruleHits": ["DEVICE_VELOCITY_HIGH", "IP_RISK_REGION"],
  "modelVersion": "risk_v23",
  "reasonCode": "HIGH_RISK_NEED_2FA"
}
```

### 7.2 规则发布接口
`POST /api/v1/risk/rules/publish`

Request:
```json
{
  "ruleId": "RISK_DEVICE_VELOCITY_V3",
  "status": "ENABLED",
  "effectiveAt": "2026-02-24T10:30:00Z",
  "grayPercent": 20
}
```

### 7.3 人审结果提交
`POST /api/v1/risk/cases/{caseId}/review`

Request:
```json
{
  "reviewerId": 7788,
  "result": "ALLOW",
  "reason": "verified with additional documents"
}
```

### 7.4 申诉提交
`POST /api/v1/risk/appeals`

### 7.5 错误码语义
- `409_EVENT_ALREADY_EVALUATED`：同 eventId 重复评估。
- `422_INVALID_RULE_EXPR`：规则表达式不合法。
- `503_MODEL_SERVICE_TIMEOUT`：模型超时，已降级规则决策。

## 8. 数据模型（核心表/索引）
### 8.1 风险事件表
```sql
CREATE TABLE risk_event (
  event_id VARCHAR(64) PRIMARY KEY,
  scene VARCHAR(32) NOT NULL,           -- LOGIN/PAYMENT/REGISTER/REFUND
  user_id BIGINT,
  device_id VARCHAR(128),
  ip VARCHAR(64),
  amount BIGINT,
  risk_score DOUBLE,
  decision VARCHAR(16) NOT NULL,        -- ALLOW/CHALLENGE/REJECT/MANUAL_REVIEW
  model_version VARCHAR(64),
  rule_hits JSON,
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_risk_event_scene_time ON risk_event(scene, created_at DESC);
CREATE INDEX idx_risk_event_user_time ON risk_event(user_id, created_at DESC);
```

### 8.2 规则定义表
```sql
CREATE TABLE risk_rule (
  rule_id VARCHAR(64) PRIMARY KEY,
  scene VARCHAR(32) NOT NULL,
  expr TEXT NOT NULL,
  priority INT NOT NULL,
  action VARCHAR(16) NOT NULL,          -- REJECT/CHALLENGE/MARK
  status VARCHAR(16) NOT NULL,          -- ENABLED/DISABLED
  version INT NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_risk_rule_scene_status ON risk_rule(scene, status, priority DESC);
```

### 8.3 人审案件表
```sql
CREATE TABLE risk_case (
  case_id BIGINT PRIMARY KEY,
  event_id VARCHAR(64) NOT NULL,
  status VARCHAR(16) NOT NULL,          -- OPEN/IN_REVIEW/CLOSED
  reviewer_id BIGINT,
  review_result VARCHAR(16),            -- ALLOW/REJECT
  review_reason VARCHAR(512),
  created_at TIMESTAMP NOT NULL,
  closed_at TIMESTAMP
);
CREATE INDEX idx_case_status_time ON risk_case(status, created_at DESC);
```

### 8.4 反馈表（拒付/申诉）
```sql
CREATE TABLE risk_feedback (
  feedback_id BIGINT PRIMARY KEY,
  event_id VARCHAR(64) NOT NULL,
  type VARCHAR(32) NOT NULL,            -- CHARGEBACK/APPEAL_SUCCESS/APPEAL_FAIL
  label VARCHAR(16) NOT NULL,           -- FRAUD/LEGIT
  source VARCHAR(32) NOT NULL,
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_feedback_event ON risk_feedback(event_id);
```

## 9. 核心流程（至少 3 条）
### 9.1 正常决策流程
1. 业务请求调用 `risk/evaluate`，带 eventId。
2. Feature Service 拉取实时特征（设备频次、IP 风险、历史拒付率等）。
3. Rule Engine 执行高优先级规则（黑名单、硬阈值）。
4. 模型评分服务返回风险分。
5. Decision Orchestrator 合成决策并返回。
6. 决策日志异步写入，回流数据仓库。

### 9.2 高峰流程（活动期间）
1. 请求暴涨导致模型服务延迟上升。
2. 系统自动降级：高风险规则优先，模型超时走规则兜底。
3. 风险阈值按活动策略临时调整（带灰度范围）。
4. 人审队列自动扩容，优先处理高金额边界样本。

### 9.3 故障恢复流程（误杀率突增）
1. 监控发现 challenge/reject 比例异常。
2. 快速定位到新规则版本或模型版本。
3. 一键回滚到上一个稳定版本。
4. 对受影响用户批量复核并触发补偿流程（如放行、道歉券）。

### 9.4 申诉与学习闭环
1. 用户申诉“正常交易被拒”。
2. 人审通过后改判 `LEGIT`。
3. 反馈写入训练样本，更新规则和模型阈值。
4. 下次相似用户被误杀概率降低。

## 10. 一致性与事务边界
### 10.1 一致性目标
- 决策结果必须可追溯（事件、规则命中、模型版本）。
- 决策日志可以最终一致写入，不阻塞主链路返回。

### 10.2 幂等边界
- `eventId` 为唯一评估键，重复请求返回同一决策。
- 人审提交按 `caseId + reviewerId + submitId` 幂等处理。

### 10.3 事务边界
- 决策返回与日志写入通过 outbox 解耦。
- 规则发布和配置变更需审计事务保证。

### 10.4 面试可复述
“风控主链路要快且稳，日志和分析链路可异步，但必须保证可追溯可重放。”

## 11. 可用性与容错
### 11.1 常见故障
- 模型服务超时。
- 特征服务局部不可用。
- 规则配置误发布。
- 人审系统积压。

### 11.2 容错策略
- 模型超时降级到规则决策。
- 特征缺失用默认值+风险加权兜底。
- 规则灰度发布 + 一键回滚。
- 人审队列优先级调度（高金额/高风险优先）。

### 11.3 RTO / RPO
- 风控决策服务 RTO：`<= 5 分钟`。
- 模型降级切换 RTO：秒级。
- 人审积压恢复 RTO：`<= 1 小时`（视人力弹性）。

## 12. 可观测性（指标 + 告警阈值）
### 12.1 主链路指标
- `risk_eval_qps`
- `risk_eval_latency_p95`
- `risk_eval_error_rate`

阈值示例：
- `risk_eval_latency_p95 > 50ms` 持续 10 分钟 -> P1
- `risk_eval_error_rate > 0.5%` 持续 5 分钟 -> P1

### 12.2 业务效果指标
- `reject_rate`
- `challenge_rate`
- `false_positive_rate`
- `false_negative_proxy`（如拒付率）

阈值示例：
- `false_positive_rate > 0.2%` -> P1
- `chargeback_rate` 日环比上升 > 20% -> P1

### 12.3 模型与规则健康
- `model_timeout_rate`
- `feature_missing_ratio`
- `rule_hit_distribution_shift`

阈值示例：
- `model_timeout_rate > 5%` 持续 5 分钟 -> P1
- `feature_missing_ratio > 3%` 持续 10 分钟 -> P1

## 13. 安全与合规
- PII 最小化采集与脱敏存储。
- 风控决策日志留存满足审计法规。
- 模型决策输出可解释理由（reason codes）。
- 高风险决策可人工复核，满足监管可申诉要求。
- 权限分层：规则编辑、发布、回滚需分离权限（四眼原则）。

## 14. 成本与取舍
### 14.1 成本构成
- 在线评分算力成本。
- 特征存储与流式计算成本。
- 人工审核成本。

### 14.2 关键取舍
- 阈值收紧：坏账下降但误杀上升。
- 阈值放宽：转化上升但风险上升。
- 全量人审最稳但成本不可承受，必须只审边界样本。

### 14.3 降本策略
- 多层决策：规则快筛 -> 模型细分 -> 人审兜底。
- 低风险直接放行，降低模型与人审压力。
- 模型蒸馏/轻量化，控制在线推断成本。

## 15. 关键代码（Java 更细 + 前端功能代码）
### 15.1 Java：规则引擎执行（优先级+短路）
```java
public class RuleEngineService {
    public RuleEvalResult evaluate(RiskContext ctx, List<RiskRule> rules) {
        List<String> hits = new ArrayList<>();
        for (RiskRule r : rules.stream().sorted(Comparator.comparingInt(RiskRule::getPriority).reversed()).toList()) {
            if (!"ENABLED".equals(r.getStatus())) continue;
            boolean matched = ruleExprExecutor.match(r.getExpr(), ctx);
            if (!matched) continue;
            hits.add(r.getRuleId());
            if ("REJECT".equals(r.getAction())) {
                return RuleEvalResult.reject(hits);
            }
            if ("CHALLENGE".equals(r.getAction())) {
                return RuleEvalResult.challenge(hits);
            }
        }
        return RuleEvalResult.pass(hits);
    }
}
```

### 15.2 Java：模型评分服务（超时降级）
```java
public class RiskModelService {
    public ModelScoreResult score(FeatureVector fv) {
        try {
            double s = modelClient.predict(fv, Duration.ofMillis(15));
            return ModelScoreResult.ok(s, "risk_v23");
        } catch (TimeoutException te) {
            return ModelScoreResult.timeoutFallback(0.5, "fallback_default"); // 降级中位风险分
        } catch (Exception ex) {
            return ModelScoreResult.errorFallback(0.5, "fallback_default");
        }
    }
}
```

### 15.3 Java：决策融合（规则+模型）
```java
public class DecisionOrchestrator {
    public DecisionResult decide(RiskContext ctx, RuleEvalResult ruleResult, ModelScoreResult modelResult) {
        if (ruleResult.isReject()) return DecisionResult.reject("RULE_REJECT", ruleResult.getHits(), modelResult);
        if (ruleResult.isChallenge()) {
            if (modelResult.getScore() >= 0.85) return DecisionResult.reject("RULE+MODEL_HIGH", ruleResult.getHits(), modelResult);
            return DecisionResult.challenge("RULE_CHALLENGE", ruleResult.getHits(), modelResult);
        }

        double score = modelResult.getScore();
        if (score >= 0.9) return DecisionResult.reject("MODEL_HIGH_RISK", ruleResult.getHits(), modelResult);
        if (score >= 0.7) return DecisionResult.challenge("MODEL_MEDIUM_RISK", ruleResult.getHits(), modelResult);
        if (score >= 0.6 && ctx.getAmount() > 100000) return DecisionResult.manualReview("HIGH_AMOUNT_BORDERLINE", ruleResult.getHits(), modelResult);
        return DecisionResult.allow("LOW_RISK", ruleResult.getHits(), modelResult);
    }
}
```

### 15.4 Java：人审闭环与反馈入模
```java
public class CaseReviewService {
    public void review(long caseId, long reviewerId, String result, String reason) {
        RiskCase c = caseRepo.findForUpdate(caseId);
        if (!"OPEN".equals(c.getStatus()) && !"IN_REVIEW".equals(c.getStatus())) {
            throw new IllegalStateException("case already closed");
        }
        caseRepo.updateResult(caseId, reviewerId, result, reason, "CLOSED");

        String label = "ALLOW".equals(result) ? "LEGIT" : "FRAUD";
        feedbackRepo.insert(c.getEventId(), "MANUAL_REVIEW", label, "CASE_REVIEW");
        trainingQueue.publish(new TrainingSampleTask(c.getEventId(), label));
    }
}
```

### 15.5 Java：误杀监控与自动阈值建议
```java
public class ThresholdAdvisorJob {
    public ThresholdSuggestion suggest(LocalDate dt) {
        Metrics m = metricsRepo.loadDaily(dt);
        double fpr = m.getFalsePositiveRate();
        double chargeback = m.getChargebackRate();

        double currentRejectThreshold = configRepo.getDouble("risk.reject.threshold");
        double next = currentRejectThreshold;
        if (fpr > 0.002 && chargeback < 0.004) {
            next = Math.min(0.95, currentRejectThreshold + 0.02); // 放松拒绝阈值
        } else if (chargeback > 0.006) {
            next = Math.max(0.80, currentRejectThreshold - 0.02); // 收紧拒绝阈值
        }
        return new ThresholdSuggestion(currentRejectThreshold, next, fpr, chargeback);
    }
}
```

### 15.6 前端（React + TypeScript）：人审案件工作台
```tsx
import { useEffect, useState } from "react";

type RiskCase = {
  caseId: number;
  eventId: string;
  scene: string;
  score: number;
  reasonCodes: string[];
  status: string;
};

export function RiskCaseReviewPanel() {
  const [cases, setCases] = useState<RiskCase[]>([]);
  const [msg, setMsg] = useState("");

  const loadCases = async () => {
    const resp = await fetch("/api/v1/risk/cases?status=OPEN&page=1&pageSize=20");
    if (resp.ok) {
      const data = await resp.json();
      setCases(data.items || []);
    }
  };

  useEffect(() => {
    loadCases();
  }, []);

  const submitReview = async (caseId: number, result: "ALLOW" | "REJECT") => {
    const resp = await fetch(`/api/v1/risk/cases/${caseId}/review`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ reviewerId: 7788, result, reason: "manual review decision" })
    });
    setMsg(resp.ok ? `案件 ${caseId} 已处理为 ${result}` : `处理失败: ${resp.status}`);
    if (resp.ok) loadCases();
  };

  return (
    <div>
      <h3>风险案件工作台</h3>
      {msg && <p>{msg}</p>}
      {cases.map((c) => (
        <div key={c.caseId}>
          <p>caseId={c.caseId} eventId={c.eventId} score={c.score}</p>
          <p>reasons={c.reasonCodes.join(",")}</p>
          <button onClick={() => submitReview(c.caseId, "ALLOW")}>放行</button>
          <button onClick={() => submitReview(c.caseId, "REJECT")}>拒绝</button>
        </div>
      ))}
    </div>
  );
}
```

### 15.7 前端（React + TypeScript）：规则灰度发布面板
```tsx
import { useState } from "react";

export function RulePublishPanel() {
  const [ruleId, setRuleId] = useState("RISK_DEVICE_VELOCITY_V3");
  const [grayPercent, setGrayPercent] = useState("20");
  const [msg, setMsg] = useState("");

  const publish = async () => {
    const resp = await fetch("/api/v1/risk/rules/publish", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        ruleId,
        status: "ENABLED",
        grayPercent: Number(grayPercent),
        effectiveAt: new Date(Date.now() + 60_000).toISOString()
      })
    });
    setMsg(resp.ok ? "规则发布成功（灰度中）" : `发布失败: ${resp.status}`);
  };

  return (
    <div>
      <h3>规则发布</h3>
      <input value={ruleId} onChange={(e) => setRuleId(e.target.value)} />
      <input value={grayPercent} onChange={(e) => setGrayPercent(e.target.value)} />
      <button onClick={publish}>发布规则</button>
      {msg && <p>{msg}</p>}
    </div>
  );
}
```

## 16. 测试策略
### 16.1 单元测试
- 规则表达式命中逻辑。
- 状态融合决策边界（阈值附近）。
- 幂等行为（eventId 重复请求）。

### 16.2 集成测试
- 特征拉取 -> 规则 -> 模型 -> 决策 -> 日志全链路。
- 模型超时降级路径。
- 人审回写 -> 反馈入模链路。

### 16.3 压测
- 120k QPS 评估请求压测。
- 高比例 challenge/reject 场景人审队列压力压测。
- 规则热更新时延与稳定性压测。

### 16.4 故障注入
- 模型服务整体超时。
- 特征服务部分缺失。
- 规则配置误发（自动回滚演练）。

## 17. 丰富例子（至少 10 个）
1. 新设备 + 异地 IP + 大额支付，触发挑战而非直接拒绝。  
2. 同设备 1 分钟 20 次注册尝试，命中频次规则直接拒绝。  
3. 支付模型分高但白名单用户，策略放行并记录观察。  
4. 人审发现误杀，改判后回流样本降低未来误杀。  
5. 拒付结果回流后，某规则阈值自动收紧。  
6. 模型服务超时时系统回退规则，主链路不超时。  
7. 活动期转化压力大，灰度放宽挑战阈值并观察坏账变化。  
8. 某规则发布后误杀率飙升，1 分钟内回滚到旧版本。  
9. 设备指纹频繁切换 + 共享收货地址命中图风险规则。  
10. 申诉成功用户加入短期白名单，防止连续误杀。  
11. 黑产利用代理 IP 切换规避规则，模型仍识别行为模式。  
12. 人审队列爆满时按金额和风险分优先级处理。  

## 18. 面试追问 + 可复述回答
### Q1：如何平衡误杀和漏判？
可复述：  
“分层决策：高风险拒绝、中风险挑战、低风险放行，并用业务指标动态调阈值。”

### Q2：规则和模型冲突怎么办？
可复述：  
“硬规则优先（合规/黑名单），其余由融合器按策略分级决策，并保留解释原因。”

### Q3：模型退化怎么发现？
可复述：  
“看漂移指标、拒付率变化、误杀率和 A/B 对照，异常时自动降级或回滚模型版本。”

### Q4：为什么还要人审？
可复述：  
“边界样本机器难判断，人审用于兜底和打标签，是提升系统长期效果的关键闭环。”

### Q5：如何防止攻击者绕过规则？
可复述：  
“规则+模型组合、多维特征、图关系、实时反馈迭代，单一规则很容易被绕过。”

### Q6：风控结果怎么向业务解释？
可复述：  
“返回命中规则和 reason code，不暴露攻击细节但可支持客服与申诉处理。”

## 19. 新手学习路线
### 第 1 周：规则风控
- 做登录/支付场景基础规则（频次、黑名单、金额阈值）。
- 做风控决策 API 和决策日志。

### 第 2 周：模型接入
- 接入简单二分类模型评分。
- 实现规则+模型融合决策。

### 第 3 周：人审与反馈
- 做案件队列与审核台。
- 打通拒付/申诉反馈回流。

### 第 4 周：工程化
- 做灰度发布、回滚、告警、漂移监控。
- 完整讲一遍“误杀/漏判平衡 + 闭环优化”面试话术。

## 20. 上场前 Checklist
- [ ] 我能讲清风险决策链路的时延预算。  
- [ ] 我能解释规则、模型、人审三层各自职责。  
- [ ] 我能说清误杀率与漏判率如何监控和调优。  
- [ ] 我能给出至少 3 个可执行告警阈值。  
- [ ] 我能描述模型超时降级和规则回滚流程。  
- [ ] 我能讲清拒付/申诉如何回流训练。  
- [ ] 我能说明决策可解释和合规要求。  
- [ ] 我能展示前端审核台如何处理边界案件。  

## 21. 30 秒总结
反欺诈系统高分答案是：  
“规则负责快速止血，模型负责识别复杂风险，人审负责边界兜底；再用拒付与申诉反馈持续迭代阈值和策略，在误杀、漏判、转化和坏账之间找到可运营平衡点。”  
把这句话落到延迟预算、状态流程、阈值告警和代码实现，你的面试答案就会非常有实战可信度。  
