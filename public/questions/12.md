# Q12 用户系统设计（高频）

## 1. 三句话题目本质
1. 用户系统是所有业务的入口，核心是“安全登录 + 权限控制 + 会话管理 + 审计追踪”。  
2. 难点在于高并发认证、跨端登录态一致、账号安全与风控平衡。  
3. 面试要讲清：认证怎么做、授权怎么做、会话怎么做、被攻击时怎么兜底。  

## 2. 一个真实场景故事
你负责一个中大型 SaaS 平台，用户登录峰值 1.5 万 QPS。某次短信验证码通道抖动，导致登录失败率暴涨；随后又出现撞库攻击。你重构后引入“多因子认证 + 风险分级 + 会话中心 + 统一审计”，登录成功率恢复到 99%+，攻击请求拦截率显著提升。  

## 3. 术语白话表（新手可懂）
1. Authentication：认证，证明“你是谁”。  
2. Authorization：授权，决定“你能做什么”。  
3. OAuth2：第三方授权协议。  
4. OIDC：在 OAuth2 上补身份信息。  
5. JWT：自包含令牌，适合无状态鉴权。  
6. Refresh Token：刷新访问令牌的长效凭证。  
7. RBAC：按角色授权。  
8. ABAC：按属性授权（部门、地域、时间等）。  
9. MFA：多因子认证（密码+短信/设备）。  
10. Session Fixation：会话固定攻击。  
11. Credential Stuffing：撞库攻击。  
12. Audit Trail：审计轨迹，记录谁在何时做了什么。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 注册、登录、登出、找回密码。  
2. 支持多种登录方式（密码、短信、SSO）。  
3. 支持角色与权限管理。  
4. 支持多端会话管理（踢人、续期、下线）。  
5. 支持安全审计和异常登录告警。  

### 4.2 非功能需求
1. 高可用认证链路。  
2. 低延迟鉴权。  
3. 强安全（防撞库、防劫持、防重放）。  
4. 可审计可追责。  

### 4.3 不做范围
1. 不做支付清结算。  
2. 不做复杂推荐系统。  
3. 不实现企业级 IAM 全套控制面。  

### 4.4 SLO/SLA
1. 登录接口 P95 < 120ms。  
2. 鉴权接口 P95 < 30ms。  
3. 认证链路可用性 >= 99.95%。  

## 5. 容量估算（数字推导）
假设 2000 万注册用户，日活 300 万：  
1. 日登录请求约 4500 万次，平均约 520 QPS。  
2. 峰值按 20 倍（早晚高峰）约 1 万 QPS。  
3. Token 校验请求通常是登录的 10~20 倍，峰值可达 10~20 万 QPS。  
4. 审计日志按每请求 600B，日增约 27GB。  
5. 会话表按活跃 500 万会话，每条 300B，约 1.5GB（不含索引）。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`Auth API -> 身份校验 -> Token服务 -> Session存储 -> 权限服务 -> 业务网关`

### 6.2 完整版
1. Identity Service：账号、密码、绑定关系。  
2. Auth Service：登录、MFA、风控挑战。  
3. Token Service：签发 Access/Refresh Token。  
4. Session Service：会话生命周期管理。  
5. Policy Service：RBAC/ABAC 权限决策。  
6. SSO Gateway：企业身份联邦（SAML/OIDC）。  
7. Risk Engine：设备指纹、IP 信誉、行为评分。  
8. Audit Service：审计日志采集与检索。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `POST /v1/auth/login`  
2. `POST /v1/auth/refresh`  
3. `POST /v1/auth/logout`  
4. `GET /v1/auth/introspect`  
5. `POST /v1/policy/check`  

登录请求示例：
```json
{
  "username": "alice@example.com",
  "password": "******",
  "deviceId": "dvc-123",
  "captchaToken": "cap_xxx",
  "idempotencyKey": "login-20260224-alice-01"
}
```

登录响应示例：
```json
{
  "accessToken": "eyJ...",
  "refreshToken": "rf_...",
  "expiresInSec": 1800,
  "mfaRequired": false
}
```

错误码：`401_INVALID_CREDENTIAL`、`403_RISK_CHALLENGE_REQUIRED`、`423_ACCOUNT_LOCKED`、`429_TOO_MANY_ATTEMPTS`。  

## 8. 数据模型（实体、索引、分片分区）
1. `user_account`：用户基础身份信息、状态。  
2. `user_credential`：密码哈希、盐、算法版本。  
3. `user_session`：会话 ID、设备、过期时间、状态。  
4. `role_binding`：用户-角色映射。  
5. `permission_policy`：资源、动作、条件表达式。  
6. `risk_event`：登录风险分、命中规则。  
7. `audit_log`：行为审计事件。  
8. 索引：`idx_user_login_name`、`idx_session_user_expire`、`idx_audit_actor_time`。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：账号密码校验 -> 风险评估 -> 通过则签发 Token -> 写会话 -> 返回。  
2. 高峰：登录洪峰时先走验证码和漏斗限流 -> 非核心接口降级 -> 扩容 Auth 节点。  
3. 故障恢复：短信通道不可用 -> 切备用通道/邮箱 OTP -> 失败请求排队重试并告警。  

## 10. 一致性与事务边界
1. 登录成功与会话写入需同事务或 Outbox 补偿。  
2. 权限变更可秒级生效，允许极短缓存窗口。  
3. Token 撤销采用黑名单或版本号方案确保立即失效。  
4. 审计日志可异步落库但不可丢。  

## 11. 可用性与容错
1. Auth 服务多 AZ 部署。  
2. 依赖故障时降级策略：限制高风险登录、保留已登录用户续期。  
3. MFA 通道双活（短信 + 邮件/Authenticator）。  
4. 密码校验库高可用读写分离。  
5. RTO 15 分钟，RPO 5 分钟。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `login_success_rate`  
2. `auth_p95_ms`  
3. `mfa_challenge_rate`  
4. `invalid_token_rate`  
5. `risk_block_rate`  

告警阈值：  
1. 登录成功率 < 97%（10分钟）-> P1。  
2. 登录 P95 > 200ms（10分钟）-> P1。  
3. 风险拦截率突增 3 倍（10分钟）-> P2。  
4. 无效令牌率 > 5%（10分钟）-> P2。  

处置：切换通道 -> 限流 -> 临时风控策略 -> 恢复后回放和复盘。  

## 13. 安全与合规
1. 密码强哈希（Argon2/Bcrypt）+ 盐。  
2. 登录防爆破（IP/账号维度限速）。  
3. Token 最小权限 + 短有效期。  
4. 敏感操作二次认证。  
5. 审计日志满足合规保留策略。  

## 14. 成本与取舍
1. JWT 无状态快但撤销难；会话中心撤销易但要状态存储。  
2. MFA 安全高但会增加登录摩擦。  
3. 风控严格减少损失但可能误伤，需要灰度和申诉通道。  
4. 审计全量存储成本高，可分级留存。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 密码校验与升级
```java
public class PasswordVerifier {
    public boolean verifyAndUpgrade(String raw, Credential cred, Consumer<String> upgradeHash) {
        boolean ok = Argon2.verify(raw, cred.hash(), cred.salt());
        if (ok && cred.algorithmVersion() < 3) {
            String newHash = Argon2.hash(raw, cred.salt(), 3);
            upgradeHash.accept(newHash);
        }
        return ok;
    }
}
```

### 15.2 登录限流
```java
public class LoginRateLimiter {
    private final CacheClient cache;

    public boolean allow(String key, int limitPerMin) {
        long count = cache.incr("login:limit:" + key, 60);
        return count <= limitPerMin;
    }
}
```

### 15.3 Token 签发与撤销版本
```java
public class TokenIssuer {
    public String issue(long userId, int tokenVersion, Duration ttl) {
        Map<String, Object> claims = Map.of("uid", userId, "ver", tokenVersion, "exp", Instant.now().plus(ttl).getEpochSecond());
        return JwtSigner.sign(claims);
    }

    public boolean valid(Map<String, Object> claims, int currentVersion) {
        return ((Number) claims.get("ver")).intValue() == currentVersion;
    }
}
```

### 15.4 权限决策
```java
public class PolicyEngine {
    public boolean allow(UserContext ctx, String resource, String action, List<Policy> policies) {
        for (Policy p : policies) {
            if (p.match(resource, action, ctx.attributes())) return p.effect() == Effect.ALLOW;
        }
        return false;
    }
}
```

### 15.5 会话踢出
```java
public class SessionService {
    private final SessionRepo repo;

    public void kickAll(long userId, String reason) {
        List<String> sessionIds = repo.findActiveSessions(userId);
        for (String sid : sessionIds) repo.markRevoked(sid, reason);
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 登录安全看板（React + TS）
```tsx
type AuthMetrics = { loginSuccessRate: number; p95Ms: number; riskBlockRate: number };

export function AuthDashboard() {
  const [m, setM] = useState<AuthMetrics | null>(null);
  useEffect(() => { fetch("/api/auth/metrics").then(r => r.json()).then(setM); }, []);
  if (!m) return <div>loading...</div>;
  return <div>成功率:{m.loginSuccessRate}% P95:{m.p95Ms}ms 风险拦截:{m.riskBlockRate}%</div>;
}
```

### 16.2 会话管理页（React + TS）
```tsx
export function SessionManagePage() {
  const [userId, setUserId] = useState("10001");
  async function kickAll() {
    await fetch(`/api/auth/users/${userId}/sessions/kick-all`, { method: "POST" });
    alert("已执行全端下线");
  }
  return (
    <div>
      <input value={userId} onChange={e => setUserId(e.target.value)} />
      <button onClick={kickAll}>踢出全部会话</button>
    </div>
  );
}
```

## 17. 测试策略
1. 单测：密码校验、Token 版本撤销、权限决策。  
2. 集成：登录 -> 鉴权 -> 授权 -> 审计全链路。  
3. 压测：登录峰值与鉴权峰值分开压测。  
4. 故障演练：MFA 通道故障、缓存故障、风控误判。  
5. 安全测试：撞库、暴力破解、重放攻击。  

## 18. 丰富例子（面试可复述）
1. 忘记密码流程如何避免被探测账号是否存在。  
2. 多端同时登录如何统一管理。  
3. 角色变更后权限如何秒级生效。  
4. Token 泄漏如何紧急失效。  
5. SSO 供应商故障如何降级。  
6. 风控误杀正常用户如何申诉。  
7. 审计日志暴增如何降本。  
8. 登录成功率突然下跌如何排查。  
9. 短信网关抖动如何切备通道。  
10. 用户频繁切换 IP 是否直接封禁。  
11. 设备丢失后如何强制下线。  
12. 密码算法升级如何平滑迁移。  

## 19. 面试追问+回答模板
1. 问：JWT 和 Session 怎么选？  
答：高并发 API 可用 JWT，安全敏感业务配合会话中心和版本撤销。  
2. 问：权限模型为什么不只用 RBAC？  
答：RBAC 简单但粗粒度，复杂场景要 ABAC 做条件控制。  
3. 问：最关键的安全防线是什么？  
答：限流防爆破 + MFA + 风险引擎 + 审计追踪。  

## 20. 新手学习路线
1. 先掌握认证与授权区别。  
2. 学 Token 与 Session 模式。  
3. 学 RBAC/ABAC。  
4. 学 MFA 与风控。  
5. 学审计与合规。  

## 21. 上场前Checklist
1. 能讲清登录链路和失败分支。  
2. 能讲清权限模型。  
3. 能给出安全阈值和告警动作。  
4. 能讲清会话撤销策略。  
5. 能讲出与母题差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q93 Fraud Detection System`。  

### 22.2 共性能力
1. 都强调安全与风控。  
2. 都依赖规则与模型协同。  
3. 都需要实时决策和审计。  
4. 都需要误杀/漏判平衡。  

### 22.3 关键差异
1. Q12 以身份认证授权为主；Q93 以欺诈识别为主。  
2. Q12 更重会话和权限语义；Q93 更重特征与风险评分。  
3. Q12 面向全体用户访问入口；Q93 面向高风险行为拦截。  
4. Q12 关键指标是登录成功率/鉴权时延；Q93 关键是欺诈拦截率。  
5. Q12 不必深入模型训练细节。  

### 22.4 本题新增必补知识
1. Token 与 Session 混合架构。  
2. RBAC/ABAC 权限设计。  
3. SSO 与联邦身份。  
4. 会话治理（踢人、续期、撤销）。  
5. 安全审计与合规留痕。  

### 22.5 面试差异话术
1. “Q12 是身份入口系统，目标是安全且顺畅地让用户进系统。”  
2. “Q93 是风险判定系统，目标是识别并阻断欺诈行为。”  
3. “讲 Q12 要重点说认证授权会话，不是讲风控模型训练流程。”  
