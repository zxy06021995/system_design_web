# Design Ticket Booking - 订票系统（母题）

> 对应题：Q11 `订票系统`  
> 迁移价值：这题吃透后，可覆盖票务、抢购、限量库存、资源预占、支付确认、超时回收等一整类交易系统题。

---

## 1. 题目边界（先定范围）

### 1.1 P0 功能
1. 演出/场次信息查询。
2. 座位图查询与可售状态展示。
3. 锁座（Hold）并设置倒计时。
4. 下单与支付确认。
5. 出票（电子票码）与订单状态查询。
6. 超时自动释放座位，防止库存被长期占用。

### 1.2 P1 功能
1. 改签、退票。
2. 候补（waitlist）。
3. 多级票价与优惠券。
4. 实名校验与防黄牛能力。

### 1.3 非功能目标（面试必须量化）
1. 高峰读 QPS：`>= 100,000`（座位图/场次页）。
2. 抢票写峰值：`>= 1,000,000` 请求/秒（入口）。
3. 核心下单链路可用性：`>= 99.99%`。
4. 库存一致性：`零超卖`（P0）。
5. 锁座接口 P95 `< 200ms`，P99 `< 500ms`。

---

## 2. 容量估算（必须算）

### 2.1 假设
1. DAU：`10,000,000`。
2. 日浏览：`50,000,000`。
3. 日订单：`1,000,000`。
4. 热门场次：`100,000` 座位，开售 1 分钟内抢空。

### 2.2 估算
1. 浏览平均 QPS：`50,000,000 / 86400 ≈ 579`，活动峰值按 20 倍近似 `~11,500`。
2. 抢票入口峰值按活动突刺建模，可达 `1,000,000` 请求/秒。
3. 日订单写入：`1,000,000`，峰值下单可短时 `5,000+ QPS`。
4. 订单存储：`1M * 2KB * 365 ≈ 730GB/年`（未含索引和备份）。

### 2.3 结论
1. 入口必须限流 + 排队，不能把所有请求直接打到库存库。
2. 库存状态必须分层：Redis 快速判断 + DB 最终一致校验。
3. 关键是“锁座 + 超时释放 + 支付确认”的状态机要严谨。

---

## 3. 核心状态机（面试加分点）

### 3.1 座位状态
1. `AVAILABLE`：可售。
2. `HELD`：已锁定，等待支付。
3. `SOLD`：已售。
4. `REFUND_PENDING`：退票处理中（可选）。

### 3.2 锁座状态
1. `ACTIVE`：锁定有效。
2. `EXPIRED`：超时失效。
3. `CONFIRMED`：已转订单。
4. `RELEASED`：主动释放。

### 3.3 订单状态
1. `INIT`：创建中。
2. `PENDING_PAY`：待支付。
3. `PAID`：支付成功。
4. `TICKETED`：已出票。
5. `CANCELLED`：取消。
6. `REFUNDED`：已退款。

状态约束：
1. `SOLD` 必须由 `HELD -> CONFIRMED -> PAID` 路径推进。
2. `EXPIRED/RELEASED` 锁座不能再创建有效订单。
3. 支付回调必须幂等处理。

---

## 4. 高层架构

```text
Client/App
   |
   v
CDN + WAF + Captcha
   |
   v
API Gateway (auth/rate-limit/anti-bot)
   |-----------------------------|
   v                             v
Search/Read Service          Booking Command Service
   |                             |
   v                             v
Redis Seat Snapshot         Queue (Kafka/RocketMQ)
   |                             |
   v                             v
MySQL Read Replica          Booking Worker
                                 |
                                 v
                         Seat Lock Service (Redis + DB Tx)
                                 |
                                 v
                             Order Service
                                 |
                                 v
                           Payment Adapter
                                 |
                                 v
                           Ticket Issuer
                                 |
                                 v
                      Notification + Audit + Metrics
```

设计要点：
1. 抢票入口请求先过网关限流和排队，再进入核心锁座逻辑。
2. 读链路和写链路分离，保证读高并发不影响库存一致性。
3. 支付与出票异步化，主链路只承诺“状态正确推进”。

---

## 5. 数据模型（核心表）

### 5.1 演出与场次

```sql
CREATE TABLE event_show (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  show_id VARCHAR(64) NOT NULL,
  title VARCHAR(256) NOT NULL,
  venue_id VARCHAR(64) NOT NULL,
  city VARCHAR(64) NOT NULL,
  start_time DATETIME NOT NULL,
  sale_start_time DATETIME NOT NULL,
  sale_end_time DATETIME NOT NULL,
  status TINYINT NOT NULL DEFAULT 1, -- 1=on_sale,2=offline
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_show_id (show_id),
  KEY idx_city_time (city, start_time)
) ENGINE=InnoDB;
```

### 5.2 座位表（关键）

```sql
CREATE TABLE seat_inventory (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  show_id VARCHAR(64) NOT NULL,
  seat_id VARCHAR(64) NOT NULL,
  section_id VARCHAR(64) NOT NULL,
  row_num INT NOT NULL,
  col_num INT NOT NULL,
  price_cents INT NOT NULL,
  status TINYINT NOT NULL DEFAULT 0, -- 0=available,1=held,2=sold
  version INT NOT NULL DEFAULT 0,    -- 乐观锁版本
  hold_id VARCHAR(64) NULL,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_show_seat (show_id, seat_id),
  KEY idx_show_status (show_id, status),
  KEY idx_hold_id (hold_id)
) ENGINE=InnoDB;
```

### 5.3 锁座表

```sql
CREATE TABLE seat_hold (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  hold_id VARCHAR(64) NOT NULL,
  show_id VARCHAR(64) NOT NULL,
  user_id VARCHAR(64) NOT NULL,
  seat_ids JSON NOT NULL,
  total_price_cents INT NOT NULL,
  status TINYINT NOT NULL DEFAULT 0, -- 0=active,1=expired,2=confirmed,3=released
  expiry_time DATETIME NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_hold_id (hold_id),
  KEY idx_user (user_id),
  KEY idx_expiry_status (expiry_time, status)
) ENGINE=InnoDB;
```

### 5.4 订单表

```sql
CREATE TABLE ticket_order (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  order_id VARCHAR(64) NOT NULL,
  hold_id VARCHAR(64) NOT NULL,
  show_id VARCHAR(64) NOT NULL,
  user_id VARCHAR(64) NOT NULL,
  amount_cents INT NOT NULL,
  status TINYINT NOT NULL, -- 0=init,1=pending_pay,2=paid,3=ticketed,4=cancelled,5=refunded
  payment_id VARCHAR(64) NULL,
  idempotency_key VARCHAR(64) NOT NULL,
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_order_id (order_id),
  UNIQUE KEY uk_idem (idempotency_key),
  KEY idx_user_time (user_id, created_at)
) ENGINE=InnoDB;
```

### 5.5 出票表

```sql
CREATE TABLE issued_ticket (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  ticket_code VARCHAR(64) NOT NULL,
  order_id VARCHAR(64) NOT NULL,
  show_id VARCHAR(64) NOT NULL,
  seat_id VARCHAR(64) NOT NULL,
  qr_payload VARCHAR(512) NOT NULL,
  status TINYINT NOT NULL DEFAULT 1, -- 1=valid,2=used,3=invalid
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_ticket_code (ticket_code),
  UNIQUE KEY uk_order_seat (order_id, seat_id)
) ENGINE=InnoDB;
```

---

## 6. API 设计

### 6.1 查询场次与座位图

```http
GET /api/v1/shows/{showId}
GET /api/v1/shows/{showId}/seats
```

### 6.2 锁座

```http
POST /api/v1/shows/{showId}/holds
Headers:
  X-Request-Id: req_20260223_11001
Body:
{
  "userId": "u_10001",
  "seatIds": ["A-1-01","A-1-02"],
  "holdSeconds": 600
}
```

返回：

```json
{
  "holdId": "HOLD_20260223_001",
  "expiryTime": "2026-02-23T10:10:00Z",
  "totalPriceCents": 256000
}
```

### 6.3 创建订单

```http
POST /api/v1/orders
Headers:
  X-Idempotency-Key: idem_abc_001
Body:
{
  "holdId": "HOLD_20260223_001",
  "userId": "u_10001",
  "contact": {"name":"张三","phone":"13800000000"}
}
```

### 6.4 支付回调

```http
POST /api/v1/payments/callback
Body:
{
  "paymentId":"pay_001",
  "orderId":"ord_001",
  "status":"SUCCESS",
  "signature":"..."
}
```

### 6.5 查询订单

```http
GET /api/v1/orders/{orderId}
```

---

## 7. 核心链路一：锁座（防超卖关键）

1. 网关防刷、验证码、人机校验。
2. 限流通过后进入排队队列（削峰）。
3. Worker 处理请求，先 Redis 快速检查座位可售状态。
4. 对 seatId 排序后依次获取分布式锁（避免死锁）。
5. 事务中二次校验 DB 座位状态与版本号。
6. 批量更新 `seat_inventory` 为 `HELD` 并写 `hold_id`。
7. 写入 `seat_hold`，设置 `expiry_time`。
8. 写 Redis `seat:status`（TTL = holdSeconds）。
9. 投递“超时释放任务”到延迟队列。

为什么要双重检查：
1. Redis 只是快速判断，可能短时不一致。
2. DB 状态才是最终真相，必须以事务检查兜底。

---

## 8. 核心链路二：下单与支付

1. 客户端携带 `idempotencyKey` 创建订单。
2. 服务端检查 `seat_hold`：
   1. 状态必须 `ACTIVE`。
   2. `expiry_time` 必须未过期。
   3. userId 必须匹配。
3. 事务内创建 `ticket_order`（`PENDING_PAY`）。
4. 调用支付渠道（同步返回受理结果）。
5. 支付成功回调时：
   1. 幂等校验（paymentId/orderId）。
   2. 订单转 `PAID`。
   3. 锁座状态转 `CONFIRMED`。
   4. 座位状态从 `HELD` 转 `SOLD`。
   5. 异步触发出票任务。

---

## 9. 核心链路三：超时释放

1. 锁座创建时写延迟消息（例如 10 分钟后触发）。
2. 释放任务执行时再次查询 `seat_hold`：
   1. 若已 `CONFIRMED`，直接跳过。
   2. 若仍 `ACTIVE` 且过期，则释放。
3. 事务更新：
   1. `seat_hold` -> `EXPIRED`。
   2. `seat_inventory` 中对应座位 `HELD` -> `AVAILABLE`。
4. 清理 Redis `seat:status`，回补库存计数。

---

## 10. 一致性方案与取舍

### 10.1 为什么不是只靠 Redis 扣库存
1. Redis 扣减快，但无法单独保证每个具体座位不重复售卖。
2. 座位系统是“离散资源”，需要 seat 级别状态转移。
3. 因此 Redis 只做加速和预判，DB 事务负责最终一致。

### 10.2 锁策略
1. 分布式锁：控制并发抢同一 seatId。
2. 乐观锁版本号：防止并发写覆盖。
3. 唯一键约束：防止重复订单/重复出票。

### 10.3 幂等策略
1. 下单接口：`X-Idempotency-Key`。
2. 支付回调：`paymentId + orderId` 唯一。
3. 出票任务：`orderId + seatId` 唯一索引保证不重复发券。

---

## 11. Java 关键代码（面试可讲可写）

### 11.1 锁座服务

```java
@Service
public class SeatHoldService {
    private final RedissonClient redisson;
    private final SeatInventoryRepository seatInventoryRepository;
    private final SeatHoldRepository seatHoldRepository;
    private final StringRedisTemplate redisTemplate;
    private final DelayTaskPublisher delayTaskPublisher;

    public SeatHoldService(RedissonClient redisson,
                           SeatInventoryRepository seatInventoryRepository,
                           SeatHoldRepository seatHoldRepository,
                           StringRedisTemplate redisTemplate,
                           DelayTaskPublisher delayTaskPublisher) {
        this.redisson = redisson;
        this.seatInventoryRepository = seatInventoryRepository;
        this.seatHoldRepository = seatHoldRepository;
        this.redisTemplate = redisTemplate;
        this.delayTaskPublisher = delayTaskPublisher;
    }

    @Transactional
    public HoldResult holdSeats(HoldCommand cmd) {
        List<String> sortedSeatIds = cmd.seatIds().stream().sorted().toList();
        List<RLock> locks = new ArrayList<>();
        try {
            for (String seatId : sortedSeatIds) {
                RLock lock = redisson.getLock("seat:lock:" + cmd.showId() + ":" + seatId);
                if (!lock.tryLock(3, 15, TimeUnit.SECONDS)) {
                    throw new BusinessException("seat lock failed: " + seatId);
                }
                locks.add(lock);
            }

            List<SeatInventory> seats = seatInventoryRepository.findByShowAndSeatIdsForUpdate(cmd.showId(), sortedSeatIds);
            if (seats.size() != sortedSeatIds.size()) {
                throw new BusinessException("some seats not found");
            }
            for (SeatInventory seat : seats) {
                if (seat.getStatus() != SeatStatus.AVAILABLE) {
                    throw new BusinessException("seat unavailable: " + seat.getSeatId());
                }
            }

            String holdId = Ids.holdId();
            LocalDateTime expiry = LocalDateTime.now().plusSeconds(cmd.holdSeconds());

            int updated = seatInventoryRepository.batchHold(cmd.showId(), sortedSeatIds, holdId);
            if (updated != sortedSeatIds.size()) {
                throw new BusinessException("hold failed by concurrent update");
            }

            int totalPrice = seats.stream().mapToInt(SeatInventory::getPriceCents).sum();
            seatHoldRepository.insert(new SeatHoldEntity(holdId, cmd.showId(), cmd.userId(), sortedSeatIds, totalPrice, HoldStatus.ACTIVE, expiry));

            for (String seatId : sortedSeatIds) {
                redisTemplate.opsForValue().set(
                        "seat:status:" + cmd.showId() + ":" + seatId,
                        "held",
                        Duration.ofSeconds(cmd.holdSeconds())
                );
            }

            delayTaskPublisher.publishReleaseTask(new ReleaseHoldTask(holdId), cmd.holdSeconds());
            return new HoldResult(holdId, expiry, totalPrice);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new BusinessException("interrupted while locking seats");
        } finally {
            for (RLock lock : locks) {
                if (lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        }
    }
}
```

### 11.2 下单服务（幂等）

```java
@Service
public class OrderService {
    private final SeatHoldRepository seatHoldRepository;
    private final TicketOrderRepository ticketOrderRepository;

    public OrderService(SeatHoldRepository seatHoldRepository,
                        TicketOrderRepository ticketOrderRepository) {
        this.seatHoldRepository = seatHoldRepository;
        this.ticketOrderRepository = ticketOrderRepository;
    }

    @Transactional
    public CreateOrderResult createOrder(CreateOrderCommand cmd) {
        TicketOrder existed = ticketOrderRepository.findByIdempotencyKey(cmd.idempotencyKey());
        if (existed != null) {
            return new CreateOrderResult(existed.getOrderId(), existed.getStatus().name());
        }

        SeatHoldEntity hold = seatHoldRepository.findByHoldIdForUpdate(cmd.holdId());
        if (hold == null || hold.getStatus() != HoldStatus.ACTIVE) {
            throw new BusinessException("hold invalid");
        }
        if (hold.getExpiryTime().isBefore(LocalDateTime.now())) {
            throw new BusinessException("hold expired");
        }
        if (!Objects.equals(hold.getUserId(), cmd.userId())) {
            throw new BusinessException("hold user mismatch");
        }

        String orderId = Ids.orderId();
        TicketOrder order = TicketOrder.pendingPay(orderId, hold.getHoldId(), hold.getShowId(), hold.getUserId(), hold.getTotalPriceCents(), cmd.idempotencyKey());
        ticketOrderRepository.insert(order);
        return new CreateOrderResult(orderId, OrderStatus.PENDING_PAY.name());
    }
}
```

### 11.3 支付回调处理（幂等推进状态）

```java
@Service
public class PaymentCallbackService {
    private final TicketOrderRepository ticketOrderRepository;
    private final SeatHoldRepository seatHoldRepository;
    private final SeatInventoryRepository seatInventoryRepository;
    private final TicketIssuePublisher ticketIssuePublisher;

    public PaymentCallbackService(TicketOrderRepository ticketOrderRepository,
                                  SeatHoldRepository seatHoldRepository,
                                  SeatInventoryRepository seatInventoryRepository,
                                  TicketIssuePublisher ticketIssuePublisher) {
        this.ticketOrderRepository = ticketOrderRepository;
        this.seatHoldRepository = seatHoldRepository;
        this.seatInventoryRepository = seatInventoryRepository;
        this.ticketIssuePublisher = ticketIssuePublisher;
    }

    @Transactional
    public void onPaymentSuccess(PaymentCallback callback) {
        TicketOrder order = ticketOrderRepository.findByOrderIdForUpdate(callback.orderId());
        if (order == null) {
            throw new BusinessException("order not found");
        }

        if (order.getStatus() == OrderStatus.PAID || order.getStatus() == OrderStatus.TICKETED) {
            // 幂等回放直接返回
            return;
        }
        if (order.getStatus() != OrderStatus.PENDING_PAY) {
            throw new BusinessException("invalid order status: " + order.getStatus());
        }

        SeatHoldEntity hold = seatHoldRepository.findByHoldIdForUpdate(order.getHoldId());
        if (hold == null || hold.getStatus() != HoldStatus.ACTIVE) {
            throw new BusinessException("hold invalid when callback");
        }

        ticketOrderRepository.markPaid(order.getOrderId(), callback.paymentId());
        seatHoldRepository.markConfirmed(hold.getHoldId());
        seatInventoryRepository.batchSold(hold.getShowId(), hold.getSeatIds(), hold.getHoldId());

        ticketIssuePublisher.publish(order.getOrderId());
    }
}
```

### 11.4 超时释放任务

```java
@Service
public class HoldReleaseJob {
    private final SeatHoldRepository seatHoldRepository;
    private final SeatInventoryRepository seatInventoryRepository;
    private final StringRedisTemplate redisTemplate;

    public HoldReleaseJob(SeatHoldRepository seatHoldRepository,
                          SeatInventoryRepository seatInventoryRepository,
                          StringRedisTemplate redisTemplate) {
        this.seatHoldRepository = seatHoldRepository;
        this.seatInventoryRepository = seatInventoryRepository;
        this.redisTemplate = redisTemplate;
    }

    @Transactional
    public void releaseIfExpired(String holdId) {
        SeatHoldEntity hold = seatHoldRepository.findByHoldIdForUpdate(holdId);
        if (hold == null) {
            return;
        }
        if (hold.getStatus() != HoldStatus.ACTIVE) {
            return;
        }
        if (hold.getExpiryTime().isAfter(LocalDateTime.now())) {
            return;
        }

        seatHoldRepository.markExpired(holdId);
        seatInventoryRepository.batchRelease(hold.getShowId(), hold.getSeatIds(), holdId);

        for (String seatId : hold.getSeatIds()) {
            redisTemplate.delete("seat:status:" + hold.getShowId() + ":" + seatId);
        }
    }
}
```

### 11.5 出票任务

```java
@Service
public class TicketIssueService {
    private final TicketOrderRepository ticketOrderRepository;
    private final IssuedTicketRepository issuedTicketRepository;
    private final SeatHoldRepository seatHoldRepository;

    public TicketIssueService(TicketOrderRepository ticketOrderRepository,
                              IssuedTicketRepository issuedTicketRepository,
                              SeatHoldRepository seatHoldRepository) {
        this.ticketOrderRepository = ticketOrderRepository;
        this.issuedTicketRepository = issuedTicketRepository;
        this.seatHoldRepository = seatHoldRepository;
    }

    @Transactional
    public void issue(String orderId) {
        TicketOrder order = ticketOrderRepository.findByOrderIdForUpdate(orderId);
        if (order == null) {
            throw new BusinessException("order not found");
        }
        if (order.getStatus() == OrderStatus.TICKETED) {
            return;
        }
        if (order.getStatus() != OrderStatus.PAID) {
            throw new BusinessException("order not paid");
        }

        SeatHoldEntity hold = seatHoldRepository.findByHoldId(order.getHoldId());
        for (String seatId : hold.getSeatIds()) {
            IssuedTicket t = new IssuedTicket(
                    Ids.ticketCode(),
                    orderId,
                    hold.getShowId(),
                    seatId,
                    QrCodec.encode(orderId, seatId)
            );
            issuedTicketRepository.insertIgnore(t); // 幂等
        }
        ticketOrderRepository.markTicketed(orderId);
    }
}
```

---

## 12. 防黄牛与公平性

1. 网关层：
   1. 人机校验（图形/行为验证码）。
   2. IP 与设备指纹限流。
   3. 黑名单策略。

2. 业务层：
   1. 单用户单场限购。
   2. 实名信息校验。
   3. 排队令牌（先排队后进核心链路）。

3. 数据层：
   1. 风险账户评分。
   2. 高频失败重试拦截。

---

## 13. 一致性与容错

### 13.1 强一致边界
1. seat 状态推进必须在事务内完成。
2. 订单状态推进与支付回调要可重入、可幂等。

### 13.2 最终一致边界
1. 座位图前端展示允许秒级延迟。
2. 通知与短信可异步。

### 13.3 常见故障与处理
1. 支付成功回调重复：幂等检查直接返回。
2. worker 崩溃导致释放任务延迟：定时补偿扫描 `expiry_time`。
3. Redis 短时不可用：降级到 DB 锁座（吞吐下降但正确性优先）。

---

## 14. 可观测性与告警

### 14.1 关键指标
1. 锁座成功率、平均锁座时延。
2. 超时释放成功率与延迟。
3. 订单支付成功率、支付回调重复率。
4. 库存不一致检查告警数。
5. 排队队列积压长度与等待时间。

### 14.2 告警阈值示例
1. 锁座失败率 > 5% 持续 3 分钟告警。
2. 超时释放任务延迟 > 60 秒告警。
3. 支付成功但未出票 > 100 单告警。
4. 库存校验发现异常立即 P0 告警。

---

## 15. 故障演练（要讲得出步骤）

### 演练1：热门场次突发百万流量
1. 动作：入口限流 + 排队令牌 + 降级非关键接口。
2. 观察：核心锁座成功率、排队等待时间。
3. 目标：不超卖、核心服务稳定。

### 演练2：支付渠道抖动
1. 动作：支付重试指数退避 + 回调补偿任务。
2. 观察：`PENDING_PAY` 长尾订单数量。
3. 目标：避免用户重复扣款，最终订单状态一致。

### 演练3：释放任务系统故障
1. 动作：启用 DB 扫描补偿（按 `expiry_time` 批量释放）。
2. 观察：过期 HOLD 堆积量。
3. 目标：30 分钟内清空过期锁座。

### 演练4：单库热点锁冲突
1. 动作：按 show 分片 + seat 维度锁粒度优化。
2. 观察：事务冲突率、重试次数。
3. 目标：锁冲突下降并恢复吞吐。

---

## 16. 与相近题的差异（少题覆盖）

1. 与 `秒杀系统`：
   1. 秒杀常是“总量库存”。
   2. 订票是“离散座位资源”，一致性复杂度更高。

2. 与 `酒店预订`：
   1. 酒店按房型/日期维度库存。
   2. 票务按 seatId 精确锁定，冲突热点更集中。

3. 与 `支付系统`：
   1. 订票题重点是库存锁定和释放。
   2. 支付题重点是资金一致性与对账。

4. 与 `Queue / MQ`：
   1. 订票只把 MQ 当削峰与异步编排工具。
   2. MQ 题本身会深挖分区、副本、语义保证。

---

## 17. 面试高频追问

1. 如何保证零超卖？
   1. seat 级状态机 + 事务更新。
   2. 分布式锁 + 乐观锁 + 唯一约束多层兜底。

2. 为什么需要 Hold 而不是直接下单扣座？
   1. 用户支付前需要短暂保留席位。
   2. Hold + expiry 可兼顾体验和库存利用率。

3. 回调重复如何处理？
   1. 以 `orderId/paymentId` 幂等去重。
   2. 状态机只允许合法前进，不允许回退覆盖。

4. 释放任务丢了怎么办？
   1. 延迟队列 + 定时扫描双保险。
   2. 任何时候以 DB `expiry_time + status` 纠偏。

5. 为什么还要 Redis？
   1. 快速可售预判、减少 DB 压力。
   2. 不是唯一真相，最终仍以 DB 为准。

---

## 18. 上场前 Checklist

1. 是否讲清了座位状态机和订单状态机。
2. 是否讲清了锁座、下单、支付、出票、释放的闭环。
3. 是否讲清了超卖防护的多层机制。
4. 是否给出幂等与重试策略。
5. 是否覆盖了反黄牛与公平排队。
6. 是否给出故障演练和回滚方案。
7. 是否给出关键监控指标和告警阈值。

---

## 19. 30秒总结

订票系统的本质不是“下单接口”，而是“有限离散资源的一致性分配系统”。  
核心答题主线：  
1. 用 `Hold + 过期释放` 管住资源生命周期。  
2. 用 `锁 + 事务 + 幂等` 保证不超卖、不重单。  
3. 用 `限流排队 + 异步编排 + 可观测补偿` 保证高峰稳定性。  

