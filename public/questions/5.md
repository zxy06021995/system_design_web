# Q5 Social Network - 社交网络数据结构（超高频）

## 1. 三句话题目本质
1. 这题核心是“如何用合适的数据结构表示人与人的关系，并支持高频查询”。  
2. 难点不是建一张用户表，而是关系图存储、共同好友计算、推荐和隐私控制。  
3. 面试官重点看你能不能在“读多写多”的社交场景里做出可扩展的图模型。  

## 2. 一个真实场景故事
你做一个校园社交 App，用户量从 20 万涨到 800 万。最初用关系型表 `user_friend(user_id, friend_id)`，查共同好友一次要跑多次 JOIN，P95 到了 2.8 秒。你重构后：  
1. 在线链路用 KV + 邻接表缓存查关系。  
2. 离线链路用图计算做推荐候选。  
3. 隐私策略单独抽成策略服务。  
结果共同好友查询 P95 降到 120ms，推荐点击率提升 18%。  

## 3. 术语白话表（新手可懂）
1. Social Graph：社交关系图，节点是人，边是关系。  
2. Directed Edge：单向边，比如“关注”。  
3. Undirected Edge：双向边，比如“好友”。  
4. Adjacency List：邻接表，记录“我连接了谁”。  
5. Mutual Friends：共同好友。  
6. Two-hop Neighbor：二跳关系（朋友的朋友）。  
7. Fan-out：把一条动态推给粉丝的过程。  
8. Privacy Scope：可见范围，如“仅好友可见”。  
9. Blocklist：拉黑列表。  
10. Graph Partition：图分片，把关系图拆到多个分片。  
11. Edge Weight：关系强度，比如互动频次。  
12. Cold Start：新用户没数据时的推荐问题。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持关注、取关、加好友、删好友。  
2. 支持共同好友查询、二跳推荐。  
3. 支持隐私设置（谁能看我、谁能加我）。  
4. 支持黑名单与关系屏蔽。  
5. 提供关系图相关统计接口。  

### 4.2 非功能需求
1. 高并发读写（关系写入、关系查询都高）。  
2. 关系查询低延迟（共同好友、是否好友）。  
3. 数据一致性可控（写后读在可接受窗口内收敛）。  
4. 可审计（隐私和封禁操作可追踪）。  

### 4.3 不做范围
1. 不做完整 timeline 推送系统。  
2. 不做实时音视频通讯。  
3. 不做复杂广告竞价。  

### 4.4 SLO/SLA
1. `isFriend` 查询 P95 < 20ms。  
2. 共同好友查询 P95 < 150ms。  
3. 关系写入成功率 >= 99.99%。  

## 5. 容量估算（数字推导）
假设 3000 万用户，人均 220 个关系边：  
1. 总边数约 66 亿（双向好友按两条边算）。  
2. 每条边存 64B 元数据，总体约 422GB（不含索引）。  
3. 日新增关系操作 1.2 亿次，平均约 1388/s。  
4. 峰值按 8 倍：约 1.1 万/s。  
5. 共同好友查询日请求 3 亿次，平均约 3472/s，峰值约 2.7 万/s。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`关系写入API -> 关系存储 -> 缓存层 -> 关系查询API -> 推荐候选服务`

### 6.2 完整版
1. Relationship API：关注/好友增删改。  
2. Graph Store：边存储（分片 KV 或图数据库）。  
3. Read Cache：热点邻接表与关系布隆过滤。  
4. Mutual Service：共同好友与二跳关系计算。  
5. Recommendation Service：候选召回 + 排序。  
6. Privacy Policy Service：可见范围、黑名单校验。  
7. Event Bus：关系变更事件下发到推荐和统计。  
8. Analytics：关系增长、社交活跃度、推荐效果。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `POST /v1/relationships/follow`  
2. `POST /v1/relationships/unfollow`  
3. `GET /v1/relationships/{uid}/mutual?with={target}`  
4. `GET /v1/relationships/{uid}/is-friend?target={target}`  
5. `POST /v1/privacy/block`  

请求示例：
```json
{
  "actorId": 1001,
  "targetId": 2002,
  "type": "FOLLOW",
  "idempotencyKey": "follow-1001-2002-20260224"
}
```

响应示例：
```json
{
  "success": true,
  "relationVersion": 987654,
  "effectiveAt": "2026-02-24T10:22:01Z"
}
```

错误码：`409_ALREADY_FOLLOWING`、`403_BLOCKED`、`429_RELATION_WRITE_LIMITED`、`503_GRAPH_SHARD_UNAVAILABLE`。  

## 8. 数据模型（实体、索引、分片分区）
1. `user_profile`：`user_id`、`status`、`privacy_mode`。  
2. `relation_edge`：`src_user`、`dst_user`、`edge_type`、`weight`、`created_at`。  
3. `relation_state`：`pair_key`、`state`（好友待确认/已确认/已删除）。  
4. `privacy_rule`：`user_id`、`rule_type`、`rule_value`。  
5. `block_edge`：`src_user`、`dst_user`、`reason`、`expire_at`。  
6. 索引：`idx_src_type(src_user,edge_type,created_at)`、`idx_dst(dst_user)`。  
7. 分片键：`src_user % N`，热点大 V 额外拆分（虚拟桶）。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常：关注请求 -> 隐私校验 -> 写边 -> 发事件 -> 缓存失效。  
2. 高峰：明星事件导致写峰值 -> 分层限流 + 异步确认 -> 热点用户关系桶拆分。  
3. 故障恢复：某分片不可用 -> 写请求降级入队 -> 分片恢复后回放并校验版本。  

## 10. 一致性与事务边界
1. 关注关系可最终一致，允许短暂读到旧值。  
2. 好友关系是双边状态机，必须保证成对更新可追溯。  
3. 隐私变更优先强一致（先生效策略，再放行读取）。  
4. 事件投递采用 Outbox，避免“写成功但事件丢失”。  

## 11. 可用性与容错
1. 读写分离，读侧缓存兜底。  
2. 熔断：分片错误率 > 30% 持续 3 分钟，切只读保护。  
3. 降级：共同好友计算超时时返回 Top-N 缓存结果。  
4. 重试：关系写入网络错误可重试，业务冲突错误不重试。  
5. RTO 20 分钟，RPO 2 分钟。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `relation_write_qps`  
2. `relation_write_error_rate`  
3. `mutual_query_p95_ms`  
4. `privacy_deny_rate`  
5. `cache_hit_ratio`  

告警阈值：  
1. 写入错误率 > 1%（5分钟）-> P1。  
2. 共同好友 P95 > 200ms（10分钟）-> P1。  
3. 缓存命中率 < 85%（15分钟）-> P2。  
4. 隐私拒绝率突增 3 倍（10分钟）-> P2（防策略误配）。  

处置：限流保护 -> 热点分片扩容 -> 缓存预热 -> 对账任务回补。  

## 13. 安全与合规
1. 隐私规则优先级高于关系查询结果。  
2. 拉黑关系强制短路，不允许旁路接口绕过。  
3. 审计日志记录每次关系和隐私操作。  
4. 反爬策略保护用户社交图不被批量抓取。  
5. 提供“数据导出/删除”能力满足合规要求。  

## 14. 成本与取舍
1. 全图数据库查询强，但成本高，可用“KV + 离线图计算”混合。  
2. 实时共同好友精确计算贵，可做分层缓存。  
3. 强一致体验好但吞吐低，关注场景可接受最终一致。  
4. 热点用户单独分桶增加复杂度，但能显著降低热点风险。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 关注写入（幂等 + 隐私校验）
```java
public class FollowService {
    private final PrivacyService privacyService;
    private final RelationRepo relationRepo;

    public void follow(long actorId, long targetId, String idemKey) {
        if (!privacyService.canFollow(actorId, targetId)) {
            throw new BizException("403_BLOCKED");
        }
        if (relationRepo.idempotentSeen(idemKey)) return;
        relationRepo.insertEdge(actorId, targetId, "FOLLOW");
        relationRepo.markIdempotent(idemKey);
    }
}
```

### 15.2 好友关系双边状态机
```java
public enum FriendState { NONE, REQUESTED, ACCEPTED, DELETED }

public class FriendStateMachine {
    public FriendState transit(FriendState current, String action) {
        return switch (current) {
            case NONE -> "REQUEST".equals(action) ? FriendState.REQUESTED : current;
            case REQUESTED -> "ACCEPT".equals(action) ? FriendState.ACCEPTED : current;
            case ACCEPTED -> "REMOVE".equals(action) ? FriendState.DELETED : current;
            default -> current;
        };
    }
}
```

### 15.3 共同好友计算（交集优化）
```java
public class MutualFriendService {
    public List<Long> mutual(List<Long> a, List<Long> b, int limit) {
        Set<Long> small = a.size() < b.size() ? new HashSet<>(a) : new HashSet<>(b);
        List<Long> large = a.size() < b.size() ? b : a;
        List<Long> out = new ArrayList<>();
        for (Long id : large) {
            if (small.contains(id)) {
                out.add(id);
                if (out.size() >= limit) break;
            }
        }
        return out;
    }
}
```

### 15.4 热点用户分桶路由
```java
public class GraphShardRouter {
    public int shard(long srcUser, int shardCount, int virtualBucket) {
        long mixed = srcUser ^ (srcUser >>> 16);
        long bucketed = mixed * 31 + virtualBucket;
        return (int) (Math.abs(bucketed) % shardCount);
    }
}
```

### 15.5 关系事件 Outbox 投递
```java
public class RelationOutboxPublisher {
    private final OutboxRepo outboxRepo;
    private final EventBus eventBus;

    public void publishPending() {
        List<OutboxEvent> events = outboxRepo.fetchPending(500);
        for (OutboxEvent e : events) {
            try {
                eventBus.publish("relation.changed", e.payload());
                outboxRepo.markSent(e.id());
            } catch (Exception ex) {
                outboxRepo.increaseRetry(e.id());
            }
        }
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 共同好友查询页（React + TS）
```tsx
type MutualResp = { mutualUserIds: number[]; latencyMs: number };

export function MutualFriendPanel() {
  const [uid, setUid] = useState("1001");
  const [target, setTarget] = useState("2002");
  const [data, setData] = useState<MutualResp | null>(null);

  async function query() {
    const res = await fetch(`/api/relationships/${uid}/mutual?with=${target}`);
    setData(await res.json());
  }

  return (
    <div>
      <input value={uid} onChange={e => setUid(e.target.value)} />
      <input value={target} onChange={e => setTarget(e.target.value)} />
      <button onClick={query}>查共同好友</button>
      {data && <p>共同好友: {data.mutualUserIds.join(", ")} / 延迟: {data.latencyMs}ms</p>}
    </div>
  );
}
```

### 16.2 隐私与拉黑管理页（React + TS）
```tsx
export function PrivacyRulePanel() {
  const [targetId, setTargetId] = useState("");
  const [reason, setReason] = useState("骚扰");

  async function block() {
    await fetch("/api/privacy/block", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ targetId: Number(targetId), reason })
    });
    alert("已拉黑");
  }

  return (
    <div>
      <input value={targetId} onChange={e => setTargetId(e.target.value)} placeholder="目标用户ID" />
      <input value={reason} onChange={e => setReason(e.target.value)} />
      <button onClick={block}>执行拉黑</button>
    </div>
  );
}
```

## 17. 测试策略
1. 单测：状态机流转、共同好友交集算法、隐私规则优先级。  
2. 集成：关注写入 + 事件投递 + 缓存失效全链路。  
3. 压测：热点大 V 关注风暴下分片负载是否均衡。  
4. 故障演练：分片宕机、缓存雪崩、策略误配。  
5. 对账：主存和缓存关系快照一致性巡检。  

## 18. 丰富例子（面试可复述）
1. 明星涨粉 100 万，如何抗热点写入。  
2. 两人关系显示不同步，怎么定位缓存还是主存问题。  
3. 共同好友查询超时，如何降级。  
4. 拉黑后仍能看动态，如何排查权限链路。  
5. 新用户冷启动推荐怎么做。  
6. 关注后立即查询没看到，如何解释一致性策略。  
7. 黑产批量探测关系图，如何防刷。  
8. 关系边暴涨后如何做数据分层。  
9. 用户注销后关系边怎么清理。  
10. 推荐命中率下降，如何定位召回阶段问题。  
11. 误拉黑恢复后如何回滚策略。  
12. 跨机房同步延迟导致推荐异常如何补偿。  

## 19. 面试追问+回答模板
1. 问：为什么不用纯图数据库？  
答：可用，但成本高且在线热点场景要额外优化。工程里常用 KV 在线读写 + 图计算离线分析的混合架构。  
2. 问：关注关系为何可最终一致？  
答：这是弱事务业务，短暂延迟可接受，换来更高吞吐和更低写放大。  
3. 问：隐私如何保证不被绕过？  
答：隐私策略放在统一策略服务并强制前置校验，任何关系查询都先过策略。  

## 20. 新手学习路线
1. 先学邻接表和关系边建模。  
2. 再学共同好友和二跳关系查询。  
3. 学缓存、分片和热点治理。  
4. 学隐私策略和拉黑优先级。  
5. 最后练“故障演练 + 面试复述”。  

## 21. 上场前Checklist
1. 能讲清关注与好友在数据模型上的区别。  
2. 能讲清共同好友优化思路。  
3. 能说明隐私策略的执行优先级。  
4. 能给出热点用户治理方案。  
5. 能讲出与母题在系统边界上的差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q2 Twitter Timeline - 推特时间线与搜索`。  

### 22.2 共性能力
1. 都是社交域核心系统。  
2. 都依赖关注关系数据。  
3. 都要处理大 V 热点问题。  
4. 都有隐私和风控要求。  

### 22.3 关键差异
1. Q5 关注“关系图数据结构”，Q2 关注“信息流分发与排序”。  
2. Q5 核心查询是共同好友/关系判断，Q2 核心查询是时间线读取。  
3. Q5 重点在边存储和图查询，Q2 重点在 fan-out 和 feed 缓存。  
4. Q5 更偏图模型与隐私关系策略，Q2 更偏内容分发策略。  
5. Q5 不必展开全文搜索，Q2 常会涉及搜索融合。  

### 22.4 本题新增必补知识
1. 图关系分片策略。  
2. 共同好友与二跳查询优化。  
3. 好友双边状态机。  
4. 隐私规则与拉黑短路。  
5. 社交图的审计与合规删除。  

### 22.5 面试差异话术
1. “Q2 是内容流系统，Q5 是关系图系统，数据主语不同。”  
2. “Q5 先解决关系正确性和查询效率，再谈上层分发。”  
3. “如果面试只问关系建模和共同好友，那就是 Q5 语境，不是 Q2。”  
