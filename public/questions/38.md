# Q38 Distributed Cache (分布式缓存)

> 来源校验（questions.ts）  
> `title`: Distributed Cache (分布式缓存)  
> `tags`: 缓存一致性, 缓存穿透, 热点缓存, 淘汰策略, 集群  
> `keyPoints`: 分片与副本, 一致性策略, 缓存击穿防护, 淘汰策略, 多级缓存架构  
> `learningCoreId`: 34（母题：Design Redis）

## 1. 三句话题目本质
1. 这题不是让你设计 Redis 内核，而是设计“业务如何正确使用分布式缓存集群”。
2. 真正难点是命中率、一致性、热点与故障降级之间的平衡，而不是 `get/set` 本身。
3. 面试高分点是讲清：缓存层级、回源保护、失效机制、可观测阈值、故障恢复路径。

## 2. 一个真实场景故事
某电商商品详情接口在大促达到 12 万 QPS，数据库连接池持续打满。团队接入分布式缓存后，平均延迟下降明显，但两周后出现三类事故：热点 SKU 击穿、批量过期雪崩、缓存与 DB 短时不一致导致“已下架商品还可见”。最终通过 L1+L2 多级缓存、single-flight、防穿透、延迟双删与告警阈值治理，稳定在 P95 28ms -> 9ms，DB 读 QPS 降低 78%。

## 3. 术语白话表（>=10）
1. L1 本地缓存：进程内缓存，极低延迟，但容量小、跨实例不一致。
2. L2 分布式缓存：如 Redis Cluster，容量大，跨实例共享。
3. Cache Aside：读时查缓存，miss 回源 DB 再回填。
4. Single-Flight：同一 key 只允许一个请求回源，其他请求等待结果。
5. 缓存穿透：请求不存在数据，持续打到 DB。
6. 缓存击穿：热点 key 过期瞬间大量请求回源。
7. 缓存雪崩：大量 key 同时过期，导致回源洪峰。
8. TTL 抖动：在过期时间上加随机偏移，避免同刻失效。
9. 延迟双删：更新 DB 后删缓存，再延迟一次删缓存。
10. 回源限流：限制缓存 miss 后访问 DB 的速率。
11. 逻辑过期：值里带过期时间，过期后异步刷新。
12. 负缓存：把“不存在”结果短暂缓存，防止穿透。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持 `get/set/delete/batchGet`。
2. 支持业务对象缓存（商品、店铺、库存只读视图）。
3. 支持 TTL、主动失效、批量失效。
4. 支持热点 key 保护与回源合并。
5. 支持多机房读取（同城优先）。

### 4.2 非功能需求
1. 低延迟：缓存命中读 P95 <= 10ms。
2. 高可用：缓存层可用性 >= 99.95%。
3. 可扩展：水平扩容不中断业务。
4. 可治理：关键指标可告警并可自动降级。

### 4.3 不做范围
1. 不做缓存引擎底层实现（内存分配、持久化文件格式）。
2. 不做跨地域强一致事务。
3. 不做复杂全文检索能力。

### 4.4 SLO
1. 总命中率 >= 92%（10 分钟窗口）。
2. 缓存 miss 回源成功率 >= 99.9%。
3. 回源 DB QPS 不超过基线 1.5 倍（持续 5 分钟触发降级）。

## 5. 容量估算（数字推导）
假设商品详情场景：
1. 日活用户 800 万，峰值并发请求 12 万 QPS。
2. 热数据 key 数 3000 万，平均 value 1 KB，key 约 60 B。
3. 原始体积约 `3000万 * (1084B) ≈ 30.3 GB`。
4. 按对象元数据、哈希桶、碎片与副本系数 2.4 估算：`30.3 * 2.4 ≈ 72.7 GB`。
5. 预留 30% 安全水位：`94.5 GB`，按 6 主分片，单主约 16 GB。
6. 峰值 miss 率按 8%：回源潜在 `120000 * 8% = 9600 QPS`，必须配回源限流（如 3000 QPS 上限）+ 负缓存。

## 6. 架构（简版+完整版）
### 6.1 简版
`Client -> Cache SDK -> Redis Cluster -> DB`

### 6.2 完整版
1. Client 侧：L1 本地缓存（Caffeine）+ L2 分布式缓存访问。
2. SDK：统一封装 key 规范、TTL 策略、single-flight、熔断与重试。
3. L2：Redis Cluster（分片+副本）承载主缓存数据。
4. Invalidation Bus：更新事件广播（Kafka），触发多实例本地缓存失效。
5. Fallback Gate：回源限流器、隔离舱、降级开关。
6. DB：主库 + 只读副本，承接受控回源流量。
7. Observability：命中率、延迟、热点倾斜、回源洪峰与节点状态告警。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 读接口
`GET /api/cache/v1/items/{bizKey}`

响应：
```json
{
  "found": true,
  "source": "L2",
  "value": {"itemId": 1024, "title": "耳机"},
  "expireAt": "2026-02-24T20:31:00Z"
}
```

### 7.2 写接口
`PUT /api/cache/v1/items/{bizKey}`

请求：
```json
{
  "value": {"itemId": 1024, "title": "耳机"},
  "ttlSec": 180,
  "idempotencyKey": "cache-write-1024-v17"
}
```

错误码：
1. `400_INVALID_TTL`
2. `409_IDEMPOTENCY_CONFLICT`
3. `429_FALLBACK_THROTTLED`
4. `503_CACHE_DEGRADED`

幂等规则：
1. 同 `bizKey + idempotencyKey` 在 10 分钟内只接受一次写入。
2. 重复写返回同一结果，不重复修改版本号。

### 7.3 失效接口
`POST /api/cache/v1/invalidate`

请求：
```json
{
  "keys": ["item:1024", "item:2048"],
  "reason": "ITEM_UPDATED",
  "requestId": "inv-20260224-001"
}
```

## 8. 数据模型（实体/索引/分片）
1. `cache_entry`：`key, value, version, expire_at, logical_expire_at, updated_at`。
2. `idempotency_log`：`idem_key, biz_key, result_hash, created_at, expire_at`。
3. `hot_key_stat`：`key, qps_1m, owner_node, skew_ratio, updated_at`。
4. `invalidate_event`：`event_id, key, reason, producer, created_at`。

索引与分片：
1. L2 按 `CRC16(key) % 16384` 路由到 slot。
2. 业务 key 规范：`item:{itemId}`，高基数字段做分片键。
3. 热点拆分键：`stock:{skuId}:{bucket}`（只读聚合时合并）。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 先查 L1，命中直接返回。
2. L1 miss 查 L2，命中则回填 L1。
3. L2 miss 进入 single-flight，只有一个请求回源 DB。
4. 回源成功写 L2+L1（TTL 带抖动），失败按降级策略返回。

### 9.2 高峰流程
1. 热点 key 触发 single-flight + 逻辑过期异步刷新。
2. 回源流量经过漏桶限流，超出阈值走“旧值可用”降级。
3. 对不存在对象写入负缓存（TTL 30~60s）防穿透。

### 9.3 故障恢复流程
1. 监控检测某分片不可达，SDK 熔断该分片短时间请求。
2. 读请求走 L1 + 受控回源，防止打爆 DB。
3. 分片恢复后逐步半开，按错误率恢复流量。
4. 触发缓存预热任务恢复热点 key 命中率。

## 10. 一致性与事务边界
1. 一致性模型：最终一致（缓存不作为真相源）。
2. 写链路：DB 事务提交成功后发布失效事件并删缓存。
3. 关键对象采用“延迟双删 + 版本号 CAS”防止旧值回填覆盖新值。
4. 事务边界在 DB；缓存失败不回滚 DB，走补偿重试。
5. 对强一致读场景（少量）：绕过缓存直读主库或使用短期读屏障。

## 11. 可用性与容错（含 RTO/RPO）
1. L2 集群多副本 + 自动故障转移。
2. SDK 层熔断、超时、限流、降级，避免级联故障。
3. 回源隔离池，防止慢查询拖垮主业务线程池。
4. RTO：分片故障后 5 分钟内命中率恢复到 85% 以上。
5. RPO：缓存层可接受丢失（可重建），关键状态不只存缓存。

## 12. 可观测性（指标+阈值+处置动作）
1. `cache_hit_ratio_10m`，阈值 `< 92%` 持续 10 分钟，动作：开启预热 + 检查失效风暴。
2. `cache_read_p95_ms`，阈值 `> 10ms` 持续 5 分钟，动作：定位热点节点并迁移槽位。
3. `fallback_db_qps`，阈值 `> 3000` 持续 2 分钟，动作：收紧回源限流并启用旧值兜底。
4. `singleflight_wait_p95_ms`，阈值 `> 80ms`，动作：扩容回源池或优化 DB 查询。
5. `hotkey_skew_ratio`，阈值 `> 35%`，动作：热点 key 拆分或只读副本扩散。
6. `invalidate_lag_ms`，阈值 `> 2000ms`，动作：排查事件总线积压并手动补发。

## 13. 安全与合规
1. 缓存接口需服务间鉴权（mTLS + token）。
2. PII 字段默认不缓存，必要时脱敏后缓存。
3. 失效接口需审计：操作者、请求 ID、影响 key 数。
4. 防缓存投毒：写入时校验 value schema 与大小上限。
5. 合规要求删除数据时，必须同步触发缓存清理与审计记录。

## 14. 成本与取舍
1. 增加副本能提高可用性，但内存与网络成本线性增加。
2. 长 TTL 提升命中率但提高陈旧风险；短 TTL 相反。
3. L1 提升延迟表现，但会增加实例间不一致窗口。
4. 逻辑过期可提升稳定性，但实现复杂度高于硬 TTL。
5. 取舍结论：高流量读场景优先“稳定优先”，允许短暂旧值。

## 15. Java 关键代码（>=5段）
### 15.1 核心读路径 + 状态转移
```java
public CacheResult<ItemDTO> getItem(String key) {
    ItemDTO l1v = l1Cache.getIfPresent(key);
    if (l1v != null) return CacheResult.hit("L1", l1v);

    VersionedValue<ItemDTO> l2v = l2Client.get(key, ItemDTO.class);
    if (l2v != null && !l2v.isHardExpired()) {
        l1Cache.put(key, l2v.value());
        return CacheResult.hit("L2", l2v.value());
    }

    return loadWithSingleFlight(key, () -> dbRepo.findItem(key));
}
```

### 15.2 幂等写入/去重
```java
public WriteResult putWithIdempotency(String bizKey, ItemDTO value, String idemKey, int ttlSec) {
    String idemRecordKey = "idem:" + bizKey + ":" + idemKey;
    String existing = l2Client.getRaw(idemRecordKey);
    if (existing != null) {
        return WriteResult.duplicate(existing);
    }

    long ver = versionGen.next(bizKey);
    l2Client.putVersioned(bizKey, value, ver, ttlSec);
    l2Client.setNx(idemRecordKey, "v=" + ver, 600);
    return WriteResult.success(ver);
}
```

### 15.3 重试退避/失败处理
```java
public <T> T callWithBackoff(Supplier<T> call, int maxRetry) {
    long backoffMs = 20;
    RuntimeException last = null;
    for (int i = 0; i <= maxRetry; i++) {
        try {
            return call.get();
        } catch (RuntimeException ex) {
            last = ex;
            if (i == maxRetry) break;
            sleep(backoffMs);
            backoffMs = Math.min(backoffMs * 2, 200);
        }
    }
    throw new CacheUnavailableException("cache_call_failed", last);
}
```

### 15.4 一致性边界（DB事务 + 延迟双删补偿）
```java
@Transactional
public void updateItemAndInvalidate(String itemKey, ItemEntity entity) {
    dbRepo.update(entity);                 // 事务内真实写
    l2Client.delete(itemKey);              // 第一次删
    scheduler.schedule(() -> l2Client.delete(itemKey), 200, TimeUnit.MILLISECONDS); // 延迟二删
}
```

### 15.5 观测触发 + 回滚判定
```java
public void fallbackGuard(String key) {
    long qps = metrics.counter("fallback_db_qps").incrementAndGet();
    if (qps > 3000) {
        degradeSwitch.enable("serve_stale_value");
        alerting.fire("FALLBACK_QPS_HIGH", "key=" + key + ",qps=" + qps);
    }
    if (metrics.gauge("cache_hit_ratio_10m").value() < 0.85) {
        prewarmJob.triggerTopKeys();
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 缓存读接口：loading/error/done + 超时降级
```javascript
import { useEffect, useState } from "react";

export function useCachedItem(itemId) {
  const [state, setState] = useState({ phase: "idle", data: null, error: "" });

  useEffect(() => {
    let canceled = false;
    const controller = new AbortController();
    setState({ phase: "loading", data: null, error: "" });

    fetch(`/api/cache/v1/items/item:${itemId}`, { signal: controller.signal })
      .then(async (res) => {
        if (!res.ok) throw new Error(`HTTP_${res.status}`);
        return res.json();
      })
      .then((json) => {
        if (!canceled) setState({ phase: "done", data: json.value, error: "" });
      })
      .catch((e) => {
        if (!canceled) setState({ phase: "error", data: null, error: String(e.message || e) });
      });

    return () => {
      canceled = true;
      controller.abort();
    };
  }, [itemId]);

  return state;
}
```

### 16.2 失效请求：幂等键 + 失败重试退避
```javascript
export async function invalidateKeys(keys) {
  const idem = `inv-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 100;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch("/api/cache/v1/invalidate", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Idempotency-Key": idem },
        body: JSON.stringify({ keys, reason: "MANUAL_REFRESH", requestId: idem })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 800);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：single-flight、TTL 抖动、幂等写入命中与重复行为。
2. 集成测试：DB 更新 + 双删后读一致性窗口验证。
3. 压测：热点 key 场景（单 key 5 万 QPS）下回源是否受控。
4. 故障测试：分片下线、事件总线延迟、DB 慢查询注入。
5. 回归测试：命中率、回源 QPS、延迟和错误码分布。

## 18. 丰富例子（>=10）
1. 商品标题改名后 200ms 内多实例缓存失效完成。
2. 热门直播间 key 过热，single-flight 将回源并发从 2000 降到 1。
3. 恶意请求随机 itemId，负缓存将 DB 读降低 60%。
4. 批量活动结束导致 10 万 key 失效，TTL 抖动避免雪崩。
5. 某分片切主期间，SDK 熔断 + L1 兜底，错误率控制在 0.3%。
6. 回源池被慢 SQL 占满时，fallback 限流阻止 DB 被拖垮。
7. 热点 SKU 拆桶后，单节点 CPU 从 90% 降到 55%。
8. Invalidation Bus 延迟 3 秒时触发告警并补发事件。
9. 发布误删 key 前缀，利用审计日志快速定位责任请求。
10. 大促预热 Top10 万商品，开场 15 分钟命中率维持 96%。
11. L1 命中过高但跨实例不一致，切换为更短 L1 TTL 解决。
12. 错误幂等键重放请求，被 `idempotency_log` 成功拦截。

## 19. 面试追问 + 可复述回答
1. 为什么不是只用 Redis？
回答：只用 L2 在高峰时回源震荡更明显；L1+L2 可显著降低尾延迟并抗瞬时抖动。
2. 如何保证更新后一致性？
回答：DB 事务成功后删缓存 + 延迟双删 + 回填时版本号校验，保证最终一致并降低旧值覆盖概率。
3. 如何避免缓存击穿？
回答：single-flight、逻辑过期异步刷新、热点预热和回源限流组合使用。
4. 回源限流阈值怎么定？
回答：按 DB 可承受读 QPS 反推，预留 30% 安全余量，再用压测验证。
5. 分布式缓存题和 Redis 题区别？
回答：前者讲“如何把缓存用对并跑稳”，后者讲“缓存引擎本身如何实现”。

## 20. 新手学习路线
1. 先掌握 Cache Aside、穿透/击穿/雪崩三件套。
2. 再掌握 L1+L2、多级 TTL 与失效广播。
3. 学会 single-flight、回源限流和降级策略。
4. 练习一致性边界：双删、版本号、补偿任务。
5. 最后做压测 + 故障演练，能用指标讲清取舍。

## 21. 上场前 Checklist
1. 能在 2 分钟讲清完整读写链路。
2. 能说出至少 3 个故障场景和恢复动作。
3. 能量化命中率、延迟、回源 QPS 阈值。
4. 能解释一致性边界和事务边界。
5. 能写出 single-flight 与双删的核心代码。
6. 能明确与母题 Q34 的边界差异。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q34 Design Redis。

### 22.2 共性能力
1. 都需要理解缓存命中率、淘汰策略、分片与副本。
2. 都会涉及高可用、故障切换、性能与成本权衡。

### 22.3 关键差异
1. Q34 关注缓存引擎内部实现（数据结构、持久化、复制协议）。
2. Q38 关注业务接入架构（多级缓存、回源治理、失效协同）。
3. Q34 更偏“系统内核”；Q38 更偏“平台落地”。

### 22.4 本题新增知识点（>=5）
1. L1+L2 多级缓存协同策略。
2. single-flight 防击穿工程化实现。
3. 回源限流与隔离池设计。
4. 失效事件总线与跨实例一致性。
5. 逻辑过期 + 异步刷新稳定性策略。
6. 幂等写与缓存操作审计。

### 22.5 面试差异话术
“如果你问我 Q34，我会从 Redis 内核能力讲起；如果是 Q38，我会从业务读写链路、回源保护、失效传播和故障恢复讲起。两者都重要，但关注层次不同。”

---

## 单题自审（Q38）
### A. 完整性检查
1. 22 节全部覆盖：通过。
2. Java 代码段数量：5（满足 >=5）：通过。
3. React JS API 协作代码段：2（满足 >=2）：通过。

### B. 易懂性检查
1. 术语均有白话定义：通过。
2. 关键流程按正常/高峰/故障分开：通过。

### C. 专属性检查
1. 内容聚焦“分布式缓存落地”，非 Redis 内核复读：通过。
2. 包含 Q38 独有的回源治理和多级缓存：通过。

### D. 工程落地检查
1. 提供阈值与处置动作绑定：通过。
2. 提供 RTO/RPO、幂等、降级路径：通过。

### E. 代码相关性检查
1. Java 覆盖状态转移/幂等/重试/一致性边界/观测触发：通过。
2. 前端覆盖 API 调用/成功失败分支/loading-error-done/重试与幂等键：通过。

### F. 母题差异检查
1. 已明确母题 Q34，且给出共性、差异、新增知识与话术：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过，>=95）
