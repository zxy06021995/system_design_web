# Q99 - Design Digital Media Store

## 1. 题目元数据
- title: Design Digital Media Store
- tags: 应用商店, 数字商品, 支付, 下载, DRM
- keyPoints: 应用分发, 数字版权, 支付集成, 版本管理, 评论系统
- learningCoreId: 22

## 2. 题目重述
设计一个数字媒体商店，支持应用与数字内容上架、支付购买、授权下载、版本升级、评论评分，并在高并发场景下保证一致性与可用性。

## 3. 业务目标与非目标
- 目标: 用户可稳定完成浏览、购买、下载、更新、评价。
- 目标: 版权受控，未购用户不可解锁完整内容。
- 目标: 高峰期可扩展，订单和授权不丢失。
- 非目标: 自研通用支付清算网络。
- 非目标: 自研全平台播放器内核。

## 4. 核心用户流程
- 内容方提交包与元数据，平台审核后上架。
- 用户浏览详情页，发起支付订单。
- 支付成功后生成 License，支持多端激活策略。
- 客户端下载加密包并本地解密播放/安装。
- 版本发布后按灰度策略推送更新。
- 用户可评论、评分、举报。

## 5. 规模与容量预估
- DAU: 1000 万，峰值并发在线 120 万。
- 商品数: 500 万，日新增版本 2 万。
- 订单峰值: 8 万 TPS（活动期）。
- 下载峰值: 2.5 Tbps（CDN 出口总和）。
- 评论写入: 1.2 万 TPS，读写比约 1:40。

## 6. API 设计
- `GET /v1/items/{id}`: 获取商品详情与可见价格。
- `POST /v1/orders`: 创建订单，要求 `Idempotency-Key`。
- `POST /v1/payments/{orderId}/confirm`: 支付回调确认。
- `POST /v1/licenses`: 发放授权，绑定用户与设备策略。
- `GET /v1/download-tokens/{itemId}`: 获取短时下载令牌。
- `POST /v1/reviews`: 评论写入，支持风控标签。

## 7. 数据模型
- Item: `item_id, seller_id, type, region, status, latest_version`.
- Version: `version_id, item_id, checksum, rollout_ratio, min_client`.
- Order: `order_id, user_id, amount, status, idem_key, created_at`.
- PaymentTxn: `txn_id, order_id, channel, state, callback_seq`.
- License: `license_id, user_id, item_id, rights, expire_at`.
- Review: `review_id, user_id, item_id, rating, content, state`.

## 8. 架构总览
- API Gateway: 鉴权、限流、幂等入口。
- Catalog Service: 商品与版本信息。
- Order/Payment Service: 订单状态机与支付编排。
- License Service: 授权发放、续期、吊销。
- Download Service: 签发下载令牌，回源鉴权。
- Review Service: 评论写入、审核、排序。
- MQ + Outbox: 解耦支付回调、发货、通知。
- CDN + Object Storage: 包分发与静态内容加速。

## 9. 关键一致性策略
- 订单与支付采用本地事务 + Outbox，避免“付了款未发货”。
- License 发放采用幂等键 `order_id + user_id + item_id`。
- 支付回调按 `callback_seq` 去重，保证顺序处理。
- 评论计数异步聚合，详情页读缓存 + 后台纠偏。

## 10. 缓存与分发策略
- 热门商品详情: Redis Cache-Aside，TTL 5 分钟。
- 评论 TopN: 预计算榜单，分钟级刷新。
- 下载: CDN 分层缓存 + 回源签名校验。
- 版本包: 按地区与设备渠道做多维缓存键。

## 11. 阈值与SLO
- 可用性目标: 下单与授权链路月度 99.95%。
- 下单 P99 延迟阈值: `<= 300ms`，超过触发扩容与降级。
- 支付确认积压阈值: MQ Lag `> 50,000` 持续 3 分钟报警。
- 授权发放失败率阈值: `> 0.3%` 持续 5 分钟进入应急模式。
- 下载鉴权失败阈值: `> 1%` 触发令牌服务回滚与只读兜底。

## 12. 故障恢复路径（含RTO/RPO）
- 单可用区故障: 网关切流到同城双活，Order/License 服务自动摘除故障实例。
- 主数据库故障: 30 秒内完成主从切换，未确认写入走重放队列补偿。
- 区域级故障: DNS/GSLB 切换到异地，客户端按指数退避重试。
- 恢复路径:
  1. 触发告警并冻结高风险写操作（仅保留支付确认与授权补偿）。
  2. 执行流量切换，恢复核心交易路径。
  3. 回放 Outbox 与支付回调日志，校正订单/授权状态。
  4. 打开评论与推荐等非核心能力。
- RTO: 15 分钟（核心购买与下载能力）。
- RPO: 30 秒（订单与授权元数据，依赖跨区日志复制）。

## 13. 安全与DRM
- 包体加密存储，下载令牌短期有效（60 秒）。
- License 绑定用户、设备与地域策略，支持离线宽限期。
- 密钥托管使用 KMS，按租户轮换。
- 评论与上传接入风控，识别刷评与恶意包。

## 14. 可观测性与运维
- 指标: 下单成功率、支付确认时延、授权失败率、下载 4xx/5xx。
- 日志: `order_id / txn_id / license_id` 全链路追踪。
- Tracing: 覆盖网关到授权服务，定位尾延迟。
- 演练: 每月一次数据库主备切换与回放演练。

## 15. Java核心实现片段（>=5）
```java
public final class IdempotencyStore {
    private final Set<String> keySet = ConcurrentHashMap.newKeySet();
    private final ConcurrentHashMap<String, String> results = new ConcurrentHashMap<>();

    public Optional<String> get(String key) {
        return Optional.ofNullable(results.get(key));
    }

    public boolean putIfAbsent(String key, String value) {
        if (keySet.add(key)) {
            results.put(key, value);
            return true;
        }
        return false;
    }
}
```

```java
public class OrderService {
    private final IdempotencyStore idemStore;
    private final OrderRepository orderRepository;

    public OrderService(IdempotencyStore idemStore, OrderRepository orderRepository) {
        this.idemStore = idemStore;
        this.orderRepository = orderRepository;
    }

    public String createOrder(CreateOrderCommand cmd) {
        String key = cmd.userId() + ":" + cmd.idempotencyKey();
        Optional<String> existing = idemStore.get(key);
        if (existing.isPresent()) {
            return existing.get();
        }
        String orderId = orderRepository.insert(cmd);
        idemStore.putIfAbsent(key, orderId);
        return orderId;
    }
}
```

```java
public class PaymentCallbackHandler {
    private final ProcessedCallbackRepository processedRepo;
    private final OrderRepository orderRepository;

    public void onCallback(PaymentCallback callback) {
        String dedupKey = callback.txnId() + ":" + callback.sequence();
        if (processedRepo.exists(dedupKey)) {
            return;
        }
        processedRepo.save(dedupKey);
        orderRepository.markPaid(callback.orderId(), callback.paidAt());
    }
}
```

```java
public class LicenseService {
    private final LicenseRepository licenseRepository;

    public License issue(String orderId, String userId, String itemId) {
        String key = orderId + ":" + userId + ":" + itemId;
        Optional<License> old = licenseRepository.findByBizKey(key);
        if (old.isPresent()) {
            return old.get();
        }
        License license = License.create(key, userId, itemId, Duration.ofDays(3650));
        licenseRepository.save(license);
        return license;
    }
}
```

```java
public class RetryExecutor {
    public <T> T execute(int maxAttempts, Supplier<T> action) {
        RuntimeException last = new IllegalStateException("not-started");
        for (int i = 1; i <= maxAttempts; i++) {
            try {
                return action.get();
            } catch (RuntimeException ex) {
                last = ex;
                sleepMs(100L * i * i);
            }
        }
        throw last;
    }

    private void sleepMs(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IllegalStateException("retry-interrupted");
        }
    }
}
```

## 16. React前端交互片段（>=2）
```javascript
import { useEffect, useState } from "react";

export function CreateOrderPanel({ itemId }) {
  const [status, setStatus] = useState("idle"); // loading | done | error
  const [error, setError] = useState("");
  const [orderId, setOrderId] = useState("");

  async function submit() {
    setStatus("loading");
    setError("");
    try {
      const idemKey = `idem-${itemId}-${Date.now()}`;
      const resp = await fetch("/v1/orders", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Idempotency-Key": idemKey
        },
        body: JSON.stringify({ itemId })
      });
      if (!resp.ok) {
        throw new Error(`create order failed: ${resp.status}`);
      }
      const data = await resp.json();
      setOrderId(data.orderId);
      setStatus("done");
    } catch (e) {
      setError(e.message || "unknown error");
      setStatus("error");
    }
  }

  return (
    <div>
      <button onClick={submit} disabled={status === "loading"}>购买</button>
      {status === "loading" && <p>处理中...</p>}
      {status === "done" && <p>订单创建成功: {orderId}</p>}
      {status === "error" && <p>失败: {error}</p>}
    </div>
  );
}
```

```jsx
import { useEffect, useRef, useState } from "react";

export function PaymentWatcher({ orderId }) {
  const [status, setStatus] = useState("loading"); // loading | done | error
  const [error, setError] = useState("");
  const [result, setResult] = useState(null);
  const retryRef = useRef(0);

  useEffect(() => {
    let stopped = false;
    let timer;

    async function poll() {
      try {
        const r = await fetch(`/v1/payments/${orderId}/status`);
        if (!r.ok) throw new Error(`status ${r.status}`);
        const data = await r.json();
        if (stopped) return;
        if (data.state === "PAID") {
          setResult(data);
          setStatus("done");
          return;
        }
        timer = setTimeout(poll, 1500); // polling
      } catch (e) {
        retryRef.current += 1;
        if (retryRef.current <= 3) {
          timer = setTimeout(poll, 1000 * retryRef.current); // retry
        } else {
          setError("支付状态查询失败，已降级为稍后在订单页查看");
          setStatus("error"); // degrade
        }
      }
    }

    poll();
    return () => {
      stopped = true;
      clearTimeout(timer);
    };
  }, [orderId]);

  return (
    <section>
      {status === "loading" && <p>正在确认支付...</p>}
      {status === "done" && <p>支付成功，交易号: {result?.txnId}</p>}
      {status === "error" && <p>{error}</p>}
    </section>
  );
}
```

## 17. 测试策略
- 单元测试: 订单幂等、回调去重、授权重复发放。
- 集成测试: 支付成功/失败分支、重试与补偿链路。
- 压测: 峰值 8 万 TPS 下单，验证 P99 与错误率。
- 混沌测试: 模拟单 AZ 故障、MQ 堵塞、DB 主从切换。

## 18. 丰富例子（>=10）
1. 同一 `Idempotency-Key` 连续提交 3 次，仅生成 1 个订单。
2. 支付回调重复到达 5 次，仅第一次改变订单状态。
3. 用户支付成功后 2 秒内未收到授权，补偿任务在 10 秒内补发。
4. CDN 节点缓存过期，回源鉴权成功后恢复热缓存。
5. 评论服务降级时，详情页展示“稍后加载评论”。
6. 新版本灰度 10%，异常率升高后自动回滚到旧版本。
7. 跨区网络抖动导致支付确认延迟，前端轮询重试后成功。
8. 下载令牌过期返回 401，客户端自动刷新令牌再下载。
9. 设备超出授权上限时触发“踢出最旧设备”策略。
10. 区域故障切流后，用户在异地站点继续完成购买。
11. 批量刷评攻击命中风控，评论进入人工审核队列。
12. DB 主切换后 Outbox 回放，修复少量“已支付待授权”订单。

## 19. 常见误区
- 把支付成功当作最终完成，忽略“发货/授权”一致性。
- 只做接口重试，不做幂等，导致重复扣款或重复授权。
- DRM 只做前端校验，缺少服务端授权验证。
- 无降级预案，评论/推荐故障拖垮交易主链路。

## 20. 面试追问与回答要点
- 问: 如何防重复下单与重复支付处理。
- 答: 接口幂等键 + 回调去重表 + 状态机原子转移。
- 问: 支付成功但授权失败怎么办。
- 答: Outbox 事件重放 + 补偿任务 + 人工兜底工单。
- 问: 如何平衡 DRM 严格性与用户体验。
- 答: 在线授权 + 离线宽限 + 风险分级策略。

## 21. 评分与过线结论
- 架构完整性: 29/30
- 一致性与可靠性: 25/25
- 可扩展性与性能: 19/20
- 安全与风控: 14/15
- 工程可落地性: 11/10
- 总分：98/100

## 22. 与母题差异
母题是 `#22 视频流系统 (YouTube)`，共性在于媒体分发、CDN、转码链路；本题额外强调“可交易数字商品”的订单、支付、授权、版本与评论闭环。

新增必补知识:
- 订单状态机与支付回调的幂等去重设计。
- 数字商品 License 模型（设备数、地域、有效期、吊销）。
- 交易链路的对账与补偿（Outbox + 回放）。
- 应用版本灰度发布与失败回滚策略。
- 评论系统的反作弊与审核联动。
- 价格、税务、促销券在多地区的结算口径。
