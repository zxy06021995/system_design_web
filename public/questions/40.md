# Q40 Distributed Transaction (分布式事务)

> 来源校验（questions.ts）  
> `title`: Distributed Transaction (分布式事务)  
> `tags`: 2PC, TCC, Saga, 补偿事务, 一致性  
> `keyPoints`: 事务边界划分, 一致性级别, 补偿机制, 幂等与去重, 失败恢复  
> `learningCoreId`: 13（母题：Design Distributed Counter）

## 1. 三句话题目本质
1. 分布式事务题的本质是：跨多个服务时，如何保证业务状态最终收敛到正确结果。
2. 难点来自网络不可靠、重复投递、部分成功和补偿失败。
3. 面试高分要讲清：一致性级别选择、状态机设计、幂等补偿、可观测与人工兜底。

## 2. 一个真实场景故事
电商下单链路包含订单服务、库存服务、优惠券服务和支付预授权。某次网络抖动导致“库存扣减成功，但订单创建失败”，出现库存幽灵占用。团队从“同步串行调用”改为 Saga 编排：每步可重试、失败可补偿、全链路可审计，事故从人工排查 2 小时降到自动收敛 3 分钟内。

## 3. 术语白话表（>=10）
1. Local Transaction：单服务本地数据库事务。
2. 2PC：两阶段提交，协调器统一提交/回滚。
3. XA：数据库层分布式事务协议。
4. TCC：Try-Confirm-Cancel 三段式业务事务。
5. Saga：长事务拆步执行，失败按反向补偿。
6. Orchestrator：中心编排器，控制步骤顺序。
7. Choreography：服务间事件协作，无中心编排。
8. Idempotency Key：幂等键，防重复执行副作用。
9. Outbox：本地事务内写事件，再异步可靠投递。
10. DLQ：死信队列，隔离失败消息。
11. Empty Rollback：Cancel 先于 Try 到达的空回滚问题。
12. Hanging：Try 超时后晚到，导致悬挂执行问题。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持跨服务事务编排（订单、库存、支付等）。
2. 支持失败重试、反向补偿和人工介入。
3. 支持事务状态查询、审计与回放。
4. 支持幂等执行和去重。
5. 支持异常事务自动扫描与收敛。

### 4.2 非功能需求
1. 正确性优先于极致延迟。
2. 可观测、可追踪、可人工修复。
3. 高可用（协调器故障不丢状态）。
4. 可扩展（高并发事务发起）。

### 4.3 不做范围
1. 不实现数据库内核 XA 协议细节。
2. 不追求全链路强一致线性化。
3. 不实现通用 BPM 工作流所有高级能力。

### 4.4 SLO
1. 事务发起成功率 >= 99.9%。
2. 异常事务自动收敛 P95 <= 5 分钟。
3. 事务状态查询可用性 >= 99.95%。

## 5. 容量估算（数字推导）
1. 峰值事务请求 2 万 TPS。
2. 每个事务平均 4 个步骤（订单/库存/券/支付）。
3. 每步平均 2 次状态写（执行+确认/补偿），状态写 QPS 约 `20000*4*2=160000`。
4. 补偿率常态 0.8%，大促异常峰值 3%。
5. 事件总线吞吐需覆盖状态事件与重试事件，预留 25 万 msg/s。
6. 结论：状态库与消息系统都必须按峰值设计，且补偿流量要单独隔离资源池。

## 6. 架构（简版+完整版）
### 6.1 简版
`API -> Tx Orchestrator -> Participant Services -> Tx State Store`

### 6.2 完整版
1. Tx Gateway：接受事务发起和查询请求。
2. Orchestrator：执行 Saga/TCC 编排与状态机推进。
3. Tx State Store：保存 master/step 状态。
4. Outbox Relay：可靠事件投递。
5. Retry Worker：指数退避重试。
6. Compensation Worker：反向补偿执行。
7. DLQ Processor：处理不可自动修复任务。
8. Ops Console：人工重试/跳过/补单。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 发起事务
`POST /api/tx/v1/start`

请求：
```json
{
  "bizType": "PLACE_ORDER",
  "bizId": "order-1001",
  "requestId": "tx-start-20260224-001",
  "payload": {"userId": 11, "skuId": 9, "amount": 199}
}
```

响应：
```json
{
  "txId": "tx_7ab2...",
  "state": "RUNNING"
}
```

### 7.2 查询事务
`GET /api/tx/v1/{txId}`

### 7.3 人工重试步骤
`POST /api/tx/v1/{txId}/steps/{stepName}/retry`

错误码：
1. `409_TX_STATE_CONFLICT`
2. `409_STEP_ALREADY_DONE`
3. `422_IDEMPOTENCY_CONFLICT`
4. `503_TX_ENGINE_BUSY`

幂等规则：
1. `bizId + requestId` 唯一，重复发起返回同 `txId`。
2. 每个 step 有独立 `stepRequestId`，重复执行不可产生副作用。

## 8. 数据模型（实体/索引/分片）
1. `tx_master(tx_id, biz_id, biz_type, state, created_at, updated_at)`。
2. `tx_step(tx_id, step_name, state, attempt, last_error, updated_at)`。
3. `tx_idem(biz_id, request_id, tx_id, expire_at)`。
4. `tx_outbox(event_id, tx_id, event_type, status, retry_count)`。
5. `tx_audit(actor, action, tx_id, detail, ts)`。

索引与分区：
1. `biz_id + request_id` 唯一索引（防重）。
2. 按 `tx_id hash` 分区提高并行写。
3. `state + updated_at` 索引用于扫描卡单。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 发起事务写 `tx_master=RUNNING`。
2. 按顺序执行 steps，每步成功更新 step 状态。
3. 全部成功后 `tx_master=SUCCESS`。

### 9.2 高峰流程
1. Retry/Compensate 队列与主执行队列分离。
2. 非核心业务事务降级（排队或拒绝），核心链路优先。
3. 对慢步骤设置并发上限，防止放大雪崩。

### 9.3 故障恢复流程
1. 某步失败进入重试队列，超过阈值触发补偿链路。
2. 补偿按逆序执行，失败项进入 DLQ。
3. 定时扫描卡单，自动重试或标记人工处理。

## 10. 一致性与事务边界
1. 一致性目标：最终一致，不追求跨服务强一致。
2. 边界：每个服务内保证本地事务，服务间靠消息与状态机收敛。
3. Outbox 保证“本地状态变更”和“事件发送”原子性。
4. 补偿也是业务操作，必须幂等并可重入。
5. 对资金类关键环节，增加对账作业作为最后防线。

## 11. 可用性与容错（含 RTO/RPO）
1. Orchestrator 多副本，无状态部署。
2. 状态库存储强依赖持久化，不以内存为准。
3. 重试采用指数退避+抖动，避免重试风暴。
4. RTO：协调器故障 15 分钟内恢复自动推进能力。
5. RPO：事务状态不可丢；若事件发送失败可由 Outbox 补发恢复。

## 12. 可观测性（指标+阈值+处置动作）
1. `tx_success_rate` < 99%（10 分钟）：触发 P1，排查失败步骤 TopN。
2. `tx_compensation_rate` > 2%（10 分钟）：启动降级并冻结高风险变更。
3. `tx_stuck_count` > 200（5 分钟）：启动卡单扫描器加速与人工值班。
4. `step_retry_p95` > 3：检查下游依赖健康和限流参数。
5. `dlq_backlog` > 10000：启动专项清理并按业务优先级回放。
6. `tx_state_write_p95_ms` > 30ms：扩容状态库分区或优化索引。

## 13. 安全与合规
1. 事务操作 API 必须鉴权并记录操作者身份。
2. 幂等键防止重放攻击，设置有效期与签名校验。
3. 人工补偿/跳过操作需审批并强审计。
4. 敏感字段（金额、账户）日志脱敏。
5. 关键事件写不可篡改审计存储。

## 14. 成本与取舍
1. 2PC 一致性强但阻塞重、可用性差，不适合高延迟跨服务。
2. TCC 一致性较好但业务侵入重、开发成本高。
3. Saga 开发成本较低、可扩展好，但补偿复杂度高。
4. 实际常见取舍：核心链路 TCC，普通链路 Saga。

## 15. Java 关键代码（>=5段）
### 15.1 状态机推进（核心算法/状态转移）
```java
public void transitStep(String txId, String step, StepState from, StepState to) {
    if (!stateMachine.canTransit(from, to)) {
        throw new IllegalStateException("invalid transition " + from + " -> " + to);
    }
    txRepo.updateStepState(txId, step, to.name());
}
```

### 15.2 幂等去重（发起事务）
```java
public String startTx(StartRequest req) {
    String key = req.bizId() + ":" + req.requestId();
    String existed = idemRepo.findTxId(key);
    if (existed != null) return existed;
    String txId = txIdGen.newId();
    txRepo.insertMaster(txId, req.bizId(), "RUNNING");
    idemRepo.save(key, txId, Duration.ofHours(24));
    return txId;
}
```

### 15.3 重试退避/失败处理
```java
public void scheduleRetry(String txId, String step, int attempt) {
    if (attempt >= 5) {
        dlqRepo.save(txId, step, "max_retry_exceeded");
        return;
    }
    long delayMs = Math.min(5000, (1L << attempt) * 100L);
    long jitter = ThreadLocalRandom.current().nextLong(0, 80);
    retryQueue.enqueue(txId, step, delayMs + jitter);
}
```

### 15.4 一致性边界（Outbox + 本地事务）
```java
@Transactional
public void markStepDoneAndPublishEvent(String txId, String step, String eventType) {
    txRepo.updateStepState(txId, step, "DONE");
    outboxRepo.insert(new OutboxEvent(txId, eventType, "NEW"));
    // 事务提交后由 relay 异步发送，避免双写不一致
}
```

### 15.5 观测触发/回滚判定
```java
public void guardTxHealth() {
    double compRate = metrics.gauge("tx_compensation_rate").value();
    if (compRate > 0.02) {
        featureSwitch.disable("non_critical_tx");
        alerting.fire("TX_COMPENSATION_SPIKE", "rate=" + compRate);
    }
    long stuck = metrics.gauge("tx_stuck_count").longValue();
    if (stuck > 200) {
        scanner.triggerNow();
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 事务状态轮询（loading/error/done）
```javascript
import { useEffect, useState } from "react";

export function useTxStatus(txId) {
  const [state, setState] = useState({ phase: "idle", data: null, error: "" });

  useEffect(() => {
    let timer;
    let canceled = false;
    const poll = async () => {
      setState((s) => ({ ...s, phase: "loading" }));
      try {
        const res = await fetch(`/api/tx/v1/${encodeURIComponent(txId)}`);
        if (!res.ok) throw new Error(`HTTP_${res.status}`);
        const json = await res.json();
        if (!canceled) setState({ phase: "done", data: json, error: "" });
      } catch (e) {
        if (!canceled) setState({ phase: "error", data: null, error: String(e.message || e) });
      }
      timer = setTimeout(poll, 5000);
    };
    if (txId) poll();
    return () => {
      canceled = true;
      clearTimeout(timer);
    };
  }, [txId]);

  return state;
}
```

### 16.2 人工重试 API（幂等键 + 失败退避）
```javascript
export async function retryTxStep(txId, stepName) {
  const idem = `retry-${txId}-${stepName}-${Date.now()}`;
  let delay = 150;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch(`/api/tx/v1/${txId}/steps/${stepName}/retry`, {
        method: "POST",
        headers: { "X-Idempotency-Key": idem }
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 1000);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：状态机转移合法性、幂等去重、补偿可重入。
2. 集成测试：Outbox 投递一致性、重试与补偿闭环。
3. 压测：2 万 TPS 下状态库和消息系统稳定性。
4. 故障注入：下游超时、消息重复、乱序、丢失模拟。
5. 运维测试：DLQ 回放、人工补偿审批链路。

## 18. 丰富例子（>=10）
1. 库存扣减成功、订单失败，触发库存补偿。
2. 支付预授权成功、优惠券失败，撤销预授权。
3. Retry 连续失败进入 DLQ，人工补单。
4. 重复发起同 `requestId` 返回同一 `txId`。
5. 下游慢服务导致补偿率上升，触发降级。
6. 空回滚请求先到达，被幂等识别忽略。
7. 悬挂请求晚到，因状态已取消而拒绝执行。
8. Outbox relay 宕机后恢复并补发积压事件。
9. 卡单扫描器发现超时事务并触发重试。
10. 大促期间仅保留核心事务，非核心排队。
11. 人工“跳过步骤”被审计并二次审批。
12. 对账任务发现资金差异，触发修复工单。

## 19. 面试追问 + 可复述回答
1. 何时选 Saga 而不是 2PC？
回答：跨服务高并发场景优先 Saga，2PC 阻塞和可用性成本高。
2. 如何避免重复补偿？
回答：补偿步骤同样幂等，按 `txId+step+action` 去重。
3. 为什么需要 Outbox？
回答：解决“本地状态已提交但消息没发出去”的双写不一致。
4. 卡单怎么处理？
回答：定时扫描超时事务，自动重试；超过阈值转人工。
5. 资金场景还能只靠 Saga 吗？
回答：不够，需要加对账和清结算补偿，保证账实一致。

## 20. 新手学习路线
1. 先掌握本地事务与幂等基本功。
2. 学 2PC/TCC/Saga 三种模式与选型原则。
3. 实现一个最小 Saga 状态机（含补偿）。
4. 加入 Outbox、重试、DLQ、审计。
5. 最后做故障演练和对账闭环。

## 21. 上场前 Checklist
1. 能画出事务 master/step 状态机。
2. 能解释至少一种补偿失败处理策略。
3. 能量化补偿率/卡单阈值及处置动作。
4. 能讲清 Outbox 与幂等的配合关系。
5. 能说出人工兜底何时介入。
6. 能区分 Q40 与母题 Q13 的问题空间。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q13 Design Distributed Counter。

### 22.2 共性能力
1. 都是高并发下的分布式状态一致性问题。
2. 都依赖幂等、防重、重试治理。
3. 都需要可观测和故障恢复闭环。

### 22.3 关键差异
1. Q13 是单维状态累加；Q40 是多服务多步骤状态协同。
2. Q13 主要挑战热点与吞吐；Q40 主要挑战部分失败与补偿收敛。
3. Q13 通常不需要反向补偿；Q40 补偿是核心能力。
4. Q13 的一致性边界较简单；Q40 需要事务状态机。
5. Q40 需要人工兜底与审计流程，Q13 通常不需要如此复杂。

### 22.4 本题新增知识点（>=5）
1. Saga/TCC/2PC 选型框架。
2. 分布式事务状态机设计。
3. Outbox 可靠事件投递模式。
4. 补偿链路幂等与重入实现。
5. 卡单扫描与 DLQ 运维体系。
6. 资金类事务的对账补偿闭环。

### 22.5 面试差异话术
“母题 Q13 讲的是分布式状态写入的基础模式；Q40 在此之上解决跨服务业务事务收敛，重点是状态机、补偿和可运维性。”

---

## 单题自审（Q40）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 协作代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 流程含正常/高峰/故障恢复：通过。

### C. 专属性检查
1. 聚焦分布式事务，不混成支付业务题：通过。
2. 重点覆盖补偿/卡单/Outbox：通过。

### D. 工程落地检查
1. 告警阈值+处置动作完整：通过。
2. RTO/RPO、人工兜底路径明确：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端包含 API、状态流转、重试与幂等：通过。

### F. 母题差异检查
1. 与 Q13 的差异具体且可复述：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过）
