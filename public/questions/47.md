# Q47 Design Multi-Data Center System

> 来源校验（questions.ts）  
> `title`: Design Multi-Data Center System  
> `tags`: 数据复制, 就近访问, 故障转移, 一致性, 多活  
> `keyPoints`: 数据复制策略, 就近路由, 故障转移, 一致性保证, 多活架构  
> `learningCoreId`: 13（母题：Design Distributed Counter）

## 1. 三句话题目本质
1. 多数据中心题本质是“跨地域提升可用性与时延体验”。
2. 核心难点在一致性代价、故障切换复杂度和流量路由策略。
3. 高分回答要讲清：拓扑、复制模式、路由、切换策略和数据冲突处理。

## 2. 一个真实场景故事
某跨境电商原本单区域部署，东南亚用户支付确认延迟高且区域故障时全站不可用。升级为双 Region 主备后，可用性提升但出现“库存短时不一致”。进一步引入按业务分级一致性策略：支付单主写、商品多活读写+冲突合并，既保障关键链路正确，也改善跨区体验。

## 3. 术语白话表（>=10）
1. Active-Passive：一地主写，另一地热备。
2. Active-Active：多地同时服务读写。
3. RPO：可接受数据丢失窗口。
4. RTO：故障恢复目标时间。
5. Geo-DNS：基于地理位置路由。
6. Anycast：网络层就近路由方式。
7. Replication Lag：跨区复制延迟。
8. Quorum：法定票数，保证一致性。
9. Split Brain：脑裂，多个主同时写。
10. Conflict Resolution：冲突合并策略。
11. Fencing：防止旧主继续写。
12. Runbook：故障处置手册。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持跨地域用户就近访问。
2. 支持区域故障自动/半自动切换。
3. 支持跨区数据复制与一致性策略。
4. 支持业务分级（强一致/最终一致）。
5. 支持跨区观测和灾备演练。

### 4.2 非功能需求
1. 全球可用性 >= 99.99%。
2. 跨区读延迟显著降低。
3. 灾难场景下核心功能可持续。
4. 切换可控、可追踪、可回滚。

### 4.3 不做范围
1. 不做全球强一致数据库内核设计。
2. 不做任意多区域全网多主写。
3. 不做 CDN 全链路设计细节。

### 4.4 SLO
1. 核心 API 可用性 >= 99.99%。
2. 区域故障切换 RTO <= 5 分钟。
3. 核心账务链路 RPO <= 10 秒。

## 5. 容量估算（数字推导）
1. 全站峰值 40 万 QPS，按美东 45%、亚太 35%、欧洲 20% 分布。
2. 跨区复制写流量 8 万 QPS，平均记录 500B，约 40MB/s。
3. 若双区同步复制，网络预留需 >100MB/s（含重传与开销）。
4. 灾备切换后单区需承接 100% 流量，容量至少按 1.5 倍常态准备。
5. 日志与变更流保留 7 天，便于回放与冲突修复。
6. 结论：容量设计必须按“单区失效”场景，而不是平时均值。

## 6. 架构（简版+完整版）
### 6.1 简版
`Global DNS -> Regional Gateway -> Regional Services -> Cross-Region Replication`

### 6.2 完整版
1. Traffic Layer：Geo-DNS + 健康探测。
2. Regional Gateway：区域入口限流与熔断。
3. Service Cluster：各 Region 独立服务集群。
4. Data Layer：主数据库+跨区复制链路。
5. Conflict Resolver：多活冲突检测与合并。
6. Control Plane：故障切换编排与开关。
7. Observability：跨区指标、链路追踪、日志聚合。
8. DR Console：演练、切换、回切操作台。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 故障切换触发
`POST /api/dr/v1/failover`

请求：
```json
{
  "fromRegion": "us-east-1",
  "toRegion": "ap-southeast-1",
  "planId": "dr-20260224-001"
}
```

### 7.2 复制状态查询
`GET /api/dr/v1/replication/status`

错误码：
1. `409_FAILOVER_IN_PROGRESS`
2. `422_REGION_NOT_HEALTHY`
3. `503_CONTROL_PLANE_DEGRADED`
4. `409_PLAN_DUPLICATED`

幂等规则：
1. `planId` 唯一，重复切换请求返回同状态。
2. 回切需新 `planId`，防止误重放。

## 8. 数据模型（实体/索引/分片）
1. `region_health(region, status, latency_ms, updated_at)`。
2. `replication_offset(stream, region, offset, lag_ms)`。
3. `failover_plan(plan_id, from_region, to_region, state, actor)`。
4. `conflict_record(entity_key, left_ver, right_ver, resolved_by)`。
5. `dr_audit(audit_id, action, detail, ts)`。

索引设计：
1. `plan_id` 唯一索引。
2. `stream+region` 联合索引看复制进度。
3. `entity_key+ts` 索引用于冲突追踪。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 用户通过 Geo-DNS 路由到最近 Region。
2. 请求在本区处理并写本区主库。
3. 变更异步复制到其他 Region。

### 9.2 高峰流程
1. 某区过载时跨区分流部分只读流量。
2. 写请求仍按主写策略保持一致性。
3. 启动弹性扩容与热点缓存缓冲。

### 9.3 故障恢复流程
1. 健康探测判定区域不可用。
2. Control Plane 执行切换 runbook（冻结写->提升备区->切流）。
3. 服务恢复后进行差异对账并回切。

## 10. 一致性与事务边界
1. 核心交易采用单主写+同步/准同步复制。
2. 非关键数据可多主写+最终一致冲突合并。
3. 事务边界在单 Region 内，跨区靠事件补偿。
4. 防脑裂：切换时发 fencing token 阻止旧主写入。
5. 冲突策略按业务定义（LWW、向量时钟、业务合并）。

## 11. 可用性与容错（含 RTO/RPO）
1. 双区或三区部署，避免单点区域风险。
2. DNS、网关、控制面都要冗余。
3. 定期灾备演练验证 runbook 可执行性。
4. RTO：5 分钟内切换核心链路。
5. RPO：核心<=10秒，非核心可放宽到分钟级。

## 12. 可观测性（指标+阈值+处置动作）
1. `replication_lag_ms` > 5000：暂停跨区写扩散并告警。
2. `region_error_rate` > 2%（3m）：触发预切换流程。
3. `geo_dns_fail_rate` > 0.5%：切备用 DNS 提供商。
4. `failover_duration_sec` > 300：升级 P1 并人工介入。
5. `conflict_unresolved_count` > 1000：启动冲突批处理。
6. `cross_region_rtt_ms` 持续升高：调整路由策略与带宽。

## 13. 安全与合规
1. 跨区链路全程 TLS 加密。
2. 数据主权要求按地区隔离存储。
3. 灾备切换操作最小权限+审批。
4. 审计日志长期保留可追责。
5. 密钥跨区轮转与托管。

## 14. 成本与取舍
1. 多活体验好但一致性与运维成本高。
2. 主备简单但跨区故障切换损失更大。
3. 同步复制一致性强但写延迟更高。
4. 取舍：核心链路主备强一致，非核心多活最终一致。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法/状态转移：故障切换状态机
```java
public void transit(FailoverState from, FailoverState to) {
    if (!fsm.canTransit(from, to)) throw new IllegalStateException("invalid failover transition");
    planRepo.updateState(currentPlanId, to.name());
}
```

### 15.2 幂等去重：planId
```java
public FailoverResult trigger(FailoverRequest req) {
    FailoverPlan existed = planRepo.findByPlanId(req.planId());
    if (existed != null) return FailoverResult.duplicate(existed.state());
    planRepo.insert(req.planId(), req.fromRegion(), req.toRegion(), "INIT");
    return FailoverResult.accepted();
}
```

### 15.3 重试退避/失败处理：切流动作
```java
public void switchTrafficWithRetry(String toRegion) {
    long delay = 200;
    for (int i = 0; i < 4; i++) {
        try {
            dnsClient.updateWeight(toRegion, 100);
            return;
        } catch (RuntimeException ex) {
            if (i == 3) throw ex;
            sleep(delay);
            delay = Math.min(delay * 2, 2000);
        }
    }
}
```

### 15.4 一致性边界：fencing token
```java
@Transactional
public long issueFencingToken(String region) {
    long token = tokenRepo.next(region);
    controlRepo.setActiveToken(region, token);
    return token;
}
```

### 15.5 观测触发/回滚判定
```java
public void guardReplication() {
    long lag = metrics.gauge("replication_lag_ms").longValue();
    if (lag > 5000) {
        featureSwitch.disable("cross_region_multi_write");
        alerting.fire("REPLICATION_LAG_HIGH", "lag=" + lag);
    }
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 复制状态查询（loading/error/done）
```javascript
import { useEffect, useState } from "react";

export function useReplicationStatus() {
  const [state, setState] = useState({ phase: "idle", data: null, error: "" });
  useEffect(() => {
    let timer;
    const load = async () => {
      setState((s) => ({ ...s, phase: "loading" }));
      try {
        const res = await fetch("/api/dr/v1/replication/status");
        if (!res.ok) throw new Error(`HTTP_${res.status}`);
        setState({ phase: "done", data: await res.json(), error: "" });
      } catch (e) {
        setState({ phase: "error", data: null, error: String(e.message || e) });
      }
      timer = setTimeout(load, 8000);
    };
    load();
    return () => clearTimeout(timer);
  }, []);
  return state;
}
```

### 16.2 故障切换触发（幂等+重试）
```javascript
export async function triggerFailover(fromRegion, toRegion) {
  const planId = `dr-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 200;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch("/api/dr/v1/failover", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Idempotency-Key": planId },
        body: JSON.stringify({ fromRegion, toRegion, planId })
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 1200);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：状态机、fencing、冲突合并策略。
2. 集成测试：复制链路、切流流程、回切流程。
3. 压测：单区失效时流量接管能力。
4. 故障测试：网络分区、DNS 故障、复制积压。
5. 演练测试：季度灾备演练和审计回放。

## 18. 丰富例子（>=10）
1. 亚太用户路由到本地 Region，延迟下降。
2. 美东故障后 4 分钟切到亚太。
3. 复制积压时暂停多主写避免冲突放大。
4. 旧主节点被 fencing 拦截写入。
5. 非核心数据冲突采用 LWW 自动合并。
6. 核心账务对账发现差异后人工修复。
7. DNS 提供商故障时切备用供应商。
8. 运营误触发切换被审批拦截。
9. 回切前先做只读预热降低抖动。
10. 单区流量突增触发跨区只读分流。
11. 日志跨区延迟升高触发带宽扩容。
12. 演练复盘沉淀 runbook 更新。

## 19. 面试追问 + 可复述回答
1. 多活一定更好吗？
回答：可用性高但一致性和成本高，不是所有业务都适合。
2. 如何防脑裂？
回答：租约+fencing token+写入仲裁，旧主必须被隔离。
3. 故障切换怎么做得可控？
回答：预案化状态机+自动探测+人工确认关键步骤。
4. 复制延迟大怎么办？
回答：分级降级、暂停多写、优先核心数据同步。
5. 与一般分布式题差异？
回答：这里重点是跨地域容灾和流量路由，不只是单集群一致性。

## 20. 新手学习路线
1. 学主备与多活基本拓扑。
2. 学复制延迟和一致性权衡。
3. 学切换流程与 runbook。
4. 学冲突合并与对账补偿。
5. 做灾备演练并量化 RTO/RPO。

## 21. 上场前 Checklist
1. 能讲清 active-passive 与 active-active 取舍。
2. 能解释 RTO/RPO 对业务影响。
3. 能描述切换状态机和防脑裂机制。
4. 能给出跨区复制监控阈值。
5. 能说明与母题 Q13 的差异。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q13 Design Distributed Counter。

### 22.2 共性能力
1. 都涉及分布式状态与一致性。
2. 都需要高可用与故障恢复。
3. 都依赖可观测与阈值治理。

### 22.3 关键差异
1. Q13 聚焦单系统计数扩展；Q47 聚焦跨地域容灾和路由。
2. Q47 额外处理跨区复制延迟与冲突。
3. Q47 需要流量切换与 DNS 策略。
4. Q47 防脑裂要求更高。
5. Q47 强调 RTO/RPO 指标与演练。

### 22.4 本题新增知识点（>=5）
1. 多数据中心拓扑选型。
2. 跨区复制策略与延迟治理。
3. 故障切换 runbook 状态机。
4. fencing token 防脑裂。
5. 冲突合并与回切对账。
6. Geo-DNS 与就近路由策略。

### 22.5 面试差异话术
“Q13 处理单集群分布式一致性；Q47 处理跨地域灾备和流量切换，重点是复制、路由、切换和冲突治理。”

---

## 单题自审（Q47）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦多数据中心容灾，不模板化：通过。
2. 复制、路由、切换、多活一致性完整：通过。

### D. 工程落地检查
1. 阈值与动作绑定：通过。
2. RTO/RPO 和演练策略明确：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端满足 API/状态流转/重试幂等：通过。

### F. 母题差异检查
1. 与 Q13 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过）
