# Q28 数据库索引系统设计（面试高分版）

## 1. 三句话题目本质
1. 索引题本质是“用空间换时间”，目标是让高频查询快、且不要把写入拖垮。  
2. 真正难点是：索引选型、执行计划稳定、在线变更风险控制。  
3. 面试要讲“为什么建这个索引、如何验证收益、坏了怎么回滚”。

## 2. 真实场景故事（问题-方案-结果）
- 问题：订单表 8 亿行，用户查订单列表 P95 4 秒。  
- 方案：按查询模式重建复合索引 `(user_id, status, created_at desc)`，并补覆盖列减少回表；上线后观察写入退化。  
- 结果：查询 P95 降到 25ms，写入增加 12% CPU，最终通过冷热索引分层把写入成本降回可控。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| B+Tree | 最常见数据库索引结构 | 范围查询和排序友好 |
| 聚簇索引 | 数据按索引顺序存放 | 主键查询最快 |
| 二级索引 | 单独维护的辅助索引 | 可能需要回表 |
| 覆盖索引 | 查询列都在索引里 | 不回表，延迟更低 |
| 复合索引 | 多列组合索引 | 要遵守最左匹配 |
| 选择性 | 字段区分能力 | 区分度低索引价值小 |
| 回表 | 先查索引再查数据行 | 会增加随机IO |
| Explain Plan | 执行计划 | 判断是否命中索引 |
| 统计信息 | 优化器估算依据 | 过期会选错计划 |
| Online DDL | 在线索引变更 | 尽量不停机 |
| 索引碎片 | 索引页不连续 | 会拖慢扫描性能 |
| Plan Regression | 计划退化 | 同SQL延迟突然变差 |

## 4. 需求澄清（功能/非功能/不做/SLO）
### 4.1 功能需求
1. 支持高频查询索引设计和管理。  
2. 支持在线创建/删除/重建索引。  
3. 支持执行计划诊断和回滚。  
4. 支持索引使用率与成本观测。

### 4.2 非功能需求
1. 查询低延迟。  
2. 写入退化受控。  
3. 变更风险可控。  
4. 大表在线操作可恢复。

### 4.3 不做范围
1. 不做数据库内核完整实现。  
2. 不做跨库分布式事务。  
3. 不做备份系统设计。

### 4.4 SLO
1. 目标查询 P95 < 30ms。  
2. 索引上线后写入退化 < 20%。  
3. 在线DDL失败回滚 RTO < 15min。

## 5. 容量估算（含数字推导）
1. 8 亿行，每条索引键平均 40B，单索引粗估 `32GB+`。  
2. 若 3 个二级索引，总索引体量接近 `100GB`。  
3. 写入 20k TPS，每次维护 3 索引，相当于索引写放大约 3 倍。  
4. 若热点查询占 60%，覆盖索引可把回表比例降到 <10%。  
5. 索引重建期间会增加 1~2 倍 IO，需限速窗口执行。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
SQL -> Optimizer -> Index Access -> Data Page -> Result
```

### 6.2 完整版
```text
Query Gateway
  -> SQL Parser
  -> Optimizer (cost-based + stats)
  -> Plan Cache
  -> Storage Engine (B+Tree / heap pages)

Index Control Plane
  -> Index Advisor
  -> Online DDL Manager
  -> Rebuild Worker
  -> Plan Regression Detector

Observability
  -> query latency / scan ratio / index hit ratio / ddl progress
```

## 7. API设计（请求/响应/错误码/幂等）
1. `POST /api/v1/indexes` 创建索引  
2. `DELETE /api/v1/indexes/{name}` 删除索引  
3. `GET /api/v1/plans/explain?sqlHash=...` 查看计划  
4. `POST /api/v1/indexes/{name}/rebuild` 重建索引  

幂等：`Idempotency-Key: ddl-{table}-{index}-{ts}`  
错误码：`DDL_LOCK_TIMEOUT`、`PLAN_REGRESSION`、`INDEX_ALREADY_EXISTS`

## 8. 数据模型（实体/索引/分区）
1. `index_meta(index_name, table_name, columns, status, created_at)`  
2. `index_usage(index_name, hit_count, last_used_at)`  
3. `ddl_job(job_id, op_type, progress, status)`  
4. `query_plan(sql_hash, plan_json, cost, updated_at)`  
5. `plan_alert(sql_hash, old_plan, new_plan, impact)`  
6. 分区表需区分本地索引与全局索引策略。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常
SQL -> 优化器选索引 -> 索引扫描 -> 可选回表 -> 返回。

### 9.2 高峰
热点查询突增 -> 计划缓存命中 -> 若命中率下降触发 plan pin（临时固定计划）。

### 9.3 故障恢复
索引变更导致计划退化 -> 回滚到旧索引版本 -> 清理 plan cache -> 恢复服务。

## 10. 一致性与事务边界
1. 数据写入与索引维护在同一事务提交。  
2. Online DDL 使用一致性快照，避免读脏数据。  
3. 统计信息更新是最终一致，可能导致短期计划抖动。  
4. 关键SQL可配置“计划白名单”降低回归风险。

## 11. 可用性与容错（含RTO/RPO）
1. Online DDL 分阶段执行（prepare/build/switch）。  
2. DDL 锁超时自动回滚。  
3. 索引损坏自动下线，回退全扫+限流。  
4. 大表重建支持断点续跑。  
5. RTO 15min，RPO 0（事务日志恢复）。

## 12. 可观测性（指标 + 阈值 + 动作）
指标：
- `query_p95_ms`
- `index_hit_ratio`
- `full_scan_ratio`
- `ddl_job_duration_sec`
- `plan_regression_count`

阈值与动作：
1. `full_scan_ratio > 20%` 持续 10min -> P1，触发计划回滚。  
2. `query_p95_ms > 120ms` 持续 10min -> P1，检查统计信息和索引失效。  
3. `plan_regression_count > 50/h` -> P1，冻结相关DDL。  
4. `ddl_job_duration_sec` 超预期 2 倍 -> P2，降速或切维护窗口。

## 13. 安全与合规
1. DDL 接口 RBAC + 审批。  
2. 索引变更审计落库。  
3. 敏感列索引需脱敏/哈希策略评审。  
4. SQL 输入参数化，防注入。

## 14. 成本与取舍
1. 索引越多查询越快，但写入和存储成本上升。  
2. 覆盖索引减少回表，但会拉大索引体积。  
3. 统计信息越频繁越稳定，但维护开销变大。  
4. 计划强制固定稳定性高，但可能错过更优新计划。

## 15. Java关键代码（>=5段）
### 15.1 索引候选打分
```java
public class IndexAdvisor {
    public double benefitScore(double selectivity, double qps, double writePenalty, double coverBonus) {
        double readGain = selectivity * qps;
        double score = readGain + coverBonus - writePenalty;
        return Math.max(score, 0);
    }

    public List<IndexCandidate> rank(List<IndexCandidate> candidates) {
        return candidates.stream()
                .sorted((a, b) -> Double.compare(b.score(), a.score()))
                .toList();
    }
}
```

### 15.2 最左匹配判断
```java
public class CompositeIndexMatcher {
    public boolean match(List<String> indexCols, List<String> whereCols) {
        if (whereCols.size() == 0) return false;
        for (int i = 0; i < whereCols.size() && i < indexCols.size(); i++) {
            if (!indexCols.get(i).equals(whereCols.get(i))) return false;
        }
        return true;
    }
}
```

### 15.3 计划回归检测
```java
public class PlanRegressionDetector {
    public boolean isRegression(long oldP95, long newP95) {
        return newP95 > oldP95 * 2;
    }

    public boolean shouldRollback(long oldP95, long newP95, double fullScanRatio) {
        return isRegression(oldP95, newP95) || fullScanRatio > 0.2;
    }
}
```

### 15.4 在线重建任务
```java
public class RebuildJobService {
    public void start(String indexName) {
        DdlJob job = ddlRepo.create("REBUILD", indexName);
        rebuildWorker.submit(job.getJobId());
    }
}
```

### 15.5 DDL幂等执行
```java
public class DdlCommandService {
    public void createIndex(CreateIndexCmd cmd) {
        if (idemRepo.exists(cmd.idemKey())) return;
        ddlEngine.create(cmd.table(), cmd.index(), cmd.columns());
        idemRepo.save(cmd.idemKey());
    }
}
```

## 16. 前端功能代码（React JS >=2段，API协作）
### 16.1 索引管理 API 模块（创建/查询）
```javascript
export async function listIndexes() {
  try {
    const r = await fetch("/api/v1/indexes");
    if (!r.ok) throw new Error(`HTTP_${r.status}`);
    const d = await r.json();
    return { ok: true, items: d.items || [], error: "" };
  } catch (e) {
    return { ok: false, items: [], error: String(e.message || e) };
  }
}

export async function createIndex(payload, retry = 0) {
  try {
    const r = await fetch("/api/v1/indexes", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Idempotency-Key": `create-${Date.now()}`
      },
      body: JSON.stringify(payload)
    });
    if (!r.ok) throw new Error(`HTTP_${r.status}`);
    return { ok: true, status: "CREATED", error: "" };
  } catch (e) {
    if (retry < 2) return createIndex(payload, retry + 1);
    return { ok: false, status: "FAILED", error: `创建失败: ${String(e.message || e)}` };
  }
}
```

### 16.2 执行计划 API 模块（Explain + 回归检测）
```javascript
export async function explainPlan(sqlHash) {
  try {
    const r = await fetch(`/api/v1/plans/explain?sqlHash=${encodeURIComponent(sqlHash)}`);
    if (!r.ok) throw new Error(`HTTP_${r.status}`);
    const d = await r.json();
    return { ok: true, plan: d, error: "" };
  } catch (e) {
    return { ok: false, plan: null, error: `Explain失败: ${String(e.message || e)}` };
  }
}

export function detectRegression(oldP95, newP95, fullScanRatio) {
  return {
    rollback: newP95 > oldP95 * 2 || fullScanRatio > 0.2,
    reason: newP95 > oldP95 * 2 ? "latency_regression" : (fullScanRatio > 0.2 ? "full_scan_too_high" : "ok")
  };
}
```

## 17. 测试策略
1. 单测：索引匹配规则、回归检测逻辑。  
2. 集成：建索引->查询提速->删索引回退。  
3. 压测：高并发读写下索引维护开销。  
4. 故障注入：DDL锁冲突、统计信息漂移。  
5. 回归：关键SQL基线对比。

## 18. 丰富例子（>=10）
1. 复合索引顺序不对导致完全不命中。  
2. 覆盖索引减少回表后延迟下降 70%。  
3. 低选择性字段建索引反而拖慢写入。  
4. 统计信息过期导致计划退化。  
5. Online DDL 与业务写入冲突。  
6. 分区表局部索引导致跨分区慢查。  
7. 索引碎片高导致扫描慢。  
8. Hint 固定计划短期止血，长期需修复根因。  
9. 回滚索引后计划恢复。  
10. 热点查询被 plan cache 污染。  
11. 大表重建如何分批限速。  
12. 审计发现未审批DDL后的处置。

## 19. 面试追问 + 可复述回答
1. 为什么不是“所有列都建索引”？  
可复述：索引有写入和存储成本，收益要看查询频次和选择性。  

2. 如何判断索引是否有效？  
可复述：看 Explain、命中率、full scan 比例和真实延迟。  

3. 上线索引最怕什么？  
可复述：计划回归和写入抖动，所以必须灰度、观测、可回滚。

## 20. 新手学习路线
1. 先学 B+Tree 与最左匹配。  
2. 再学 Explain 读法。  
3. 学覆盖索引和回表成本。  
4. 学 Online DDL 与回滚流程。  
5. 学计划回归治理。

## 21. 上场前Checklist
- [ ] 能解释为什么选择这个复合索引顺序。  
- [ ] 能给出至少3个索引告警阈值。  
- [ ] 能说明上线索引灰度和回滚。  
- [ ] 能讲清写放大与成本权衡。  
- [ ] 能区分本题与分库分表题。

## 22. 与母题差异（对应 Q15）
### 22.1 对应母题
- Q15 数据库拆分与一致性哈希

### 22.2 共性能力
1. 数据层性能优化。  
2. 路由与查询效率治理。  
3. 变更风险控制。  
4. 可观测与应急恢复。

### 22.3 关键差异（>=5条）
1. Q28 关注“单库/单分片内索引”，Q15 关注“跨分片扩展”。  
2. Q28 核心是执行计划和回表成本。  
3. Q15 核心是分片键、迁移、跨分片查询。  
4. Q28 偏局部查询优化，Q15 偏全局架构扩展。  
5. Q28 主要风险是计划回归，Q15 主要风险是数据迁移一致性。

### 22.4 本题新增必补知识（>=5条）
1. B+Tree 与复合索引顺序。  
2. 覆盖索引与回表权衡。  
3. Explain 与计划诊断。  
4. Online DDL 风险控制。  
5. 索引碎片和统计信息治理。

### 22.5 面试差异话术（3条）
1. “Q15 解决扩不动，Q28 解决查不快。”  
2. “Q28 我会重点讲执行计划和索引上线风险，不展开分库迁移。”  
3. “Q28 是性能深挖题，Q15 是架构扩展题。”
