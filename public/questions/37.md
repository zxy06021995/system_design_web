# Q37 API Rate Limiter（网关限流系统）- 面试高分版

## 1. 三句话题目本质
1. 限流器是网关稳定性的第一道闸门，目标是“在不拖垮核心服务的前提下尽量放行正常请求”。  
2. 难点在于多维规则（租户/API/用户）、突发流量吸收、误杀控制和依赖故障降级。  
3. 面试高分要讲清：算法选择、网关接入、回退策略、监控阈值和策略发布流程。

## 2. 真实场景故事（问题-方案-结果）
- 问题：支付回调接口被突发流量冲击，后端线程池耗尽，整个网关响应雪崩。  
- 方案：上线多级限流（本地令牌桶 + Redis滑窗）；核心租户保底配额；策略先干跑再灰度。  
- 结果：高峰期核心链路可用性恢复到 99.95%，429 拒绝率可控，误杀率降到 0.3%。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Token Bucket | 令牌桶 | 允许短突发，长期受速率约束 |
| Leaky Bucket | 漏桶 | 把流量平滑输出 |
| Sliding Window | 滑动窗口 | 统计更准确但成本更高 |
| Fixed Window | 固定窗口 | 实现简单但边界误差大 |
| Burst | 突发容量 | 桶内可一次性消费令牌 |
| Quota | 配额 | 一段时间可用额度 |
| Retry-After | 重试建议时间 | 429时告诉客户端多久再试 |
| Dry Run | 干跑模式 | 只统计不拦截，用于验证规则 |
| Fail-open | 失败放行 | 限流依赖故障时优先可用 |
| Fail-close | 失败拒绝 | 高风险接口优先安全 |
| Global Limit | 全局限流 | 全站总量保护 |
| Tenant Limit | 租户限流 | 防单租户打满全局资源 |

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持按 API、用户、租户、IP 多维限流。  
2. 支持突发流量吸收与长期速率控制。  
3. 支持动态策略发布、灰度与回滚。  
4. 支持 429 标准响应与 `Retry-After`。  
5. 支持干跑模式评估误杀。

### 4.2 非功能需求
1. 判定延迟低。  
2. 限流服务高可用。  
3. 误杀率可观测可治理。  
4. 降级行为可配置。

### 4.3 不做范围
1. 不做完整 WAF。  
2. 不做业务风控评分模型。  
3. 不做计费结算。

### 4.4 SLO
1. 判定延迟 P95 < 5ms。  
2. 限流服务可用性 >= 99.99%。  
3. 误杀率 < 0.5%。  
4. 策略生效延迟 P95 < 3s。

## 5. 容量估算（含数字推导）
1. 网关峰值 500k QPS。  
2. 每请求至少一次限流判定，判定吞吐同量级。  
3. 若 10% 请求触发多维规则叠加，限流判定计算约 550k ops/s。  
4. 计数键规模百万级，需短TTL高频更新。  
5. 热租户可占 20% 流量，必须有租户隔离配额。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
Gateway -> Limiter Engine -> Counter Store
```

### 6.2 完整版
```text
API Gateway
  -> Local Limiter (token bucket)
  -> Distributed Limiter (Redis sliding window)
  -> Decision Combiner (allow/deny + reason)
  -> Response Decorator (429 + Retry-After)

Control Plane
  -> Policy Service (versioned rules)
  -> Gray Publisher
  -> Dry-run Analyzer
  -> Rollback Controller

Observability
  -> Metrics / Logs / Trace
  -> Alerting / Runbook
```

## 7. API设计（请求/响应/错误码/幂等）
1. `POST /api/v1/ratelimit/check`  
2. `POST /api/v1/ratelimit/policies`  
3. `POST /api/v1/ratelimit/policies/{id}/publish`  
4. `POST /api/v1/ratelimit/policies/{id}/rollback`

错误码：
- `POLICY_INVALID`、`LIMITER_DEGRADED`、`TENANT_QUOTA_EXCEEDED`、`DRYRUN_ONLY`

幂等：
- 发布/回滚接口需 `Idempotency-Key` 避免重复生效。

## 8. 数据模型（核心表/索引）
1. `limit_policy(policy_id, scope, key_expr, algo, rate, burst, status, version)`  
2. `limit_counter(counter_key, window_start, count, expire_at)`  
3. `limit_decision_log(ts, policy_id, dimension_key, allowed, reason)`  
4. `tenant_quota(tenant_id, guaranteed_qps, max_burst)`  
5. `policy_publish_log(policy_id, version, result, ts)`  
6. 索引：`(scope, status)`、`(tenant_id)`、`(policy_id, version)`。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常链路
请求进入网关 -> 生成多维 key -> 本地限流判定 -> 分布式确认 -> 允许或429。

### 9.2 高峰链路
流量突增 -> 非核心租户先触发限流 -> 核心租户保底配额 -> 后端稳定。

### 9.3 故障恢复链路
Redis 超时 -> 限流器进入降级模式（本地保守限流）-> 依赖恢复后回切。

## 10. 一致性与事务边界
1. 计数是近似一致，不追求强一致。  
2. 策略发布按版本原子切换。  
3. 判定以稳定性优先于绝对精确。  
4. 高风险接口可配置 fail-close，其余接口 fail-open。

## 11. 可用性与容错（含RTO/RPO）
1. 限流服务多副本 + 网关本地兜底。  
2. 分布式计数故障时降级本地限流。  
3. 发布异常一键回滚到前版本。  
4. RTO 5 分钟，RPO 0（策略版本可回放）。

## 12. 可观测性（指标 + 阈值 + 动作）
指标：
- `decision_p95_ms`
- `allow_rate`
- `reject_qps`
- `false_positive_rate`
- `counter_store_timeout_rate`

阈值与动作：
1. `decision_p95_ms > 10ms` 持续 10 分钟 -> P1，降级多维规则复杂度。  
2. `reject_qps` 突增 3 倍 -> P1，检查误配置并启用策略回滚。  
3. `false_positive_rate > 1%` -> P1，切换策略到 dry-run 并人工复核。  
4. `counter_store_timeout_rate > 5%` -> P1，切本地保守限流。

## 13. 安全与合规
1. 策略变更 RBAC + 审批。  
2. 管理接口限流防滥用。  
3. 审计策略改动与发布操作。  
4. 核心租户保护策略单独管控。

## 14. 成本与取舍
1. 滑窗更准但 Redis 成本高。  
2. 本地限流延迟低但全局精度弱。  
3. 多维规则越多越精细，但维护成本越高。  
4. fail-open 提升可用性但可能放过流量尖峰。

## 15. Java关键代码（>=5段）
### 15.1 令牌桶判定
```java
public class TokenBucketLimiter {
    private double tokens;
    private final double ratePerSec;
    private final double capacity;
    private long lastRefillMs;

    public TokenBucketLimiter(double ratePerSec, double capacity) {
        this.ratePerSec = ratePerSec;
        this.capacity = capacity;
        this.tokens = capacity;
        this.lastRefillMs = System.currentTimeMillis();
    }

    public synchronized boolean allow() {
        refill(System.currentTimeMillis());
        if (tokens >= 1.0) {
            tokens -= 1.0;
            return true;
        }
        return false;
    }

    private void refill(long nowMs) {
        double add = (nowMs - lastRefillMs) / 1000.0 * ratePerSec;
        tokens = Math.min(capacity, tokens + add);
        lastRefillMs = nowMs;
    }
}
```

### 15.2 滑动窗口计数（Redis）
```java
public class SlidingWindowCounter {
    public long incrAndCount(String key, long nowMs, long windowMs) {
        long bucket = nowMs / 1000; // second bucket
        String redisKey = key + ":" + bucket;
        redis.incr(redisKey);
        redis.expire(redisKey, (int) (windowMs / 1000 + 2));
        long sum = 0;
        long startBucket = (nowMs - windowMs) / 1000;
        for (long b = startBucket; b <= bucket; b++) {
            sum += redis.getLong(key + ":" + b);
        }
        return sum;
    }
}
```

### 15.3 多维限流Key生成
```java
public class LimitKeyBuilder {
    public List<String> keys(RequestCtx ctx) {
        return List.of(
            "api:" + ctx.api(),
            "tenant:" + ctx.tenantId() + ":api:" + ctx.api(),
            "user:" + ctx.userId() + ":api:" + ctx.api()
        );
    }
}
```

### 15.4 判定与拒绝响应
```java
public class DecisionService {
    public Decision decide(RequestCtx ctx, List<Policy> policies) {
        for (Policy p : policies) {
            if (!p.matcher().test(ctx)) continue;
            if (!p.limiter().allow(ctx)) {
                return Decision.reject(429, p.retryAfterSec(), "LIMITED_BY_" + p.id());
            }
        }
        return Decision.allow();
    }
}
```

### 15.5 策略热更新与回滚
```java
public class PolicyVersionService {
    public void publish(long policyId, long version) {
        if (!validator.pass(policyId, version)) throw new IllegalStateException("invalid");
        policyRepo.atomicSwitch(policyId, version);
    }

    public void rollback(long policyId) {
        long prev = policyRepo.previousStableVersion(policyId);
        policyRepo.atomicSwitch(policyId, prev);
    }
}
```

## 16. 前端功能代码（React JS >=2段，API协作）
### 16.1 策略发布 API 模块（提交+重试+状态）
```javascript
export async function createPolicy(payload, retry = 0) {
  try {
    const resp = await fetch("/api/v1/ratelimit/policies", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Idempotency-Key": `policy-${Date.now()}`
      },
      body: JSON.stringify(payload)
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    return { ok: true, policyId: data.policyId, error: "" };
  } catch (e) {
    if (retry < 2) return createPolicy(payload, retry + 1);
    return { ok: false, policyId: "", error: `创建失败: ${String(e.message || e)}` };
  }
}

export async function publishPolicy(policyId) {
  try {
    const resp = await fetch(`/api/v1/ratelimit/policies/${policyId}/publish`, { method: "POST" });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, status: "PUBLISHED", error: "" };
  } catch (e) {
    return { ok: false, status: "FAILED", error: `发布失败: ${String(e.message || e)}` };
  }
}
```

### 16.2 指标与回滚 API 模块（拉取指标+触发回滚）
```javascript
export async function fetchLimiterMetrics() {
  try {
    const resp = await fetch("/api/v1/ratelimit/stats");
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    return { ok: true, metrics: data, error: "" };
  } catch (e) {
    return { ok: false, metrics: {}, error: `指标拉取失败: ${String(e.message || e)}` };
  }
}

export async function rollbackPolicy(policyId) {
  try {
    const resp = await fetch(`/api/v1/ratelimit/policies/${policyId}/rollback`, {
      method: "POST",
      headers: { "Idempotency-Key": `rollback-${policyId}-${Date.now()}` }
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    return { ok: true, status: "ROLLED_BACK", error: "" };
  } catch (e) {
    return { ok: false, status: "FAILED", error: `回滚失败: ${String(e.message || e)}` };
  }
}
```

## 17. 测试策略
1. 单测：令牌桶、滑窗计数、多维 key。  
2. 集成：网关接入判定、429 响应语义。  
3. 压测：突发流量、租户隔离。  
4. 故障注入：Redis 超时、策略误发布。  
5. 回归：误杀率、放行率、延迟变化。

## 18. 丰富例子（>=10）
1. 秒级突发流量如何被 token bucket 吸收。  
2. 单租户爆量时如何不影响其他租户。  
3. 滑窗统计延迟变高如何优化。  
4. Redis 抖动时为何要本地保守限流。  
5. 误配置导致拒绝率暴涨如何回滚。  
6. 客户端重试风暴如何配合 Retry-After。  
7. 多机时钟偏差对滑窗统计影响。  
8. 干跑模式如何评估误杀率。  
9. 核心支付接口为何使用 fail-close。  
10. 非核心查询接口为何可 fail-open。  
11. 多维规则冲突如何定义优先级。  
12. 高峰时策略发布为何必须灰度。

## 19. 面试追问 + 可复述回答
1. 为什么本地+分布式两级限流？  
可复述：本地快、分布式准，组合是延迟和精度的平衡。  

2. 如何降低误杀？  
可复述：策略先 dry-run，分批灰度，指标异常自动回滚。  

3. Retry-After 有什么价值？  
可复述：指导客户端退避，减少无效重试风暴。

## 20. 新手学习路线
1. 先学四类限流算法。  
2. 再学网关接入点。  
3. 再学多维规则与优先级。  
4. 最后学观测、灰度和回滚机制。

## 21. 上场前 Checklist
- [ ] 能解释令牌桶与滑窗取舍。  
- [ ] 能讲清多维限流键设计。  
- [ ] 能给出3个告警阈值和动作。  
- [ ] 能说明 fail-open/fail-close 的场景。  
- [ ] 能讲和母题 Q16 的区别。

## 22. 与母题差异（对应 Q16）
### 22.1 对应母题
- Q16 RateLimiter + Grafana

### 22.2 共性能力
1. 限流算法选型。  
2. 多维配额控制。  
3. 告警监控闭环。  
4. 高可用降级策略。

### 22.3 关键差异（>=5条）
1. Q37 更偏 API 网关落地场景。  
2. Q16 更偏“限流+监控体系”母题。  
3. Q37 更强调 `Retry-After`、接口语义和租户隔离。  
4. Q16 更强调算法对比和可视化观测闭环。  
5. Q37 直接面向线上接口治理。

### 22.4 本题新增必补知识（>=5条）
1. 网关接入点与判定时机。  
2. 多维 key 组合设计。  
3. 429 响应语义规范。  
4. 干跑与灰度发布流程。  
5. fail-open/fail-close 策略。

### 22.5 面试差异话术（3条）
1. “Q16 给我通用限流框架，Q37我会落到网关接口治理细节。”  
2. “Q37 的重点是多租户接口语义，不只是算法本身。”  
3. “Q37 高分要把策略发布、回滚和误杀治理讲清楚。”
