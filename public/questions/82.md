# Q82：Design Large-Scale Graph Processing System

## 1. 题目定位
这题是大规模图处理系统设计，目标是支持 PageRank、图遍历、连通分量等批式迭代计算，并在分布式环境下保证吞吐、收敛与可恢复。

## 2. 必读元数据（先读题库）
- title: `Design Large-Scale Graph Processing System`
- tags: `图计算`、`分布式`、`PageRank`、`图遍历`、`社交网络`
- keyPoints: `图分区`、`分布式计算`、`图算法`、`迭代计算`、`内存管理`
- learningCoreId: `60`

## 3. 业务目标
给定万亿边级别图数据，提供离线或准实时图计算能力，输出排名、推荐候选、社区发现等结果，支持多租户任务提交、进度追踪和失败恢复。

## 4. 非功能目标
- 可用性目标：控制面 99.95%，计算面 99.9%。
- 吞吐目标：单集群可并发 1,000+ 作业。
- 延迟目标：中等规模（百亿边）作业在 30 分钟内完成。
- 一致性目标：作业结果可重复、可审计、可回放。

## 5. 约束与范围
- 优先做批处理与微批，不做强实时毫秒级图查询。
- 优先最终一致与可恢复，不做跨地域强一致调度。
- 优先任务级隔离，不做全局资源抢占优化到极致。

## 6. 容量估算
- 假设 2,000 亿边，平均每条边压缩后 24B，原始边存储约 4.8TB。
- 顶点属性与索引约为边数据 30%，额外 1.44TB。
- 3 副本后存储约 `(4.8 + 1.44) * 3 = 18.72TB`。
- 单次 PageRank 迭代扫描全图，若有效吞吐 120GB/min，单轮约 52 分钟，10 轮约 8.7 小时；需通过增量分区和并行度提升把单轮压到 10 分钟内。

## 7. 总体架构
```text
Client -> API Gateway -> Job Service -> Scheduler -> Worker Pool
                                  -> Metadata DB
                                  -> Object Storage(HDFS/S3)
                                  -> MQ(事件/重试)
                                  -> Metrics/Logs/Trace
```

## 8. 存储与分区设计
- 图存储：CSR/邻接表分块，按顶点范围 + 边切分。
- 分区策略：先 hash 做均衡，再按社交圈/社区做局部性优化。
- 热点处理：超级节点单独拆分并限制单 worker 承载。
- 结果存储：按 jobId + version 写入，支持回滚和比对。

## 9. 调度与执行模型
- DAG 作业拆分为 `load -> partition -> iterate -> merge -> publish`。
- Scheduler 做资源配额、优先级队列、抢占控制。
- Worker 使用心跳 + lease 机制，超时自动重派。
- 迭代作业保留 checkpoint，失败从最近检查点继续。

## 10. 一致性与幂等
- 提交作业使用 `requestId` 幂等键，重复请求返回同一 jobId。
- 阶段结果写入采用 `jobId + stage + attempt` 唯一约束。
- 事件消费采用 at-least-once，借助幂等写保证正确。
- 发布结果采用版本切换，旧版本保留用于回滚。

## 11. 故障模型
- Worker 宕机：任务 lease 过期后重试，attempt +1。
- 存储暂时不可用：作业进入 `DEGRADED`，只保 checkpoint，暂停 publish。
- 分区倾斜：触发重分区任务，限制单分区最大边数。
- 控制面故障：只读模式开放，禁止新作业提交，保障已有作业恢复。

## 12. 阈值与故障恢复路径（含RTO/RPO）
- 阈值1：`job_fail_rate_5m > 3%` 触发 P1。
- 阈值2：`scheduler_queue_lag > 120s` 持续 10 分钟触发扩容。
- 阈值3：`worker_heartbeat_loss > 5%` 触发隔离与重派。
- 阈值4：`checkpoint_delay > 15min` 触发写路径降级。
- RTO：控制面 15 分钟内恢复可提交；计算面 30 分钟内恢复执行。
- RPO：元数据 5 分钟；作业中间状态 15 分钟（依赖 checkpoint 间隔）。
- 故障恢复路径：告警触发 -> 自动隔离故障节点 -> 从最近 checkpoint 重跑 -> 对账校验 -> 版本切换恢复写流量 -> 复盘补规则。

## 13. 观测与运维
- 指标：QPS、队列积压、阶段耗时、迭代收敛率、失败重试次数。
- 日志：job 维度结构化日志，带 traceId、partitionId、attempt。
- 链路：调度到执行全链路 trace，定位慢点与失败点。
- Runbook：P1/P2 标准处置脚本，支持一键流量降级和作业冻结。

## 14. 安全与多租户
- 租户隔离：队列、命名空间、存储路径三层隔离。
- 权限：RBAC + 审批流，敏感操作双人复核。
- 数据安全：传输 TLS，加密存储，关键字段脱敏审计。

## 15. Java 关键代码（>=5段）
```java
public class JobSubmitService {
    public SubmitResult submit(SubmitCommand cmd) {
        String key = cmd.getTenantId() + ":" + cmd.getRequestId();
        if (idempotencyRepo.exists(key)) {
            return idempotencyRepo.getResult(key);
        }
        long jobId = idGenerator.nextId();
        jobRepo.insert(jobId, cmd.getTenantId(), "PENDING");
        outboxRepo.append("JOB_CREATED", jobId, cmd.getGraphVersion());
        SubmitResult result = SubmitResult.accepted(jobId);
        idempotencyRepo.save(key, result);
        return result;
    }
}
```

```java
public class PartitionPlanner {
    public List<PartitionPlan> plan(GraphStat stat, int workerCount) {
        int base = Math.max(workerCount * 4, 32);
        long maxEdgesPerPartition = Math.max(stat.totalEdges() / base, 5_000_000L);
        List<PartitionPlan> plans = new ArrayList<>();
        long cursor = 0;
        int pid = 0;
        while (cursor < stat.totalEdges()) {
            long next = Math.min(cursor + maxEdgesPerPartition, stat.totalEdges());
            plans.add(new PartitionPlan(pid++, cursor, next));
            cursor = next;
        }
        return plans;
    }
}
```

```java
public class RetryPolicy {
    public Duration nextDelay(int attempt) {
        int capped = Math.min(attempt, 6);
        long sec = (long) Math.pow(2, capped);
        long jitter = ThreadLocalRandom.current().nextLong(0, 3);
        return Duration.ofSeconds(sec + jitter);
    }

    public boolean shouldMoveToDlq(int attempt, Exception ex) {
        return attempt >= 8 || ex instanceof IllegalArgumentException;
    }
}
```

```java
public class CheckpointRecoveryService {
    public RecoveryResult recover(long jobId) {
        Optional<Checkpoint> cp = checkpointRepo.findLatest(jobId);
        if (cp.isPresent()) {
            scheduler.resumeFrom(jobId, cp.get().stage(), cp.get().offset());
            return RecoveryResult.fromCheckpoint(jobId, cp.get().version());
        }
        scheduler.restart(jobId);
        return RecoveryResult.coldStart(jobId);
    }
}
```

```java
public class PublishService {
    public PublishResult publish(long jobId, String targetAlias) {
        String candidateVersion = resultRepo.latestVersion(jobId);
        qualityGate.assertPass(jobId, candidateVersion);
        versionRepo.bindAlias(targetAlias, candidateVersion);
        auditRepo.log("PUBLISH_SUCCESS", jobId, candidateVersion);
        return PublishResult.success(jobId, candidateVersion);
    }
}
```

## 16. React JavaScript 代码（>=2段）
```jsx
import { useEffect, useRef, useState } from "react";

export default function JobStatusPanel({ jobId }) {
  const [state, setState] = useState({ status: "loading", data: null, error: "" });
  const timerRef = useRef(null);
  const stoppedRef = useRef(false);

  useEffect(() => {
    async function poll() {
      if (stoppedRef.current) return;
      setState((s) => ({ ...s, status: "loading", error: "" }));
      try {
        const res = await fetch(`/api/jobs/${jobId}/status`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        setState({ status: "done", data, error: "" });
      } catch (e) {
        setState((s) => ({ ...s, status: "error", error: String(e) }));
      } finally {
        timerRef.current = setTimeout(poll, 5000); // polling
      }
    }
    poll();
    return () => {
      stoppedRef.current = true;
      if (timerRef.current) clearTimeout(timerRef.current);
    };
  }, [jobId]);

  if (state.status === "loading") return <div>loading...</div>;
  if (state.status === "error") return <div>error: {state.error}</div>;
  return <pre>{JSON.stringify(state.data, null, 2)}</pre>;
}
```

```javascript
import { useState } from "react";

export function SubmitJobButton({ payload }) {
  const [status, setStatus] = useState("idle");
  const [error, setError] = useState("");
  const [jobId, setJobId] = useState(null);

  async function submitWithRetry() {
    setStatus("loading");
    setError("");
    const idempotencyKey = `${Date.now()}-${Math.random().toString(16).slice(2)}`; // idempotency
    for (let attempt = 1; attempt <= 3; attempt += 1) {
      try {
        const res = await fetch("/api/jobs", {
          method: "POST",
          headers: { "Content-Type": "application/json", "Idempotency-Key": idempotencyKey },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error(`submit failed: ${res.status}`);
        const data = await res.json();
        setJobId(data.jobId);
        setStatus("done");
        return;
      } catch (e) {
        if (attempt === 3) {
          setError(String(e));
          setStatus("error");
          return;
        }
        await new Promise((r) => setTimeout(r, 500 * attempt)); // retry backoff
      }
    }
  }

  return (
    <div>
      <button onClick={submitWithRetry}>Submit Job</button>
      {status === "loading" && <p>loading...</p>}
      {status === "error" && <p>error: {error}</p>}
      {status === "done" && <p>done, jobId={jobId}</p>}
    </div>
  );
}
```

## 17. 测试策略
- 单测：分区算法、状态机、重试策略、幂等提交。
- 集成：调度-执行-检查点-发布全链路。
- 压测：超大图、多租户抢占、热点分区。
- 故障注入：worker 宕机、存储超时、消息重复、元数据回退。

## 18. 丰富例子（>=10）
1. 社交网络每晚跑 PageRank，超级节点导致单分区过热，如何拆分。
2. 图遍历任务在第 7 轮失败，如何从 checkpoint 恢复而非全量重跑。
3. 租户 A 突发提交 500 作业，如何限额避免拖垮租户 B。
4. 存储短时抖动导致 publish 失败，如何进入降级并延迟发布。
5. 同一 requestId 重复提交，如何保证幂等返回同一 jobId。
6. worker 批量离线时，如何触发自动重派并控制重试风暴。
7. 分区倾斜严重时，如何重分区且保证阶段结果不丢失。
8. 迭代不收敛时，如何通过阈值自动终止并打审计标签。
9. 结果版本发布后指标异常，如何 1 分钟内回滚别名。
10. 多机房网络闪断时，如何保障元数据 RPO 不超过 5 分钟。
11. 数据团队要回放某天作业，如何按 version 精准重算。
12. 合规审计要求追踪人工发布操作，如何落地全链路审计。

## 19. 面试追问与回答
- 问：为什么不做 exactly-once？
- 答：代价高且收益有限，本题用 at-least-once + 幂等写能更稳更经济。
- 问：如何处理超级节点热点？
- 答：超级节点拆分、邻接表分桶、执行期限流三层兜底。
- 问：恢复顺序为何先控制面再计算面？
- 答：先恢复可控入口，防止故障扩大，再恢复算力更安全。

## 20. 评分结论
- 架构完整性：20/20
- 一致性与恢复：20/20
- 可观测与运维：19/20
- 工程落地代码：19/20
- 面试表达与取舍：18/20
- 总分：96/100

## 21. 复习清单
- 能解释图分区策略及倾斜治理。
- 能解释迭代计算 checkpoint 的价值与代价。
- 能说明幂等键设计和重试边界。
- 能给出 RTO/RPO 与恢复路径。
- 能说明多租户资源隔离方案。

## 22. 与母题差异
- 母题是 `learningCoreId=60`：`Design Task Management Application`，核心在任务状态流转与协作产品能力。
- 本题聚焦图计算引擎，核心难点是分区、迭代、收敛和大规模资源调度。
- 本题更强调批式计算容错与 checkpoint 恢复，不是通用任务流 UI 协作。
- 本题对存储布局和超级节点热点治理要求更高。
- 本题在结果发布上强调版本别名切换与可回滚。
- 新增必补知识1：图分区算法（hash/range/community）与数据局部性取舍。
- 新增必补知识2：PageRank/图遍历的迭代终止条件与收敛判定。
- 新增必补知识3：checkpoint 频率设计对 RPO、成本和吞吐的影响。
- 新增必补知识4：超级节点与分区倾斜治理（拆分、限流、重平衡）。
- 新增必补知识5：批处理作业幂等发布与版本化回滚机制。
