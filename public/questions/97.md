## 1. 题目元信息
- id: 97
- title: Design Coupons and Deals Platform
- tags: 优惠券、促销、发放策略、核销、防刷
- keyPoints: 优惠券生成、发放策略、核销流程、防刷机制、统计分析
- learningCoreId: 83

## 2. 业务目标与范围
- 目标：稳定支持发券、领券、核销、退款回滚、活动统计。
- 范围：B2C 电商场景，含满减券、折扣券、品类券、新人券、店铺券。
- 非目标：营销内容编辑器、广告投放系统、复杂预算归因模型。

## 3. 关键角色与核心流程
- 角色：运营、用户、商家、风控、清结算。
- 流程：建活动 -> 审核发布 -> 发券 -> 领券 -> 下单锁券 -> 支付后核销 -> 失败回滚/过期释放。

## 4. 需求拆解
- 功能：活动配置、发放策略、人群圈选、领券限制、核销规则、报表。
- 非功能：高并发、幂等、一致性、低延迟、可观测、可恢复。
- 约束：同用户限领、跨端一致、黑灰产防刷、财务可审计。

## 5. 容量预估
- 峰值领券 QPS：50k，峰值核销 QPS：20k。
- 日发券量：1e8，券实例总量：1e10（冷热分层）。
- 延迟目标：领券 P99 < 120ms，核销 P99 < 150ms。

## 6. 数据模型
- `coupon_template`：券模板（门槛、折扣、预算、生效期、适用范围）。
- `coupon_instance`：用户券实例（状态：NEW/LOCKED/USED/EXPIRED/REFUNDED）。
- `coupon_event_log`：状态流转事件（幂等键、操作者、来源、时间）。
- `promotion_rule_snapshot`：规则快照，保证核销可重放。

## 7. API 设计
- `POST /api/coupons/claim`：领券（请求含 `templateId`、`userId`、`idempotencyKey`）。
- `POST /api/coupons/lock`：下单锁券（订单维度幂等）。
- `POST /api/coupons/redeem`：支付成功核销。
- `POST /api/coupons/release`：支付失败/超时释放。
- `GET /api/coupons/user/{userId}`：查询用户券包。

## 8. 架构总览
- 接入层：API Gateway + 限流 + 鉴权。
- 业务层：发券服务、规则服务、核销服务、风控服务。
- 数据层：Redis（库存与热点状态）+ MySQL 分库分表（强一致事实）+ Kafka（事件总线）+ OLAP（统计）。
- 异步层：Outbox + 消费重试 + 死信队列 + 补偿任务。

## 9. 核心链路：发券
- 运营发布模板后写入模板库与缓存。
- 发券任务按人群分片写 Kafka。
- 消费端批量创建 `coupon_instance`，并写事件日志。
- 若预算不足，模板自动转 `PAUSED`，并告警。

## 10. 核心链路：领券与核销
- 领券：先查资格与限领，再原子扣减模板可发额度，再落库实例。
- 锁券：订单创建时将券置 `LOCKED`，写锁定 TTL。
- 核销：支付成功触发 `redeem`，状态 `LOCKED -> USED`。
- 回滚：取消/超时触发 `release`，状态 `LOCKED -> NEW`（或直接失效，按策略）。

## 11. 一致性与幂等
- 幂等键：`idempotencyKey = userId + templateId + bizType + requestId`。
- 状态机约束：仅允许合法跃迁，非法请求直接拒绝并记录审计日志。
- Outbox 事务：业务写库与消息投递最终一致。
- 去重：消费者以业务主键 + 事件版本号实现幂等消费。

## 12. 阈值、SLO与故障恢复（RTO/RPO）
- 阈值：
1. 领券成功率 >= 99.95%，低于 99.9% 持续 5 分钟触发 P1。
2. 核销成功率 >= 99.99%，低于 99.95% 持续 3 分钟触发 P1。
3. Redis 命中率 >= 95%，低于 90% 持续 10 分钟触发扩容与热点迁移。
4. Kafka 消费延迟 <= 30 秒，超过 120 秒触发流量降级。
- RTO/RPO：
1. 同城故障：RTO 10 分钟，RPO 0-30 秒（依赖 binlog + outbox 重放）。
2. 异地灾难：RTO 30 分钟，RPO <= 5 分钟（跨城异步复制）。
- 故障恢复路径：
1. 网关限流提级，关闭非核心活动。
2. 领券降级为排队受理，核销链路优先级提升。
3. 触发只读规则快照与静态兜底折扣。
4. 恢复后按事件时间回放，执行对账与补偿。

## 13. 高可用与多活
- 服务无状态部署，多 AZ 自动扩缩容。
- Redis 主从 + 哨兵；MySQL 主备 + 半同步。
- 多机房流量就近接入，核销主写单元化，跨单元只读查询。

## 14. 安全与反作弊
- 设备指纹、账号画像、IP 信誉、行为频控联合判定。
- 规则：同设备多账号、秒领、多模板异常命中触发二次验证。
- 高风险请求降级到人工/延迟发放。

## 15. Java实现片段（>=5）
```java
public final class IdempotencyKeyUtil {
    public static String buildClaimKey(long userId, long templateId, String requestId) {
        return "claim:" + userId + ":" + templateId + ":" + requestId;
    }
}
```

```java
public class CouponStateMachine {
    public boolean canTransit(String from, String to) {
        if ("NEW".equals(from) && "LOCKED".equals(to)) return true;
        if ("LOCKED".equals(from) && "USED".equals(to)) return true;
        if ("LOCKED".equals(from) && "NEW".equals(to)) return true;
        return "NEW".equals(from) && "EXPIRED".equals(to);
    }
}
```

```java
public class ClaimService {
    public ClaimResult claim(long userId, long templateId, String idemKey) {
        if (idemStore.exists(idemKey)) {
            return idemStore.getResult(idemKey);
        }
        boolean quotaOk = redisQuota.decrIfPositive(templateId);
        if (!quotaOk) {
            ClaimResult fail = ClaimResult.failed("NO_QUOTA");
            idemStore.save(idemKey, fail);
            return fail;
        }
        CouponInstance instance = repository.create(userId, templateId);
        ClaimResult ok = ClaimResult.success(instance.getCouponId());
        idemStore.save(idemKey, ok);
        return ok;
    }
}
```

```java
public class RedeemService {
    @Transactional
    public RedeemResult redeem(long couponId, String orderId) {
        CouponInstance c = repository.lockById(couponId);
        if (!"LOCKED".equals(c.getStatus())) {
            return RedeemResult.failed("INVALID_STATE");
        }
        c.setStatus("USED");
        c.setOrderId(orderId);
        repository.update(c);
        outbox.append("COUPON_REDEEMED", couponId, orderId);
        return RedeemResult.success(couponId, orderId);
    }
}
```

```java
public class RecoveryJob {
    public int replayOutbox(List<OutboxEvent> events) {
        int recovered = 0;
        for (OutboxEvent e : events) {
            boolean done = publisher.publish(e);
            if (done) {
                outbox.markDone(e.getId());
                recovered++;
            }
        }
        return recovered;
    }
}
```

## 16. React集成示例（>=2）
```jsx
import React, { useState } from "react";

export function ClaimCouponButton({ templateId, userId }) {
  const [status, setStatus] = useState("idle"); // idle/loading/done/error
  const [message, setMessage] = useState("");

  async function claimWithRetry(retries = 2) {
    setStatus("loading");
    const idemKey = `${userId}-${templateId}-${Date.now()}`;
    try {
      const res = await fetch("/api/coupons/claim", {
        method: "POST",
        headers: { "Content-Type": "application/json", "X-Idempotency-Key": idemKey },
        body: JSON.stringify({ userId, templateId, idempotencyKey: idemKey })
      });
      const data = await res.json();
      if (res.ok && data.success) {
        setStatus("done");
        setMessage("领券成功");
      } else {
        throw new Error(data.message || "claim failed");
      }
    } catch (e) {
      if (retries > 0) return claimWithRetry(retries - 1); // retry
      setStatus("error");
      setMessage("领券失败，请稍后重试");
    }
  }

  return <button onClick={() => claimWithRetry()}>{status === "loading" ? "领取中..." : message || "领取优惠券"}</button>;
}
```

```javascript
import { useEffect, useState } from "react";

export function useRedeemStatus(orderId) {
  const [status, setStatus] = useState("loading"); // loading/done/error
  const [data, setData] = useState(null);
  const [error, setError] = useState("");

  useEffect(() => {
    let active = true;
    let timer = null;

    const poll = async () => {
      try {
        const res = await fetch(`/api/coupons/redeem/status?orderId=${orderId}`);
        const json = await res.json();
        if (!active) return;
        if (res.ok && json.state === "DONE") {
          setData(json);
          setStatus("done");
          return;
        }
        timer = setTimeout(poll, 1500); // polling
      } catch (e) {
        if (!active) return;
        setError("状态查询失败，已降级展示订单原价");
        setStatus("error"); // degrade
      }
    };

    poll();
    return () => { active = false; if (timer) clearTimeout(timer); };
  }, [orderId]);

  return { status, data, error };
}
```

## 17. 监控与压测
- 监控：成功率、P95/P99、库存差异、死信堆积、重试率、风控拦截率。
- 压测：大促前做 2 倍峰值压测，验证限流、降级、补偿链路。
- 演练：每月做一次核销链路故障注入和跨城切换演练。

## 18. 丰富例子（>=10）
1. 新人首单券：注册 24 小时内可领，过期自动失效。
2. 满 200 减 30：只适用于指定类目，叠加店铺券禁用。
3. 每日 10 点限量券：按库存桶分片发放，超发自动熔断。
4. 会员等级券：银卡 95 折，金卡 9 折，铂金 85 折。
5. 节日活动券：黑五全场券，模板按地域差异定价。
6. 支付方式券：仅银行卡支付可用，退款后券按规则返还。
7. 邀请裂变券：被邀请人下单后给邀请人返券。
8. 直播间口令券：口令校验 + 设备风险评分。
9. 店铺专属券：店铺预算隔离，避免平台活动互相挤占。
10. 召回补偿券：系统故障后向受影响订单自动补券。
11. A/B 券策略：同模板不同门槛对比转化率与毛利。
12. 高风险地区券：默认人工审核后发放。

## 19. 面试追问与回答
- 问：如何防止超发？答：Redis 原子扣减 + DB 兜底校验 + 异步对账。
- 问：如何保证不重复核销？答：订单维度幂等键 + 状态机单向跃迁。
- 问：缓存失效时怎么办？答：热点预热 + 限流 + 只读快照降级。
- 问：如何审计？答：全链路事件日志可重放，支持财务对账。

## 20. 常见错误与修正
- 错误：只在应用层做幂等。修正：网关、服务、存储三层幂等。
- 错误：先发消息后落库。修正：Outbox 保证最终一致。
- 错误：忽略退款回滚。修正：明确 `USED -> REFUNDED` 补偿流程。
- 错误：无故障演练。修正：固定频率做故障注入与切换演习。

## 21. 评分与结论
- 需求完整性：20/20
- 架构合理性：20/20
- 一致性与幂等：20/20
- 高可用与容灾：19/20
- 可观测与工程化：19/20
- 总分：98/100

## 22. 与母题差异
- 母题（learningCoreId=83）更偏“电商交易与库存主链路”，本题聚焦“促销资产（券）生命周期与风控”。
- 本题新增了模板预算、发放策略、核销状态机、活动审计、反作弊组合策略。
- 新增必补知识：
1. 优惠券规则引擎（门槛、叠加、互斥、优先级）。
2. 发券预算控制与分桶配额算法。
3. 券实例状态机设计与可回放事件建模。
4. 营销反作弊（设备指纹、行为图谱、风险分层）。
5. 营销活动故障降级与补券补偿机制。
6. 营销核销与财务清结算对账口径统一。
