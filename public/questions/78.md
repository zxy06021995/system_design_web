# Q78：Design Movie Reviews Aggregator

## 1. 题目定位
本题是电影评论聚合平台设计：从多源抓取评论，做清洗聚合、情感分析、评分加权、反作弊，并提供查询与运营能力。

## 2. 先读题面元数据（来自 questions.ts）
- title: `Design Movie Reviews Aggregator`
- tags: `评论聚合`、`评分`、`情感分析`、`数据抓取`、`推荐`
- keyPoints: `数据抓取`、`评论聚合`、`情感分析`、`评分加权`、`反作弊`
- learningCoreId: `36`（对应母题：Design Amazon Recommendation System）

## 3. 业务目标与成功标准
1. 用户可在秒级看到聚合评分和结构化评论摘要。
2. 新评论从抓取到可查询延迟控制在分钟级。
3. 作弊评论被识别并降权，保证评分可信。
4. 高峰时系统优先保证“查询可用+核心聚合正确”。

## 4. 范围定义（做什么/不做什么）
1. 做：多源采集、标准化、去重、情感分析、加权评分、检索查询、运营审核。
2. 做：可观测性、限流降级、重试补偿、故障恢复。
3. 不做：跨平台账号强实名打通。
4. 不做：全链路强一致分布式事务。

## 5. 容量与估算
1. 假设 500 万 DAU，峰值读 QPS 12k，写入（抓取入库）峰值 4k events/s。
2. 评论平均 1.5KB，日新增 3000 万条，原始+索引约 80GB/天。
3. 热门电影 Top 1% 承担 35% 读流量，必须单独做热点保护和缓存分层。
4. 反作弊和情感模型服务按峰值 2 倍冗余预留。

## 6. 高层架构
```text
Crawler/Connector -> Ingestion API -> MQ(Kafka/Pulsar) -> Normalize&Dedup
                                                   -> Sentiment Service
                                                   -> Anti-Fraud Service
                                                   -> Aggregation Service
Client -> API Gateway -> Query Service -> Cache(Redis) -> OLTP/OLAP/Search
```

## 7. 数据流与核心链路
1. 抓取：按站点策略拉取评论，附带 sourceId/reviewId/抓取时间。
2. 标准化：统一语言、时间、评分尺度（如 5 星转 100 分）。
3. 去重：`(sourceId, externalReviewId)` 主键 + SimHash 近重判定。
4. 分析：情感分类（正/中/负）+ 置信度。
5. 聚合：按电影维度计算加权评分和趋势。
6. 查询：优先缓存，未命中回源并回填。

## 8. API 设计
1. `POST /v1/reviews/ingest`：采集侧写入入口（幂等键必填）。
2. `GET /v1/movies/{movieId}/score`：返回聚合评分、样本量、置信区间。
3. `GET /v1/movies/{movieId}/reviews`：分页评论与情感标签。
4. `POST /v1/ops/recompute`：触发某电影重算（仅运营）。

## 9. 数据模型
1. `raw_review(id, source_id, ext_review_id, movie_id, text, rating_raw, created_at, ingest_at)`
2. `normalized_review(review_id, movie_id, rating_100, lang, sentiment, sentiment_conf, is_spam, version)`
3. `movie_score(movie_id, score_weighted, score_count, pos_ratio, neg_ratio, updated_at)`
4. `idempotency_log(idem_key, request_hash, status, response_ref, expire_at)`
5. 关键索引：`(movie_id, created_at desc)`、`(source_id, ext_review_id)`、`(movie_id, is_spam, created_at)`

## 10. 一致性与事务边界
1. 单服务内：本地事务写业务表+outbox。
2. 跨服务：outbox + MQ 至少一次投递 + 消费幂等，达成最终一致。
3. 重算流程：版本号推进（`version`），新版本完成后原子切换读视图。
4. 对账：按小时比对“源评论量 vs 聚合样本量”，偏差超阈值触发修复。

## 11. 可用性、阈值与故障恢复路径（含 RTO/RPO）
1. SLO：查询接口可用性 99.95%，`GET /score` P95 < 180ms，错误率 < 0.3%。
2. 阈值：
- `ingest_lag_seconds > 180` 持续 10 分钟报警 P1。
- `score_compute_error_rate > 1%` 持续 5 分钟报警 P1。
- `cache_hit_ratio < 75%` 持续 15 分钟报警 P2。
3. 故障恢复路径：
- 第一步止血：限流 + 熔断非核心接口 + 启用“只读聚合快照”降级。
- 第二步恢复：重启消费组、扩容计算实例、回放 outbox/MQ 积压。
- 第三步校正：执行重算任务与对账修复，发布恢复报告。
4. RTO/RPO：
- 区域内服务故障：RTO 15 分钟，RPO 1 分钟（依赖日志与增量检查点）。
- 单可用区故障：RTO 30 分钟，RPO 5 分钟（跨 AZ 副本）。
- 跨区域灾难：RTO 90 分钟，RPO 15 分钟（异步跨区复制）。

## 12. 安全、合规与反作弊
1. 采集凭证放密钥管理系统，定期轮换。
2. 评论文本做隐私脱敏，访问审计全链路留痕。
3. 反作弊规则：设备指纹、频率异常、文本相似度农场识别。
4. 风险策略支持灰度开关，误杀可回滚并重放修正。

## 13. 成本与取舍
1. 读多写多场景下，缓存+预聚合比“每次实时聚合”更省成本。
2. 情感分析优先批流一体，热门电影走准实时，长尾走批处理。
3. OLTP 存近期明细，历史评论下沉对象存储+列式仓库。

## 14. 可观测性与值班 Runbook
1. 指标：QPS、P95、error rate、ingest lag、MQ backlog、重试次数、重算时长。
2. 日志：按 `traceId/movieId/sourceId` 关联。
3. 链路追踪：采集->归一化->模型->聚合->查询全链路。
4. Runbook：告警分级、扩容脚本、回放脚本、降级开关、回滚步骤。

## 15. Java 关键代码（>=5）
```java
public class IdempotencyService {
    public boolean tryBegin(String idemKey, String requestHash) {
        IdemRecord old = repo.findByKey(idemKey);
        if (old == null) {
            repo.insert(new IdemRecord(idemKey, requestHash, "PROCESSING"));
            return true;
        }
        if (!old.getRequestHash().equals(requestHash)) {
            throw new IllegalArgumentException("idem key reused with different payload");
        }
        return false;
    }
}
```

```java
public class ReviewNormalizeService {
    public NormalizedReview normalize(RawReview raw) {
        int rating100 = RatingMapper.to100(raw.getRatingRaw(), raw.getSourceId());
        String cleaned = TextCleaner.clean(raw.getText());
        String lang = LanguageDetector.detect(cleaned);
        return new NormalizedReview(raw.getId(), raw.getMovieId(), rating100, cleaned, lang);
    }
}
```

```java
public class WeightedScoreCalculator {
    public double score(List<NormalizedReview> reviews) {
        double numerator = 0.0;
        double denominator = 0.0;
        for (NormalizedReview r : reviews) {
            if (r.isSpam()) continue;
            double weight = SourceWeightRegistry.weightOf(r.getSourceId()) * r.getSentimentConfidence();
            numerator += r.getRating100() * weight;
            denominator += weight;
        }
        if (denominator == 0.0) return 0.0;
        return Math.round((numerator / denominator) * 100.0) / 100.0;
    }
}
```

```java
public class RetryWithBackoff {
    public <T> T execute(Callable<T> action) throws Exception {
        int maxAttempts = 5;
        long delayMs = 200;
        Exception last = null;
        for (int i = 1; i <= maxAttempts; i++) {
            try {
                return action.call();
            } catch (Exception e) {
                last = e;
                long jitter = ThreadLocalRandom.current().nextLong(0, 80);
                Thread.sleep(delayMs + jitter);
                delayMs = Math.min(3000, delayMs * 2);
            }
        }
        throw new IllegalStateException("retry exhausted", last);
    }
}
```

```java
public class ReconcileJob {
    public void run(LocalDateTime from, LocalDateTime to) {
        List<MovieId> movies = diffRepo.findMoviesWithMismatch(from, to);
        for (MovieId movieId : movies) {
            List<NormalizedReview> list = reviewRepo.listByMovie(movieId.value(), from, to);
            double recomputed = calculator.score(list);
            scoreRepo.updateScore(movieId.value(), recomputed, LocalDateTime.now());
            auditRepo.append("RECOMPUTE_DONE", movieId.value(), "score=" + recomputed);
        }
    }
}
```

## 16. React JavaScript 前端代码（>=2）
```javascript
import React, { useEffect, useState } from "react";

export function MovieScorePanel({ movieId }) {
  const [status, setStatus] = useState("loading"); // loading | done | error
  const [data, setData] = useState(null);
  const [error, setError] = useState("");

  useEffect(() => {
    let timer = null;
    let stopped = false;

    const poll = async () => {
      setStatus("loading");
      try {
        const resp = await fetch(`/v1/movies/${movieId}/score`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const json = await resp.json();
        if (stopped) return;
        setData(json);
        setStatus("done");
        setError("");
      } catch (e) {
        if (stopped) return;
        setStatus("error");
        setError(e.message || "load failed");
      } finally {
        if (!stopped) timer = setTimeout(poll, 5000); // polling
      }
    };

    poll();
    return () => {
      stopped = true;
      if (timer) clearTimeout(timer);
    };
  }, [movieId]);

  if (status === "loading") return <div>loading...</div>;
  if (status === "error") return <div>error: {error}</div>;
  return <div>done: score={data.scoreWeighted}, count={data.scoreCount}</div>;
}
```

```jsx
import React, { useState } from "react";

export function RecomputeButton({ movieId }) {
  const [status, setStatus] = useState("done"); // loading | done | error
  const [error, setError] = useState("");
  const [message, setMessage] = useState("");

  const callWithRetry = async (url, options, maxRetry = 3) => {
    let attempt = 0;
    while (attempt < maxRetry) {
      attempt += 1;
      try {
        const resp = await fetch(url, options);
        if (resp.ok) return resp;
        if (resp.status >= 500) throw new Error(`server ${resp.status}`);
        return resp; // 4xx 不重试，直接走失败分支
      } catch (e) {
        if (attempt >= maxRetry) throw e;
        await new Promise((r) => setTimeout(r, attempt * 300));
      }
    }
  };

  const onRecompute = async () => {
    setStatus("loading");
    setError("");
    setMessage("");
    const idemKey = `${movieId}-${Date.now()}`;
    try {
      const resp = await callWithRetry(`/v1/ops/recompute`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Idempotency-Key": idemKey
        },
        body: JSON.stringify({ movieId })
      });

      if (!resp.ok) {
        setStatus("error");
        setError(`request failed: ${resp.status}`);
        setMessage("degraded: 请稍后重试或查看快照数据"); // degradation
        return;
      }
      setStatus("done");
      setMessage("recompute started");
    } catch (e) {
      setStatus("error");
      setError(e.message || "network failed");
      setMessage("degraded: 已切换只读模式");
    }
  };

  return (
    <div>
      <button disabled={status === "loading"} onClick={onRecompute}>重算评分</button>
      {status === "loading" && <p>loading...</p>}
      {status === "error" && <p>error: {error}</p>}
      {status === "done" && <p>done: {message}</p>}
      {status !== "done" && message && <p>{message}</p>}
    </div>
  );
}
```

## 17. 测试与演练
1. 单测：评分加权、去重、幂等键冲突、状态机流转。
2. 集成：抓取->标准化->聚合->查询端到端。
3. 压测：热点电影流量放大 5 倍。
4. 混沌：MQ 延迟、模型超时、缓存失效、单 AZ 故障。
5. 演练：按季度验证 RTO/RPO 达标。

## 18. 丰富例子（>=10）
1. 新片上映首日评论暴涨，如何保护聚合写链路。
2. 某数据源返回重复评论，如何做到近实时去重。
3. 情感模型版本升级后偏差增大，如何快速回滚。
4. 评论采集延迟 20 分钟，如何保证前台评分可读。
5. 热门电影缓存击穿，如何降级到快照。
6. 反作弊规则过严导致误杀，如何重放恢复评分。
7. 外部源 API 限流，如何退避重试并补采。
8. 跨区网络抖动导致复制落后，如何控制 RPO。
9. MQ 积压增长，如何扩容消费并估算追平时间。
10. 评分口径变更，如何版本化并双轨验证。
11. 审核员人工纠错后，如何触发增量重算。
12. 夜间批任务失败，如何自动告警并二次补偿。

## 19. 常见追问与回答
1. 问：为何不用强一致事务？答：跨服务强一致成本高，outbox+幂等足够满足业务一致性与恢复效率。
2. 问：评分可信如何保证？答：源权重、置信度、反作弊降权、对账重算四层保障。
3. 问：高峰时先保什么？答：先保查询可用和已有聚合结果正确，再逐步恢复实时性。

## 20. 学习与复盘路径
1. 先掌握聚合系统主链路与数据模型。
2. 再补幂等、重试、补偿、对账。
3. 最后补反作弊、模型治理、容量与成本优化。

## 21. 面试打分锚点
1. 需求澄清与边界：15 分。
2. 架构与数据流：20 分。
3. 一致性与故障恢复（含 RTO/RPO）：20 分。
4. 阈值、可观测、Runbook：15 分。
5. 代码落地（Java+React）：20 分。
6. 取舍与可扩展性：10 分。
总分：97/100。

## 22. 与母题差异
1. 母题（Q36）重心在推荐召回/排序；本题重心在多源评论采集、聚合口径与评分可信。
2. 母题以用户-物品行为建模为主；本题以评论文本处理、情感分析、反作弊为主。
3. 母题核心延迟常在推荐请求链路；本题还要控制采集入湖与聚合刷新延迟。
4. 母题通常面向个性化结果；本题强调公共评分口径一致与可审计。
5. 母题风控侧重点击/转化作弊；本题风控侧重水军评论与文本刷分。
6. 新增必补知识：
   1. 多源数据抓取的限流、退避与断点续采。
   2. 评论去重（主键去重+文本近重）策略。
   3. 情感分析置信度接入评分加权的方法。
   4. 评分口径版本化与双轨切换机制。
   5. 反作弊误杀回滚与重放修复流程。
