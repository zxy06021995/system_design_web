# Q25 推特搜索系统（Twitter Search）- 面试高分版

## 1. 三句话题目本质
1. 这是一个“海量短文本近实时检索”系统，核心目标是新推文尽快可搜到、热门查询稳定返回。  
2. 最大难点不是“能搜”，而是“高并发下还能保持延迟、相关性、可用性和删除一致性”。  
3. 面试回答要抓三条链路：写入建索引、查询召回排序、故障降级恢复。

## 2. 真实场景故事（问题-方案-结果）
- 问题：突发热点时，某关键词查询流量 20 倍上涨，搜索集群出现 P99 抖动，且新推文 1 分钟后才可检索。  
- 方案：把索引从批量刷新改成流式微批刷新；查询端增加热点缓存、分片限流、慢分片熔断；删除走 tombstone 先过滤再异步清理。  
- 结果：索引可见延迟从 60s 降到 8s，查询 P95 稳定在 140ms 内，热点故障从全站扩散变为局部可控。

## 3. 术语白话表（>=10）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| 倒排索引 | 词到文档ID列表的映射 | 搜索速度快的基础结构 |
| NRT | Near Real Time，近实时可搜索 | 秒级可见，不是强实时 |
| Segment | 索引分段文件 | 写入先写小段再合并 |
| Refresh | 让新段对查询可见 | 刷新越快越实时但越耗资源 |
| Merge | 段合并降低查询放大 | 合并会吃IO，要限速 |
| Recall | 先找候选文档 | 先保证“找得到” |
| Ranking | 对候选打分排序 | 决定结果质量 |
| Tombstone | 删除墓碑标记 | 先隐藏后清理 |
| Query Rewrite | 查询改写（同义词/纠错） | 提升召回和体验 |
| Hot Key | 热门查询词 | 需要缓存和隔离保护 |
| Fan-out Query | 查询打到多个分片 | 聚合层要处理超时和不一致 |
| Click Signal | 点击行为信号 | 用于排序质量优化 |

## 4. 需求澄清（功能/非功能/不做/SLO）
### 4.1 功能需求
1. 支持关键词搜索、语言/时间/作者筛选。  
2. 支持建议词、热门词、结果高亮。  
3. 支持删除后不可见、封禁内容不可见。  
4. 支持运营触发重建、回滚索引版本。

### 4.2 非功能需求
1. 查询高可用，热点时不雪崩。  
2. 索引秒级可见（NRT）。  
3. 查询延迟可控，排序可迭代。  
4. 支持分片扩缩容与在线迁移。

### 4.3 不做范围
1. 不做网页爬虫（这属于 Q32 全链路）。  
2. 不做广告竞价。  
3. 不做LLM问答检索融合。

### 4.4 SLO/SLA
1. 查询延迟：P95 < 180ms，P99 < 350ms。  
2. 索引可见延迟：P95 < 10s。  
3. 可用性：>= 99.95%。  
4. 删除生效：P95 < 15s。

## 5. 容量估算（数字推导）
1. 假设日新增推文 `6e8`，平均文本 200B，日文本量约 `120GB`。  
2. 倒排索引通常是原文 2~4 倍，按 3 倍估算，日索引增量约 `360GB`。  
3. 峰值查询 `200k QPS`，其中热点词占 35%。  
4. 若每次查询 fan-out 到 24 分片，网关每秒内部请求约 `4.8M rps`，必须缓存+超时截断。  
5. 删除峰值 `2k/s`，需 tombstone 索引在秒级传播。

## 6. 架构设计（简版 + 完整版）
### 6.1 简版
```text
Tweet Ingest -> Index Pipeline -> Search Shards -> Query Gateway -> Client
```

### 6.2 完整版
```text
Producer(Tweet/Update/Delete)
  -> Kafka
  -> Tokenize/Normalize Service
  -> Index Writer (WAL + Segment)
  -> Refresh Coordinator
  -> Search Cluster (Primary/Replica, multi-shard)

Client
  -> API Gateway
  -> Query Rewrite + ACL Filter
  -> Fan-out Search
  -> Ranker (text + freshness + engagement)
  -> Aggregator/De-dup/Highlight
  -> Cache (hot query/result page)

Ops
  -> Metrics/Trace/Logs
  -> Reindex Controller
  -> Version Rollback
```

## 7. API设计（请求/响应/错误码/幂等）
### 7.1 查询接口
- `GET /api/v1/search/tweets?q=earthquake&lang=en&from=2026-02-01&cursor=abc`

响应示例：
```json
{
  "requestId": "req_25_1001",
  "tookMs": 92,
  "partial": false,
  "items": [
    {"tweetId": "t_1", "score": 18.2, "snippet": "..." }
  ],
  "nextCursor": "c_2"
}
```

### 7.2 删除同步接口
- `POST /api/v1/search/documents/delete`
- Header: `Idempotency-Key: del-{tweetId}-{ts}`

### 7.3 重建接口
- `POST /api/v1/search/reindex`
- 错误码：`SHARD_TIMEOUT`、`INDEX_LAG_HIGH`、`ACL_DENIED`、`RATE_LIMITED`

## 8. 数据模型（实体/索引/分片）
1. `tweet_doc(tweet_id, author_id, lang, text, created_at, visibility)`  
2. `inv_index(term, shard_id, posting_ptr, df)`  
3. `doc_stat(tweet_id, len, like_cnt, reply_cnt, retweet_cnt)`  
4. `delete_tombstone(tweet_id, deleted_at, source)`  
5. `query_cache(cache_key, payload, expire_at)`  
6. 分片键：`hash(tweet_id) % N`；查询层并发 fan-out 聚合。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常链路
发推事件 -> Kafka -> 分词标准化 -> 写入段 -> refresh -> 查询可见。

### 9.2 高峰链路
热点词突增 -> 网关命中热点缓存 -> 未命中走分片查询 -> 慢分片超时截断并返回 `partial=true`。

### 9.3 故障恢复链路
某分片不可用 -> 熔断该分片 -> 走副本/降级结果 -> 异步修复 -> 恢复后回切。

## 10. 一致性与事务边界
1. 搜索结果是最终一致，不做跨分片强一致。  
2. 删除采用 tombstone 优先过滤，保证“先不可见，再物理清理”。  
3. 写入链路采用 WAL + 重放，避免索引丢失。  
4. 重试必须幂等（按 tweet_id + operation_id）。

## 11. 可用性与容错（含RTO/RPO）
1. 每分片主从副本，查询优先读副本，主故障自动摘除。  
2. 网关支持慢分片超时、部分结果返回、熔断恢复。  
3. 高峰开启 query admission control（准入限流）。  
4. RTO 15 分钟，RPO 5 分钟（依赖事件重放）。

## 12. 可观测性（指标 + 阈值 + 动作）
核心指标：
- `search_p95_ms`
- `search_p99_ms`
- `index_visible_lag_sec`
- `shard_timeout_rate`
- `delete_visibility_lag_sec`
- `cache_hit_ratio`

告警阈值与动作：
1. `search_p95_ms > 220ms` 持续 10 分钟 -> P1，执行热点限流+缓存扩容。  
2. `index_visible_lag_sec > 20` 持续 5 分钟 -> P1，降 refresh 间隔并扩写入节点。  
3. `shard_timeout_rate > 2%` 持续 5 分钟 -> P1，触发分片隔离和副本切换。  
4. `delete_visibility_lag_sec > 30` -> P1，优先处理删除队列。

## 13. 安全与合规
1. API 鉴权 + 细粒度 ACL（私密推文不可检索）。  
2. 管理接口（重建/回滚）必须 RBAC + 审计日志。  
3. 敏感词与违规内容下线联动搜索屏蔽。  
4. 合规数据保留与删除可追踪。

## 14. 成本与取舍
1. 更快 refresh 提升实时性但显著增加 CPU/IO 成本。  
2. 更多副本提升稳定性但成本近似线性上升。  
3. 强排序模型提升相关性但会增加延迟。  
4. 热词缓存成本低但存在短暂陈旧结果。

## 15. Java关键代码（>=5段）
### 15.1 写入幂等与WAL
```java
public class IndexCommandService {
    public void indexTweet(IndexEvent e) {
        String idemKey = "index:" + e.tweetId() + ":" + e.eventId();
        if (idemRepo.exists(idemKey)) return;
        wal.append(e);
        segmentWriter.write(e);
        refreshQueue.offer(e.shardId());
        idemRepo.save(idemKey);
    }
}
```

### 15.2 查询召回（分片并发）
```java
public class RecallService {
    public List<Long> recall(List<String> terms, int topK) {
        Set<Long> merged = new LinkedHashSet<>();
        for (String term : terms) {
            List<Long> posting = postingRepo.readTop(term, 5000);
            for (Long id : posting) {
                merged.add(id);
                if (merged.size() >= topK * 20) break;
            }
        }
        return new ArrayList<>(merged);
    }
}
```

### 15.3 排序打分（文本+新鲜度+互动）
```java
public class Ranker {
    public double score(double bm25, long ageSec, long likes, long retweets) {
        double freshness = 1.0 / (1.0 + ageSec / 3600.0);
        double engagement = Math.log1p(likes) * 0.7 + Math.log1p(retweets) * 1.2;
        return bm25 * 0.65 + freshness * 0.20 + engagement * 0.15;
    }
}
```

### 15.4 删除墓碑过滤
```java
public class VisibilityFilter {
    public boolean visible(long tweetId) {
        Tombstone t = tombstoneRepo.find(tweetId);
        return t == null;
    }
}
```

### 15.5 慢分片重试、退避与熔断
```java
public class ShardGuard {
    public SearchResponse callShard(String shard, Query q) {
        int maxRetry = 2;
        long delayMs = 20;
        for (int i = 0; i <= maxRetry; i++) {
            try {
                return shardClient.search(shard, q, 80); // 80ms shard timeout
            } catch (TimeoutException ex) {
                if (i == maxRetry) {
                    circuitBreaker.markFailure(shard);
                    return SearchResponse.partial(shard);
                }
                sleep(delayMs);
                delayMs *= 2; // 指数退避
            }
        }
        return SearchResponse.partial(shard);
    }
    private void sleep(long ms) {
        try { Thread.sleep(ms); } catch (InterruptedException ignored) {}
    }
}
```

## 16. 前端功能代码（React JS >=2段，含API协作）
### 16.1 搜索API协作模块（查询、分页、错误处理）
```javascript
export async function searchTweets({ q, cursor = "" }) {
  const state = { loading: true, error: "", items: [], nextCursor: "" };
  try {
    const url = `/api/v1/search/tweets?q=${encodeURIComponent(q)}&cursor=${encodeURIComponent(cursor)}`;
    const resp = await fetch(url, { method: "GET" });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    state.items = data.items || [];
    state.nextCursor = data.nextCursor || "";
  } catch (e) {
    state.error = `查询失败：${String(e.message || e)}`;
  } finally {
    state.loading = false;
  }
  return state;
}
```

### 16.2 重建任务协作模块（幂等、轮询、失败分支）
```javascript
export async function triggerReindex() {
  const idem = `reindex-${Date.now()}`;
  const result = { ok: false, jobId: "", error: "" };
  try {
    const resp = await fetch("/api/v1/search/reindex", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Idempotency-Key": idem
      },
      body: JSON.stringify({ reason: "ops_manual" })
    });
    if (!resp.ok) throw new Error(`HTTP_${resp.status}`);
    const data = await resp.json();
    result.ok = true;
    result.jobId = data.jobId;
  } catch (e) {
    result.error = `触发失败：${String(e.message || e)}`;
  }
  return result;
}

export async function pollReindex(jobId) {
  try {
    const r = await fetch(`/api/v1/search/reindex/${jobId}`);
    if (!r.ok) throw new Error(`HTTP_${r.status}`);
    const d = await r.json();
    return { status: d.status, done: d.status === "SUCCESS" || d.status === "FAILED", error: "" };
  } catch (e) {
    return { status: "UNKNOWN", done: false, error: `轮询失败：${String(e.message || e)}` };
  }
}
```

## 17. 测试策略
1. 单测：分词、召回、排序函数、tombstone过滤。  
2. 集成：写入->可见、删除->不可见、重建->回滚。  
3. 压测：热点词、长尾词、分页深翻。  
4. 故障注入：分片超时、Kafka 延迟、索引节点重启。  
5. 回归：排序质量（NDCG@10）、空结果率变化。

## 18. 丰富例子（>=10）
1. 热点事件下关键词突增，如何防止 query fan-out 打爆分片。  
2. 新推文为什么 30 秒后还搜不到。  
3. 删除推文后用户还能搜到旧缓存结果如何处理。  
4. 多语言分词导致召回下降如何快速止损。  
5. 某分片慢 5 倍引发整体 P99 抖动。  
6. 排序模型更新后点击率下降如何回滚。  
7. 运营紧急要求全量重建如何保证在线可用。  
8. 缓存命中率突然降到 10% 的排查路径。  
9. 索引合并导致写入抖动如何限速。  
10. `partial=true` 结果如何向客户端解释。  
11. ACL 误配导致私密推文可搜的应急措施。  
12. 高亮逻辑耗时过高导致响应慢的优化方法。

## 19. 面试追问 + 可复述回答
1. 为什么删除不用强一致事务？  
可复述：搜索是读取优化系统，删除先 tombstone 过滤保证用户不可见，再异步清理，兼顾时效与吞吐。  

2. 热点词风暴怎么扛？  
可复述：先热点缓存，再查询准入限流，最后慢分片熔断+部分结果返回，防止全局雪崩。  

3. 如何平衡实时性和成本？  
可复述：按业务窗口调整 refresh 策略，热点时提高实时性，平峰时降低刷新频率节省资源。

## 20. 新手学习路线
1. 先学倒排索引和分词。  
2. 再学搜索召回与排序。  
3. 再理解 NRT 写入和段合并。  
4. 最后学热点治理、熔断降级、质量评估。

## 21. 上场前Checklist
- [ ] 1分钟讲清“写入到可搜”的链路。  
- [ ] 说清 tombstone 删除一致性边界。  
- [ ] 给出至少3个监控阈值和动作。  
- [ ] 解释热点词保护策略。  
- [ ] 能说出与 Q32 的差异。

## 22. 与母题差异（对应 Q32）
### 22.1 对应母题
- Q32 Design Google Search Engine

### 22.2 共性能力（最多5条）
1. 倒排索引与分片检索。  
2. 查询召回和排序。  
3. 索引更新与重建。  
4. 缓存和高并发治理。  
5. 可观测与故障恢复。

### 22.3 关键差异（>=5条）
1. Q25 聚焦“推文短文本+NRT”，Q32 是“爬虫到排序全链路”。  
2. Q25 更强调删除可见性和内容合规联动。  
3. Q25 排序更依赖社交互动信号（转发、点赞、时效）。  
4. Q32 更关注网页抓取、链接分析、站点质量。  
5. Q25 的热点风暴更频繁，降级策略更重要。

### 22.4 本题新增必补知识（>=5条）
1. 短文本分词与 query rewrite。  
2. 秒级索引可见（NRT）策略。  
3. Tombstone 删除可见性治理。  
4. 社交信号排序融合。  
5. 热词缓存与分片熔断。

### 22.5 面试差异话术（3条）
1. “Q32 讲搜索全栈，Q25 我会深挖实时社交搜索的索引和查询稳定性。”  
2. “Q25 的关键不是爬虫，而是 NRT 与热点流量治理。”  
3. “Q25 必须把删除可见性和内容下线联动讲透，这是母题里不会细讲的点。”
