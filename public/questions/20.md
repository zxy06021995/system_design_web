# Q20 Bigtable - 大规模结构化数据存储（高频）

## 1. 三句话题目本质
1. Bigtable 是“海量稀疏结构化数据”的分布式存储系统。  
2. 核心是 LSM 写路径、按行键有序存储、列族模型和 compaction。  
3. 面试要讲清：为什么写快、如何控读放大、怎么做分片与容灾。  

## 2. 一个真实场景故事
你要存储 IoT 设备的时序状态，每天新增 50 亿条记录。传统关系库写入吃不消，查询热点也明显。换成 Bigtable 风格后：  
1. 写入先落 MemTable + WAL，顺序刷盘。  
2. 定期 flush 成 SSTable。  
3. 多层 compaction 控制读放大。  
最终写入吞吐提升，查询延迟稳定在目标范围。  

## 3. 术语白话表（新手可懂）
1. Row Key：行键，决定数据物理邻近性。  
2. Column Family：列族，相关列放一起。  
3. Cell：最小单元（行键+列+时间戳）。  
4. MemTable：内存写缓冲。  
5. WAL：预写日志，防崩溃丢数据。  
6. SSTable：不可变有序文件。  
7. Compaction：合并文件减少读放大。  
8. Tablet：分片单元。  
9. Bloom Filter：快速判断键是否可能存在。  
10. Read Amplification：读放大。  
11. Write Amplification：写放大。  
12. Tombstone：删除标记。  

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持高吞吐写入。  
2. 支持按 row key 范围读取。  
3. 支持多版本（按时间戳）。  
4. 支持 TTL 和删除。  
5. 支持在线分片与迁移。  

### 4.2 非功能需求
1. 可横向扩展。  
2. 高可用与故障自愈。  
3. 写入持久性强。  
4. 查询延迟可控。  

### 4.3 不做范围
1. 不做强事务 SQL。  
2. 不做复杂多表 Join。  
3. 不做跨行强一致事务。  

### 4.4 SLO/SLA
1. 写入 P95 < 20ms。  
2. 单行读取 P95 < 30ms。  
3. 集群可用性 >= 99.95%。  

## 5. 容量估算（数字推导）
假设日写 50 亿条，每条平均 200B：  
1. 日原始写入约 1TB。  
2. 3 副本后物理约 3TB/天。  
3. WAL + compaction 额外写放大按 3 倍，磁盘吞吐需按 9TB/天预算。  
4. 一年冷热分层后需 PB 级存储。  
5. Tablet 数量按热点与容量双维度动态拆分。  

## 6. 架构设计（简版+完整版）
### 6.1 简版
`Client -> Tablet Server -> MemTable/WAL -> SSTable -> Compaction`

### 6.2 完整版
1. Master：tablet 分配、迁移、负载均衡。  
2. Tablet Server：处理读写请求。  
3. WAL Service：顺序日志持久化。  
4. MemTable：内存写缓存。  
5. SSTable Store：不可变文件层。  
6. Compaction Worker：后台合并与清理 tombstone。  
7. Block Cache：热点数据块缓存。  
8. Metadata Service：schema、tablet 路由、健康状态。  

## 7. API 设计（请求/响应/错误码/幂等）
1. `PUT /v1/bigtable/{table}/row/{rowKey}`  
2. `GET /v1/bigtable/{table}/row/{rowKey}`  
3. `GET /v1/bigtable/{table}/scan?start=&end=&limit=`  
4. `DELETE /v1/bigtable/{table}/row/{rowKey}`  

写入请求示例：
```json
{
  "columnFamily": "metrics",
  "columns": {"temp":"36.8","hum":"55"},
  "timestamp": 1771920000,
  "idempotencyKey": "put-dev1001-1771920000"
}
```

错误码：`409_TABLET_MOVING`、`503_COMPACTION_BACKLOG`、`507_DISK_PRESSURE`。  

## 8. 数据模型（实体、索引、分片分区）
1. `table_schema`：表、列族、版本策略、TTL。  
2. `tablet_meta`：range、server、状态。  
3. `sstable_meta`：level、file_id、min_key、max_key。  
4. `wal_segment`：segment_id、start_lsn、end_lsn。  
5. `compaction_task`：输入文件、输出文件、状态。  
6. 分区：按 row key 范围切 tablet。  

## 9. 核心流程（正常/高峰/故障恢复）
1. 正常写：WAL 先落盘 -> 写 MemTable -> ack -> 后台 flush。  
2. 高峰写：MemTable 快速轮转 + 写队列回压 + 延迟低优先级 compaction。  
3. 故障恢复：节点崩溃 -> 重放 WAL -> 重建 MemTable -> 恢复服务。  

## 10. 一致性与事务边界
1. 单行读写可强一致（同 row key）。  
2. 跨行操作不保证强一致事务。  
3. 删除采用 tombstone，最终由 compaction 清理。  
4. 读路径需处理多版本与覆盖关系。  

## 11. 可用性与容错
1. Tablet 副本跨节点分布。  
2. Master 故障自动选主。  
3. 磁盘压力高时触发写回压保护。  
4. 热点 tablet 自动拆分迁移。  
5. RTO 20 分钟，RPO 1 分钟。  

## 12. 可观测性（指标+阈值+处置）
关键指标：  
1. `write_p95_ms`  
2. `read_p95_ms`  
3. `compaction_backlog_files`  
4. `wal_replay_lag_sec`  
5. `tablet_hotspot_ratio`  

告警阈值：  
1. 写 P95 > 40ms（10分钟）-> P1。  
2. compaction backlog > 5000 文件（15分钟）-> P1。  
3. 热点 tablet 占比 > 20%（10分钟）-> P2。  
4. WAL 重放延迟 > 120s（10分钟）-> P1。  

处置：扩容 tablet server -> 限流写入 -> 手动触发优先 compaction。  

## 13. 安全与合规
1. 表级/列族级 ACL。  
2. 传输加密 + 磁盘加密。  
3. 审计访问与变更。  
4. TTL 与数据删除策略合规。  
5. 备份与恢复演练。  

## 14. 成本与取舍
1. 激进 compaction 降读放大但写放大和 IO 成本上升。  
2. 大 block 提高吞吐但随机读不友好。  
3. 副本多更安全但存储成本高。  
4. 热点拆分能提性能但管理复杂度增加。  

## 15. Java 关键代码（贴题难点，充分细节）
### 15.1 写入 WAL + MemTable
```java
public class WritePath {
    public void put(PutRequest req, Wal wal, MemTable mem) {
        wal.append(req.rowKey(), req.columnFamily(), req.columns(), req.timestamp());
        mem.upsert(req.rowKey(), req.columnFamily(), req.columns(), req.timestamp());
    }
}
```

### 15.2 MemTable Flush
```java
public class FlushService {
    public SStableFile flush(MemTable mem, SStableWriter writer) {
        List<RowEntry> sorted = mem.dumpSorted();
        return writer.write(sorted);
    }
}
```

### 15.3 读路径合并
```java
public class ReadPath {
    public Optional<Cell> get(String rowKey, MemTable mem, List<SStableReader> readers) {
        Optional<Cell> inMem = mem.get(rowKey);
        if (inMem.isPresent()) return inMem;
        for (SStableReader r : readers) {
            Optional<Cell> c = r.get(rowKey);
            if (c.isPresent()) return c;
        }
        return Optional.empty();
    }
}
```

### 15.4 Compaction 任务
```java
public class CompactionJob {
    public SStableFile compact(List<SStableFile> inputs, SStableWriter writer) {
        Iterator<RowEntry> merged = MergeIterators.byKeyAndTs(inputs);
        return writer.writeFilterTombstone(merged);
    }
}
```

### 15.5 热点拆分
```java
public class TabletSplitter {
    public List<KeyRange> split(KeyRange range, String splitKey) {
        return List.of(new KeyRange(range.start(), splitKey), new KeyRange(splitKey, range.end()));
    }
}
```

## 16. 前端功能代码（贴题控制台/运营页）
### 16.1 Tablet 热点看板（React + TS）
```tsx
type TabletHot = { tabletId: string; qps: number; range: string };

export function TabletHotspotBoard() {
  const [rows, setRows] = useState<TabletHot[]>([]);
  useEffect(() => { fetch("/api/bigtable/hot-tablets").then(r => r.json()).then(setRows); }, []);
  return <ul>{rows.map(r => <li key={r.tabletId}>{r.tabletId} {r.range} qps={r.qps}</li>)}</ul>;
}
```

### 16.2 Compaction 运维页（React + TS）
```tsx
export function CompactionPanel() {
  const [table, setTable] = useState("iot_metrics");
  async function trigger() {
    await fetch("/api/bigtable/compaction/trigger", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ table })
    });
    alert("已触发 compaction");
  }
  return <div><input value={table} onChange={e => setTable(e.target.value)} /><button onClick={trigger}>触发</button></div>;
}
```

## 17. 测试策略
1. 单测：写入顺序、版本覆盖、tombstone 行为。  
2. 集成：写->刷盘->读->compaction 全链路。  
3. 压测：高写入场景下延迟和吞吐。  
4. 故障演练：节点崩溃、WAL 损坏、热点迁移。  
5. 对账：随机抽样比对写入与查询结果。  

## 18. 丰富例子（面试可复述）
1. 为什么 row key 设计决定性能。  
2. 热点 key 如何打散。  
3. compaction 堆积会导致什么问题。  
4. tombstone 太多为何读变慢。  
5. WAL 重放慢怎么优化。  
6. 跨表 join 为什么不适合。  
7. 小对象写入如何批量化。  
8. 读写高峰同时来如何调参。  
9. 冷热数据如何分层。  
10. schema 变更如何平滑。  
11. 多版本保留策略怎么定。  
12. 数据合规删除如何保证。  

## 19. 面试追问+回答模板
1. 问：LSM 为什么写快？  
答：写先顺序落 WAL+MemTable，避免随机磁盘写。  
2. 问：为什么读会慢？  
答：数据分散在多层 SSTable，需要多路合并，产生读放大。  
3. 问：compaction 的价值？  
答：减少读放大、清理 tombstone、控制文件数量，维持查询性能。  

## 20. 新手学习路线
1. 先理解 row key 与列族。  
2. 学写路径（WAL+MemTable）。  
3. 学 SSTable 和 compaction。  
4. 学热点分片与迁移。  
5. 学监控与故障恢复。  

## 21. 上场前Checklist
1. 能画出写路径和读路径。  
2. 能解释 compaction 取舍。  
3. 能说明 row key 设计原则。  
4. 能给出告警阈值。  
5. 能讲出与母题差异。  

## 22. 与母题差异（共性/差异/新增知识/话术）
### 22.1 对应母题
- 母题：`Q15 数据库拆分与一致性哈希`。  

### 22.2 共性能力
1. 都是数据层扩展问题。  
2. 都涉及分片与路由。  
3. 都关注性能与一致性取舍。  
4. 都要处理扩容迁移。  

### 22.3 关键差异
1. Q15 偏关系库分片策略；Q20 偏 LSM 存储引擎架构。  
2. Q20 重点在写放大/读放大与 compaction。  
3. Q15 更强调跨分片查询与事务边界。  
4. Q20 更强调 row key、列族和版本模型。  
5. Q20 通常用于海量时序/日志类场景。  

### 22.4 本题新增必补知识
1. WAL + MemTable 写路径。  
2. SSTable 组织方式。  
3. Compaction 策略。  
4. Tombstone 清理机制。  
5. Tablet 热点拆分迁移。  

### 22.5 面试差异话术
1. “Q15 讲分库分表策略，Q20 讲底层 LSM 存储体系。”  
2. “Q20 高分点是把读写放大和 compaction 讲透。”  
3. “Q20 不是 SQL 事务题，而是海量写入与范围读题。”  
