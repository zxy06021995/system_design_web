# 母题 Q16：RateLimiter + Grafana（新手能懂 + 面试能讲清）

## 0. 先用三句话讲明白这题
1. 限流系统的目标不是“多拦请求”，而是“在高峰时保护系统不崩”。  
2. 真正难点不是算法名字，而是“别误伤正常用户、规则能回滚、效果看得见”。  
3. 面试高分关键：你要讲清楚“策略分层 + 发布回滚 + 监控闭环”。  

---

## 1. 先讲一个真实小故事（最好懂）
### 场景
- 晚上 8 点活动开始，订单接口流量从 2k RPS 突然冲到 40k RPS。  
- 数据库连接池开始耗尽，接口错误率飙升。  

### 没有限流会发生什么
- 所有请求都挤进来，下游被压垮，最后“好请求坏请求一起挂”。  

### 有限流之后想达到什么
- 优先保护核心请求（下单、支付）。
- 非核心请求（推荐、统计）先降级。
- 系统整体还能活着，业务可控。  

---

## 2. 把抽象名词翻译成白话（面试特别好用）
| 术语 | 白话解释 | 面试可直接说法 |
|---|---|---|
| Rate Limiter | 请求“闸门” | “超过阈值就先拦住，保护后端” |
| Token Bucket | 发通行证 | “桶里有 token 才能过，没 token 就拦” |
| Sliding Window | 看最近一段时间请求数 | “过去 1 秒内不能超过 N 次” |
| Leaky Bucket | 匀速放水 | “入口再快，出口保持稳定速度” |
| Burst | 突发流量 | “短时间内请求突然暴涨” |
| False Positive | 误杀 | “正常用户被当成超限” |
| Fail-Open | 放行降级 | “限流系统挂了，先放行避免业务全挂” |
| Fail-Close | 严格拦截 | “限流系统挂了，也要保守拦截” |
| Rule Version | 规则版本号 | “方便灰度和回滚” |
| SLO | 服务目标线 | “比如 P99、可用性、误杀率” |

---

## 3. 需求澄清（Functional / Non-Functional / 不做）
### 3.1 功能需求
- 支持多维限流：全局、租户、用户、IP、API。  
- 支持不同算法：令牌桶、滑动窗口、漏桶。  
- 支持规则管理：创建、灰度发布、回滚。  
- 支持返回限流信息：剩余额度、重置时间、命中规则。  
- 支持 Grafana 看板和告警。  

### 3.2 非功能需求
- 判定时延 P99 `< 5ms`。  
- 限流服务可用性 `>= 99.99%`。  
- 规则传播延迟 `< 3s`。  
- 关键接口误杀率 `< 0.3%`。  

### 3.3 第一版不做
- 不做机器学习自动调阈值。  
- 不做全球跨 Region 强一致配额。  
- 不做无限复杂策略（避免规则爆炸）。  

### 3.4 面试开口模板
“我先把限流分成三层：数据面快速判定、控制面规则发布、观测面效果评估。  
如果只做算法不做发布和监控，线上一定翻车。”  

---

## 4. 容量估算（一步一步算给面试官看）
### 4.1 输入假设（示例）
- 网关峰值流量：`220,000 RPS`  
- 参与限流判定比例：`90%`  
- 每请求平均检查规则：`2`（全局 + 维度）  
- Redis Lua 单分片保守能力：`40,000 ops/s`  

### 4.2 计算
- 判定请求量：`220,000 * 0.9 = 198,000 QPS`  
- 若每次检查两条规则：`396,000 ops/s`  
- Redis 分片数粗估：`396,000 / 40,000 ~= 9.9`，考虑冗余建议 12~16 分片。  

### 4.3 为什么重要
- 容量估算决定你怎么配 Redis、判定服务、网关线程池。  
- 面试官会看你是不是“先算清楚再设计”。  

### 4.4 面试一句话
“我按 20 万级判定 QPS 设计，留 2 倍突发余量，保证高峰不雪崩。”  

---

## 5. 架构：先讲简版，再讲完整版
### 5.1 简版（先让人听懂）
```text
客户端请求
  -> 网关
    -> 限流判定服务
      -> Redis 计数
    -> 业务服务
```

### 5.2 完整版（面试加分）
```text
Data Plane:
Client -> API Gateway(Filter) -> Decision Service -> Redis Cluster -> Upstream

Control Plane:
Rule API -> Rule Store(MySQL/Etcd) -> Rule Distributor(Kafka/NATS) -> Local Cache

Observability Plane:
Prometheus -> Grafana -> Alertmanager -> Oncall
Audit Log -> SIEM
```

### 5.3 每层一句话职责
- 数据面：只做“快判定”，不要复杂逻辑。  
- 控制面：只做“规则发布和回滚”。  
- 观测面：回答“这条规则到底好不好”。  

---

## 6. 算法怎么选（别背定义，要讲场景）
### 6.1 令牌桶（Token Bucket）
- 适合：允许短时突发，但控制长期速率。  
- 例子：普通用户查询接口。  

### 6.2 滑动窗口（Sliding Window）
- 适合：对“边界公平”要求高。  
- 例子：支付、下单等关键接口。  

### 6.3 漏桶（Leaky Bucket）
- 适合：保护下游，输出节奏要稳定。  
- 例子：异步任务消费、网关到后端整流。  

### 6.4 常见组合（实战）
- 全局防洪：漏桶。  
- 租户维度：令牌桶。  
- 核心接口：滑动窗口 + 白名单。  

### 6.5 面试可复述
“我不会全站只用一个算法，而是按业务风险分层组合。”  

---

## 7. 策略层级与冲突处理（易被问）
### 7.1 策略层级
1. 全局规则（保护系统底线）  
2. 租户规则（商业分级）  
3. 用户/IP 规则（防刷）  
4. API 规则（热点接口精细控制）  

### 7.2 冲突决策规则
- 采用“最严格优先”。  
- 例子：全局剩余 100，租户剩余 20，用户剩余 5 -> 最终只给 5。  

### 7.3 特殊例外
- 核心救命接口可配置紧急白名单（必须审计）。  
- 活动期间可以临时放量（必须有过期时间）。  

---

## 8. API 设计（带示例）
### 8.1 判定接口
`POST /v1/limiter/check`

Request:
```json
{
  "tenantId": "t-1001",
  "userId": "u-998",
  "ip": "10.10.1.8",
  "api": "POST:/v1/orders",
  "cost": 1,
  "timestamp": 1771900000123
}
```

Response:
```json
{
  "allowed": false,
  "ruleId": "rule-tenant-order",
  "ruleVersion": 208,
  "remaining": 0,
  "resetAt": 1771900001000,
  "reason": "TOKEN_EXHAUSTED"
}
```

### 8.2 规则管理接口
- `POST /v1/limiter/rules`（创建规则）  
- `POST /v1/limiter/rules/{id}/publish`（灰度发布）  
- `POST /v1/limiter/rules/{id}/rollback`（回滚）  
- `GET /v1/limiter/rules/{id}/history`（变更审计）  

### 8.3 常见错误码
- `RULE_NOT_FOUND`  
- `RULE_VERSION_CONFLICT`  
- `LIMITER_BACKEND_TIMEOUT`  
- `CHECK_TIMEOUT`  

---

## 9. 数据模型（MySQL + Redis Key）
### 9.1 规则表
```sql
CREATE TABLE limit_rule (
  rule_id VARCHAR(64) PRIMARY KEY,
  dimension VARCHAR(32) NOT NULL,
  algorithm VARCHAR(32) NOT NULL,
  rate_limit INT NOT NULL,
  burst_limit INT,
  priority INT NOT NULL,
  status VARCHAR(16) NOT NULL,
  version BIGINT NOT NULL,
  created_by VARCHAR(64) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
```

### 9.2 发布记录表
```sql
CREATE TABLE rule_release (
  release_id BIGINT PRIMARY KEY,
  rule_id VARCHAR(64) NOT NULL,
  version BIGINT NOT NULL,
  traffic_ratio INT NOT NULL,
  state VARCHAR(16) NOT NULL,
  rollback_from BIGINT,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
```

### 9.3 审计表
```sql
CREATE TABLE limit_audit (
  id BIGINT PRIMARY KEY,
  trace_id VARCHAR(128) NOT NULL,
  tenant_id VARCHAR(64),
  user_id VARCHAR(64),
  api VARCHAR(128),
  rule_id VARCHAR(64),
  decision VARCHAR(16) NOT NULL,
  reason VARCHAR(128),
  ts TIMESTAMP NOT NULL
);
```

### 9.4 Redis Key 规范
- `rl:tb:{ruleId}:{subject}`（令牌桶）  
- `rl:sw:{ruleId}:{subject}:{epochSec}`（滑窗）  
- `rl:rule:{ruleId}:{version}`（规则缓存）  

---

## 10. 核心流程（面试必讲）
### 10.1 正常判定流程
1. 网关抽取维度（tenant/user/ip/api）。  
2. 判定服务读取本地规则缓存。  
3. Redis Lua 原子判定。  
4. 返回 allow/reject + remaining/resetAt。  

### 10.2 高峰突发流程（例子）
- 某租户突发 20 倍流量。  
- 系统先命中租户限流，再命中全局保护。  
- 非核心接口返回 429，核心接口保留配额。  

### 10.3 规则灰度流程
1. 新规则先 5% 流量试跑。  
2. 观察拒绝率、成功率、误杀率。  
3. 正常则升到 20%/50%/100%。  

### 10.4 回滚流程
1. 告警触发（误杀率超阈）。  
2. 一键切回稳定版本。  
3. 冻结发布并复盘。  

---

## 11. 一致性、事务、幂等（说清边界）
### 11.1 一致性边界
- 限流判定只要求“单 key 原子”，不追求全局强一致。  
- 规则配置采用版本号最终一致传播。  

### 11.2 事务边界
- 判定链路不做跨库事务。  
- 审计写失败不影响主判定（异步补偿）。  

### 11.3 幂等
- 判定请求可重试，但要保持同一窗口行为稳定。  
- 规则发布用 `release_id` 防重复执行。  

---

## 12. 可用性与容错（系统自己挂了怎么办）
### 12.1 关键策略
- Redis 超时时：根据 API 级别选择 fail-open 或 fail-close。  
- 判定服务故障：本地短 TTL 兜底限流。  
- 分发通道故障：保持上一稳定规则继续运行。  

### 12.2 隔离策略
- 核心接口与普通接口用不同配额池。  
- 判定线程池与业务线程池隔离。  
- 高价值租户可独立隔离。  

### 12.3 RTO / RPO
- RTO `< 5min`（控制面恢复）  
- RPO `< 1min`（规则变更审计）  

---

## 13. 可观测性（Grafana 要画什么）
### 13.1 必看指标
- `request_qps`, `allowed_qps`, `rejected_qps`  
- `decision_p95/p99`  
- `backend_timeout_rate`  
- `critical_api_reject_rate`  
- `false_positive_rate`  
- `rule_release_success` / `rollback_count`  

### 13.2 告警阈值示例
- `decision_p99 > 8ms` 持续 5 分钟 -> P1  
- `critical_api_reject_rate > 2%` 持续 3 分钟 -> P1  
- `false_positive_rate > 0.5%` 持续 10 分钟 -> 自动建议回滚  

### 13.3 新手好懂解释
- “只看 429 比例不够，必须同时看业务成功率，不然你可能在‘稳定地误杀’。”  

---

## 14. 安全与合规
- 规则变更必须 RBAC + 审批 + 审计。  
- 用户/IP 等敏感字段做脱敏。  
- 核心规则发布启用双人复核。  

---

## 15. 成本与取舍
### 15.1 主要成本
- Redis 高并发判定成本。  
- 全量审计日志成本。  
- 高精度策略（滑窗）计算成本。  

### 15.2 取舍建议
- 关键接口用滑窗，普通接口用令牌桶。  
- 放行日志采样，拒绝日志全量。  
- 历史指标下沉冷存。  

---

## 16. Java 关键代码（加注释，便于新手）
### 16.1 主判定流程
```java
public class LimitDecisionService {
  public Decision check(CheckRequest req) {
    Rule rule = ruleCache.match(req);
    if (rule == null) {
      return Decision.allow("NO_RULE");
    }

    // Redis Lua 保证原子判定
    RedisEvalResult r = redisLimiter.eval(rule, req.subjectKey(), req.cost(), System.currentTimeMillis());
    if (r.allowed()) {
      return Decision.allow(rule.ruleId(), rule.version(), r.remaining(), r.resetAt());
    }
    return Decision.reject(rule.ruleId(), rule.version(), r.remaining(), r.resetAt(), r.reason());
  }
}
```

### 16.2 Redis 故障本地兜底
```java
public class LocalFallbackLimiter {
  private final ConcurrentHashMap<String, AtomicInteger> counter = new ConcurrentHashMap<>();
  private final ConcurrentHashMap<String, Long> windowStart = new ConcurrentHashMap<>();

  public boolean allow(String key, int limit, long nowMs, long windowMs) {
    long start = windowStart.getOrDefault(key, nowMs);
    if (nowMs - start >= windowMs) {
      windowStart.put(key, nowMs);
      counter.put(key, new AtomicInteger(0));
    }
    int val = counter.computeIfAbsent(key, k -> new AtomicInteger(0)).incrementAndGet();
    return val <= limit;
  }
}
```

### 16.3 规则灰度发布与回滚
```java
public class RuleReleaseService {
  public void publish(String ruleId, long version, int ratio) {
    ReleasePlan plan = ReleasePlan.publish(ruleId, version, ratio);
    releaseRepo.save(plan);
    distributor.broadcast(plan);
  }

  public void rollback(String ruleId, long badVersion, long stableVersion) {
    ReleasePlan rollback = ReleasePlan.rollback(ruleId, badVersion, stableVersion);
    releaseRepo.save(rollback);
    distributor.broadcast(rollback);
  }
}
```

### 16.4 误杀检测任务
```java
public class FalsePositiveJob {
  @Scheduled(fixedDelay = 60000)
  public void run() {
    double rejectRate = metrics.query("sum(rate(limiter_reject_total[5m])) / sum(rate(limiter_request_total[5m]))");
    double bizSuccess = metrics.query("sum(rate(biz_success_total[5m])) / sum(rate(biz_request_total[5m]))");
    if (rejectRate > 0.15 && bizSuccess < 0.25) {
      alert.send("Possible false-positive spike, check latest release and rollback if needed");
    }
  }
}
```

---

## 17. 丰富例子（保证你能讲给新手听）
1. **活动秒杀**：流量 20 倍，核心下单保留，推荐接口先限。  
2. **爬虫攻击**：同 IP 高频请求，IP 维度限流先拦。  
3. **单租户暴涨**：租户级限流防止拖垮全局。  
4. **规则写错一个 0**：1000/s 配成 100/s，灰度阶段快速发现回滚。  
5. **Redis 抖动**：启用本地兜底，业务不至于全挂。  
6. **误杀正常用户**：拒绝率高但业务成功率掉太快，触发告警。  
7. **运营活动放量**：临时规则带过期时间，活动后自动回收。  
8. **支付接口保护**：支付接口限流更宽松但严格监控。  
9. **多规则冲突**：全局和租户冲突时取更严格值。  
10. **发布回滚演练**：每次发版都验证“一键回滚 3 分钟内生效”。  

---

## 18. 测试策略（面试加分）
### 18.1 单测
- 令牌桶边界测试（空桶、补充、突发）。  
- 滑窗边界测试（窗口切换点）。  

### 18.2 压测
- 20 万 QPS 判定压测。  
- 热点租户压测。  

### 18.3 故障注入
- Redis 超时注入。  
- 规则分发中断注入。  
- 发布后自动回滚演练。  

### 18.4 回归
- 每次规则引擎升级都跑历史流量回放。  

---

## 19. 面试高频追问 + 可直接复述答案
### Q1：为什么不用一个算法搞定全部场景？
- “因为场景目标不同：有的要抗突发，有的要公平精确，所以要组合。”  

### Q2：限流系统自己挂了怎么办？
- “按接口级别做 fail-open/fail-close，并有本地短 TTL 兜底。”  

### Q3：怎么衡量误杀？
- “不能只看拒绝率，要看拒绝率与业务成功率是否背离。”  

### Q4：灰度发布看哪些指标？
- “至少看拒绝率、成功率、P99、错误码分布。”  

### Q5：怎么证明方案能落地？
- “我有演练 Runbook：规则误发布、Redis 抖动、热点洪峰三类场景都能回滚。”  

---

## 20. 新手学习路线（7 天）
1. 第 1 天：实现单机令牌桶。  
2. 第 2 天：实现滑动窗口。  
3. 第 3 天：接 Redis Lua 做原子判定。  
4. 第 4 天：做规则表和版本发布。  
5. 第 5 天：接 Prometheus + Grafana。  
6. 第 6 天：做灰度 + 回滚。  
7. 第 7 天：按面试结构讲一遍并复盘。  

---

## 21. 上场前 Checklist
- [ ] 我能讲清 3 种算法的适用边界。  
- [ ] 我能讲清策略层级和冲突处理。  
- [ ] 我能讲清规则灰度发布和回滚。  
- [ ] 我能讲清误杀率如何定义和监控。  
- [ ] 我能说出至少 3 个关键告警阈值。  
- [ ] 我能举出 3 个真实场景例子。  

---

## 22. 30 秒总结
- Q16 高分关键不是“会算法”，而是“算法 + 发布 + 回滚 + 观测”形成闭环。  
- 你只要按“先故事、再规则、再例子、再兜底”讲，面试官会觉得你真做过线上治理。  
