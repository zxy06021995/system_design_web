# Q34：Design Redis（95分面试版，面向新手可讲清）

## 1. 三句话题目本质
1. Redis 题本质不是“会几个命令”，而是“如何设计一个高性能内存数据库并在故障下还能稳定工作”。  
2. 面试官主要看你是否讲清三条主线：数据结构与性能、持久化与一致性、高可用与扩展。  
3. 真正高分点在取舍：快到什么程度、丢数据能容忍多少、故障切换能接受多长抖动。  

## 2. 一个真实场景故事
你负责一个电商系统，平时 Redis 很稳。  
双 11 当天出现了三件事：
- 热门商品库存 key 每秒被打 20 万次，单 key 成瓶颈。
- 主节点突然重启，业务出现短暂“查不到缓存”。
- AOF 文件膨胀，重写时 CPU 抖动，延迟飙高。

老板的问题很现实：
- 为什么 Redis 明明很快，还是会抖？
- 数据到底会丢多少？
- 我们该选 Sentinel 还是 Cluster？

这就是这题要回答的核心：不仅要快，还要在高压和故障下可控。

## 3. 术语白话表（至少 10 项）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Event Loop | 事件循环 | “Redis 单线程顺序处理命令，避免锁竞争” |
| I/O Thread | IO 线程 | “新版本可并行做网络收发，执行逻辑仍主线程” |
| SDS | 简单动态字符串 | “Redis 自定义字符串，避免 C 字符串低效问题” |
| Dict | 哈希表 | “大多数 Key 的底层索引结构” |
| SkipList | 跳表 | “ZSet 排序能力的核心结构” |
| RDB | 快照持久化 | “定时把内存拍成二进制快照” |
| AOF | 追加日志持久化 | “把写命令顺序记日志” |
| AOF Rewrite | AOF 重写 | “把历史命令压缩成最小重放命令集” |
| PSYNC | 增量复制协议 | “主从断线重连后尽量只补差量” |
| Replication Lag | 复制延迟 | “从库落后主库的时间差” |
| Sentinel | 哨兵 | “监控+故障转移协调组件” |
| Slot | 槽位 | “Cluster 把 Key 空间拆成 16384 槽” |
| Hash Tag | 哈希标签 | “让多个 key 强制落到同一槽位” |
| Eviction Policy | 淘汰策略 | “内存满时删谁” |
| BigKey | 大 key | “单 key 占太大，操作会慢且危险” |
| HotKey | 热 key | “访问过热，单节点被打爆” |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 提供 String/Hash/List/Set/ZSet 常用结构。
- 支持高并发读写与 TTL 过期。
- 支持持久化（RDB/AOF）与重启恢复。
- 支持主从复制、故障切换和水平扩容。
- 提供基础权限控制、监控和告警。

### 4.2 非功能需求（SLO 示例）
- 读延迟 `P95 <= 2ms`，写延迟 `P95 <= 3ms`（同机房）。
- 峰值吞吐：`>= 1,000,000 ops/s`（集群总吞吐）。
- 可用性：`>= 99.95%`。
- 主从切换恢复时间（RTO）：`<= 30s`。
- 数据恢复点目标（RPO）：`0~1s`（AOF everysec）或分钟级（RDB-only）。

### 4.3 Out of Scope（首版不做）
- 不实现复杂 SQL 与多表 Join。
- 不追求跨机房强一致事务。
- 不做 OLAP 分析型查询。

## 5. 容量估算（含数字推导）
### 5.1 假设
- 总 key 数：`300,000,000`
- 平均 value：`180B`
- 平均 key：`32B`
- 元数据开销系数（对象头/指针/哈希桶等）：`2.2x`
- 峰值吞吐：`1,200,000 ops/s`（读写比 8:2）

### 5.2 内存估算
- 业务数据体积：`300M * (32 + 180)B ≈ 63.6GB`
- 乘上 Redis 结构开销：`~140GB`
- 留 30% 安全水位：`~182GB`

如果使用 6 主节点分片，单主有效数据约 `30GB`，可控制在常见机器内存范围。

### 5.3 网络估算
- 假设平均请求+响应 400B：  
  `1,200,000 * 400B ≈ 480MB/s ≈ 3.84Gbps`
- 主从复制还要额外带宽，峰值需预留 > 2 倍。

### 5.4 关键结论
- 容量估算必须包含对象开销，不然上线就 OOM。
- 机器规划要按“数据 + 复制 + 突发 + 重平衡”留足余量。
- Cluster 是吞吐扩展主路径，单机纵向扩容很快到顶。

## 6. 架构（简版 + 完整版）
### 6.1 简版架构
```text
Client -> Redis Cluster(多主分片) -> Replica
                     -> Persistence(RDB/AOF)
                     -> Monitoring/Alert
```

### 6.2 完整版架构
```text
[App Clients]
   -> [Redis Client SDK / Proxy]
      -> [Redis Cluster: Master Shards]
           -> [Replica per Shard]
      -> [Sentinel (非Cluster模式HA)]
      -> [Config Center]

[Persistence Layer]
   -> [RDB Snapshot Files]
   -> [AOF Append + Rewrite]

[Ops & Observability]
   -> [Metrics Exporter]
   -> [Alert Manager]
   -> [Slowlog Analyzer]
   -> [Failover Automation]
```

### 6.3 Sentinel vs Cluster 一句话区别
- Sentinel：解决“主从故障切换”，不解决数据自动分片。
- Cluster：同时解决“分片扩展 + 节点故障转移”。

## 7. API 设计（含请求/响应样例）
Redis 原生命令是协议交互，这里按工程实践给两层接口示例：

### 7.1 应用缓存服务 API（业务侧）
`GET /cache/v1/object/{bizKey}`

Response:
```json
{
  "found": true,
  "value": "{\"id\":101,\"name\":\"phone\"}",
  "ttlSec": 48
}
```

`POST /cache/v1/object/{bizKey}`

Request:
```json
{
  "value": "{\"id\":101,\"name\":\"phone\"}",
  "ttlSec": 300,
  "idempotencyKey": "cache_set_20260224_001"
}
```

### 7.2 Redis 命令层示例
- `SET product:101 {...} EX 300 NX`
- `HSET user:2001 profile:name "alice"`
- `ZADD rank:sales 9234 product_101`
- `EVAL <lua_script> 2 stock:101 user:2001`

### 7.3 错误语义
- `429_RATE_LIMITED`：客户端流量控制触发。
- `503_CACHE_DEGRADED`：分片不可用，触发降级读 DB。
- `409_LOCK_CONFLICT`：分布式锁争抢失败。

## 8. 数据模型（核心 key 设计 + 索引）
### 8.1 Key Schema（推荐规范）
| 业务对象 | Key 模板 | 结构 | TTL |
|---|---|---|---|
| 商品缓存 | `product:{id}` | String(JSON) | 5min |
| 用户会话 | `session:{token}` | Hash | 30min |
| 秒杀库存 | `stock:{skuId}` | String(int) | 活动期 |
| 排行榜 | `rank:{scene}` | ZSet | 按需 |
| 去重集合 | `dedup:{biz}:{day}` | Set | 1d |
| 延迟任务 | `delay:{topic}` | ZSet | 常驻 |

### 8.2 索引与路由策略
- 分片键优先选高基数字段（如 `userId`、`skuId`）。
- 需要事务性的多 key 操作，使用 hash tag：  
  例如 `{order123}:status`、`{order123}:events`，确保同槽。

### 8.3 过期和淘汰策略
- 业务 TTL + 随机抖动（防雪崩）。
- `maxmemory-policy` 推荐按业务选：  
  `allkeys-lru`（通用缓存）  
  `volatile-ttl`（有 TTL 数据优先淘汰）  

## 9. 核心流程（至少 3 条）
### 9.1 正常读写流程（Cache Aside）
1. 读请求先查 Redis。
2. 未命中查 DB。
3. DB 结果回填 Redis，设置 TTL+随机值。
4. 返回业务结果。

### 9.2 高峰流程（秒杀库存）
1. 请求打到库存 Lua 脚本，原子扣减。
2. 扣减成功写 MQ 创建订单，失败立即返回售罄。
3. 热 key 过热时用本地缓存+令牌桶+分片拆 key 降压。

### 9.3 故障恢复流程（主节点宕机）
1. Sentinel/Cluster 检测主节点不可达。
2. 选举从节点晋升为新主。
3. 客户端刷新路由并重连。
4. 对业务执行短期降级（只读缓存/回源 DB 限流）。

### 9.4 扩容迁移流程（Cluster）
1. 新增节点加入集群。
2. 迁移槽位（slot move），渐进搬迁 key。
3. 迁移期间双节点协作转发。
4. 完成后更新路由，清理旧节点负载。

## 10. 一致性与事务边界
### 10.1 一致性现实
- Redis 主从默认异步复制，主写成功不等于从已落盘。
- 故障切主时可能丢最近一小段写入（取决于复制进度和持久化策略）。

### 10.2 事务边界
- 单 key 原子操作天然支持（INCR、HINCRBY、SETNX）。
- 多 key 原子建议 Lua 脚本（同槽位）。
- `MULTI/EXEC` 不是传统数据库事务，不支持回滚语义。

### 10.3 减少数据丢失策略
- AOF `appendfsync everysec`（常见平衡点）。
- 关键写可配置 `WAIT` 命令等待副本确认（牺牲延迟换更低丢失概率）。
- 对关键业务采用“Redis + DB 双写校对”。

## 11. 可用性与容错
### 11.1 常见故障
- OOM 触发写拒绝。
- BigKey 删除阻塞主线程。
- 复制积压缓冲区不足导致全量同步风暴。
- AOF rewrite 与业务高峰重叠导致延迟抖动。

### 11.2 对应策略
- 内存水位线管理：70% 预警、85% 限流、95% 强降级。
- 大 key 治理：上线前扫描、异步分批删除、键拆分。
- 复制优化：合理 `repl-backlog-size`，防频繁全量同步。
- 重写窗口：AOF rewrite 在低峰执行，设置最小增长阈值。

### 11.3 RTO / RPO 目标示例
- RTO：`<= 30 秒`（自动切主 + 客户端路由更新）。
- RPO：  
  RDB-only：分钟级  
  AOF everysec：约 1 秒级  
  AOF always：更低丢失但高性能成本  

## 12. 可观测性（指标 + 告警阈值）
### 12.1 性能指标
- `instantaneous_ops_per_sec`
- `latency_p95_ms`, `latency_p99_ms`
- `connected_clients`

阈值示例：
- `latency_p95_ms > 5` 持续 5 分钟 -> P1
- `connected_clients > 90% maxclients` -> P1

### 12.2 内存与淘汰指标
- `used_memory`
- `mem_fragmentation_ratio`
- `evicted_keys`
- `expired_keys`

阈值示例：
- `used_memory > 85%` 持续 10 分钟 -> P1
- `mem_fragmentation_ratio > 1.8` 持续 30 分钟 -> P2
- `evicted_keys` 突增 > 基线 3 倍 -> P1

### 12.3 复制与持久化指标
- `master_repl_offset` / `slave_repl_offset`
- `replication_lag_sec`
- `aof_current_size`, `aof_rewrite_in_progress`
- `rdb_last_bgsave_status`

阈值示例：
- `replication_lag_sec > 3` 持续 5 分钟 -> P1
- `aof_rewrite_in_progress=1` 且 `latency_p99_ms > 20` 持续 10 分钟 -> P1

## 13. 安全与合规
- ACL：按应用划分账号和命令权限，最小权限原则。
- 网络隔离：Redis 仅内网可达，禁止公网裸露。
- 传输安全：跨机房建议 TLS。
- 高危命令防护：禁用/重命名 `FLUSHALL`, `CONFIG`, `KEYS` 等敏感命令。
- 审计：配置变更、故障切换、权限变更必须留痕。

## 14. 成本与取舍
### 14.1 成本组成
- 内存成本（最大头）。
- CPU 成本（高并发 + 脚本 + 重写）。
- 网络成本（复制与跨机房同步）。

### 14.2 典型取舍
- AOF always 数据更安全，但延迟和 IO 成本更高。
- 更高副本数提升可用性，但增加复制带宽和内存占用。
- 追求低延迟时，复杂 Lua/大对象操作要严格控制。

### 14.3 降本策略
- 热冷分层：热点放 Redis，冷数据回 DB/对象存储。
- 值压缩：JSON 压缩或字段拆分，减少内存占用。
- 数据结构选型：能用 Hash 不用大 JSON String。
- TTL 分级：高价值 key 长 TTL，低价值短 TTL。

## 15. Java 关键代码（至少 4 段，点位不同）
### 15.1 Cache Aside + 防击穿互斥锁
```java
public class ProductCacheService {
    public Product getProduct(long productId) {
        String key = "product:" + productId;
        String cached = redis.get(key);
        if (cached != null) {
            return Jsons.fromJson(cached, Product.class);
        }

        String lockKey = "lock:product:" + productId;
        String token = UUID.randomUUID().toString();
        boolean locked = "OK".equals(redis.set(lockKey, token, "NX", "PX", 3000));
        if (!locked) {
            sleep(30);
            String retry = redis.get(key);
            return retry == null ? null : Jsons.fromJson(retry, Product.class);
        }

        try {
            Product db = productRepo.findById(productId);
            if (db == null) {
                redis.setex("null:" + productId, 60, "1"); // 防穿透
                return null;
            }
            int ttl = 300 + ThreadLocalRandom.current().nextInt(60); // 防雪崩抖动
            redis.setex(key, ttl, Jsons.toJson(db));
            return db;
        } finally {
            unlockSafely(lockKey, token);
        }
    }

    private void unlockSafely(String lockKey, String token) {
        String lua = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        redis.eval(lua, List.of(lockKey), List.of(token));
    }

    private void sleep(long ms) {
        try { Thread.sleep(ms); } catch (InterruptedException ignored) {}
    }
}
```

### 15.2 秒杀库存 Lua 原子扣减
```java
public class StockService {
    private static final String DEDUCT_LUA =
        "local stock = tonumber(redis.call('get', KEYS[1]) or '-1') " +
        "if stock <= 0 then return -1 end " +
        "redis.call('decr', KEYS[1]) " +
        "redis.call('sadd', KEYS[2], ARGV[1]) " +
        "return stock - 1";

    public int deduct(String skuId, long userId) {
        String stockKey = "stock:" + skuId;
        String buyersKey = "buyers:" + skuId;
        Object result = redis.eval(DEDUCT_LUA, List.of(stockKey, buyersKey), List.of(String.valueOf(userId)));
        return ((Number) result).intValue();
    }
}
```

### 15.3 分布式锁续约（看门狗简化版）
```java
public class RenewLockService {
    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();

    public LockHandle tryLock(String key, long ttlMs) {
        String token = UUID.randomUUID().toString();
        boolean ok = "OK".equals(redis.set(key, token, "NX", "PX", ttlMs));
        if (!ok) return null;

        ScheduledFuture<?> renewTask = scheduler.scheduleAtFixedRate(() -> {
            String lua =
                "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                "  return redis.call('pexpire', KEYS[1], ARGV[2]) " +
                "else return 0 end";
            redis.eval(lua, List.of(key), List.of(token, String.valueOf(ttlMs)));
        }, ttlMs / 3, ttlMs / 3, TimeUnit.MILLISECONDS);

        return new LockHandle(key, token, renewTask);
    }
}
```

### 15.4 延迟队列（ZSet）消费与 ACK
```java
public class DelayQueueConsumer {
    public List<String> pollDueTasks(String queueKey, long nowMs, int limit) {
        return redis.zrangeByScore(queueKey, 0, nowMs, 0, limit);
    }

    public boolean ackTask(String queueKey, String taskId) {
        Long removed = redis.zrem(queueKey, taskId);
        return removed != null && removed > 0;
    }

    public void requeue(String queueKey, String taskId, long delayMs) {
        redis.zadd(queueKey, System.currentTimeMillis() + delayMs, taskId);
    }
}
```

### 15.5 批量删除 BigKey（避免阻塞）
```java
public class BigKeyCleaner {
    public void cleanSetInBatches(String key, int batchSize) {
        while (true) {
            Set<String> members = redis.spop(key, batchSize);
            if (members == null || members.isEmpty()) break;
            // 批量处理后继续，避免一次性阻塞
        }
        redis.del(key);
    }
}
```

## 16. 测试策略
### 16.1 单元测试
- 缓存击穿互斥逻辑是否正确。
- Lua 扣减在并发下是否超卖。
- 锁续约在异常退出时是否释放。

### 16.2 集成测试
- 主从复制延迟场景读一致性验证。
- Sentinel 切主后客户端自动重连。
- Cluster 扩容迁移期间业务读写连续性。

### 16.3 压测
- 热 key 压测（单 key 20 万 QPS）。
- 混合读写压测（80/20）观察 P95/P99。
- AOF rewrite 时压测，评估延迟抖动。

### 16.4 故障演练
- 主节点强杀：测 RTO。
- 从节点网络隔离：测复制恢复。
- OOM 注入：验证降级和限流是否生效。

## 17. 丰富例子（至少 10 个）
1. 登录态存在 `session:{token}`，TTL 30 分钟，用户活跃时续期。  
2. 秒杀库存用 Lua 原子扣减，防并发超卖。  
3. 排行榜用 ZSet，实时更新并支持 TopN 查询。  
4. 热 key 被打爆时，本地缓存 50ms 短 TTL 降压。  
5. 大 key 删除导致卡顿，改为分批删除恢复稳定。  
6. AOF 文件 30GB 触发重写，错峰执行避免业务高峰。  
7. 主节点宕机后 20 秒内自动切主，客户端刷新路由恢复。  
8. 复制延迟升高时，支付相关读请求强制走主库。  
9. 缓存雪崩时，TTL 随机抖动 + 限流 + 熔断避免 DB 被压垮。  
10. 缓存穿透时，空对象缓存 + 布隆过滤器双重防护。  
11. Cluster 扩容时迁移槽位，热点槽优先分散到新节点。  
12. 某业务误用 `KEYS *` 触发慢查询，后续通过 ACL 禁止上线。  

## 18. 面试追问 + 可复述回答
### Q1：Redis 为什么快？
可复述：  
“核心是内存访问、事件循环减少锁开销、数据结构针对性优化，以及网络协议和实现层面的高效。”

### Q2：RDB 和 AOF 怎么选？
可复述：  
“RDB 恢复快、开销低但可能丢快照间数据；AOF 更完整但 IO 成本高。生产常用 RDB+AOF everysec 平衡。”

### Q3：Sentinel 和 Cluster 如何取舍？
可复述：  
“只要 HA 不要分片可选 Sentinel；需要容量和吞吐扩展就选 Cluster。”

### Q4：怎么处理 hot key？
可复述：  
“先识别热点，再做本地缓存、多副本读扩散、请求合并和限流，必要时改数据模型拆 key。”

### Q5：怎么避免一主宕机后丢数据太多？
可复述：  
“关键路径启用 AOF everysec 或 WAIT，缩短复制延迟并持续监控 lag；关键账务仍需 DB 兜底校对。”

### Q6：为什么不把所有数据都放 Redis？
可复述：  
“Redis 是高价值热数据层，不是无限容量主存储。全量放会导致成本和故障域失控。”

## 19. 新手学习路线
### 第 1 周：基础命令和数据结构
- 熟练 String/Hash/List/Set/ZSet。
- 理解底层结构（SDS/Dict/SkipList）与复杂度。

### 第 2 周：持久化和复制
- 实验 RDB、AOF、AOF rewrite。
- 实验主从复制、断链重连、复制延迟观察。

### 第 3 周：高可用和扩展
- 搭 Sentinel 故障切换。
- 搭 Cluster 并做槽位迁移。

### 第 4 周：工程实战
- 实现缓存三板斧：防穿透、防击穿、防雪崩。
- 做监控告警和故障演练。
- 用 10 分钟面试结构讲一遍完整答案。

## 20. 上场前 Checklist
- [ ] 我能解释 Redis 五大结构和适用场景。  
- [ ] 我能讲清 RDB/AOF 的数据丢失边界和性能影响。  
- [ ] 我能说清 Sentinel 与 Cluster 的差异与选型。  
- [ ] 我能描述一次主节点故障切换完整链路。  
- [ ] 我能给出 3 个以上核心告警阈值。  
- [ ] 我能解释 hot key / big key 的识别和治理。  
- [ ] 我能给出至少一个 Lua 原子操作实战点。  
- [ ] 我能量化“性能-一致性-成本”的取舍。  

## 21. 30 秒总结
Redis 设计题的高分表达是：  
“先用正确的数据结构把性能做出来，再用 RDB/AOF 定义数据安全边界，用主从+哨兵或集群保证可用和扩展，最后用 hot/big key 治理与告警体系把系统跑稳。”  
只要你能把这句话拆成容量、链路、阈值、故障和代码点位，面试官会判断你具备实战落地能力。  
