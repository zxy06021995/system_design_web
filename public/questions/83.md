# Q83：Design E-commerce Website（电商网站系统设计）- 95分面试版

## 1. 三句话题目本质
1. 电商系统核心链路是：浏览 -> 加购 -> 下单 -> 库存确认 -> 支付 -> 履约 -> 售后。  
2. 真正难点不是“能下单”，而是高并发下不超卖、不重单、状态不乱、资金与订单一致。  
3. 面试高分关键：讲清订单状态机、库存预占与释放、异步补偿、峰值治理和可观测性。  

## 2. 一个真实场景故事
双 11 零点，某 SKU 库存 20,000，瞬时有 300,000 用户点击“立即购买”。  
如果设计不当，常见事故是：
- 超卖：库存被扣成负数。
- 重复下单：用户网络重试导致多单。
- 支付成功但订单没更新：资金对账异常。
- 履约错单：库存确认与发货状态不一致。

业务方对你只有一个要求：  
“系统可以慢一点，但不能错单、不能丢单、不能乱扣库存。”

## 3. 术语白话表（至少 10 项）
| 术语 | 白话解释 | 面试可复述 |
|---|---|---|
| Cart | 购物车 | “用户临时选中的商品集合” |
| Checkout | 结算页 | “确认地址、优惠、运费后生成应付金额” |
| Reservation | 库存预占 | “先锁库存，支付后再正式扣减” |
| Oversell | 超卖 | “卖出的数量超过真实库存” |
| Idempotency Key | 幂等键 | “防止同一请求被重复执行” |
| Saga | 补偿事务编排 | “跨服务失败后按步骤回滚” |
| Outbox | 事务外发箱 | “本地事务提交后可靠发事件” |
| Fulfillment | 履约 | “仓配、拣货、打包、发货链路” |
| Split Order | 拆单 | “一个订单拆成多个仓/包裹处理” |
| Payment Callback | 支付回调 | “支付平台异步通知交易结果” |
| Risk Control | 风控 | “识别刷单、欺诈、异常退款” |
| Flash Sale | 秒杀 | “极端峰值场景，需要限流削峰” |
| SLA | 服务时限 | “例如 5 分钟未支付自动取消” |
| Reconciliation | 对账 | “订单、支付、资金、库存数据核对” |
| DLQ | 死信队列 | “多次处理失败事件隔离区” |

## 4. 需求澄清（功能/非功能/不做范围）
### 4.1 功能需求
- 商品浏览、搜索、详情、加购、下单、支付、发货、退款。
- 支持秒杀场景和普通下单场景并存。
- 支持优惠券、满减、运费计算、地址管理。
- 支持订单查询、取消、退款、物流追踪。
- 支持库存预占、支付确认、超时释放。

### 4.2 非功能需求（SLO 示例）
- 下单接口延迟：`P95 <= 300ms`（不含外部支付网关）。
- 库存预占成功率：`>= 99.95%`。
- 支付回调处理成功率：`>= 99.99%`。
- 系统可用性：`>= 99.95%`。
- 超卖率目标：`0`（核心 SKU）。

### 4.3 Out of Scope（首版不做）
- 不做跨境税务清结算细节。
- 不做复杂推荐与广告系统（另题）。
- 不做直播带货互动引擎（可后续扩展）。

## 5. 容量估算（含数字推导）
### 5.1 假设
- DAU：`80,000,000`
- 日订单创建：`25,000,000`
- 峰值下单 QPS：`220,000`
- 支付成功峰值 QPS：`60,000`
- 热门 SKU 秒杀峰值：`100,000 req/s/SKU`

### 5.2 吞吐估算
- 平均下单 QPS：`25M / 86400 ≈ 289`
- 峰值与均值差异巨大，必须按峰值设计核心链路。

### 5.3 存储估算
- 订单主表按 1KB/单：`25GB/day`
- 订单明细 + 审计 + 状态流转日志通常 3~5 倍放大
- 3 年历史数据轻松 PB 级（含索引/备份）

### 5.4 关键结论
- 核心压力不在平均值，而在热点 SKU 峰值。
- 库存服务与订单服务必须独立扩展。
- 秒杀入口必须限流+排队，不能让所有请求直接打库存 DB。

## 6. 架构（简版 + 完整版）
### 6.1 简版架构
```text
Client -> Gateway -> Cart -> Order -> Inventory -> Payment -> Fulfillment
                              \-> MQ/Event Bus -> Notification/Audit/Search
```

### 6.2 完整版架构
```text
[Web/App Client]
  -> [API Gateway + Auth + RateLimit]
  -> [Catalog Service]
  -> [Cart Service]
  -> [Pricing/Promotion Service]
  -> [Order Service]
  -> [Inventory Service]
  -> [Payment Orchestrator]
  -> [Fulfillment Service]
  -> [After-sale Service]

[Async Backbone]
  -> [Outbox + Kafka]
  -> [Order Event Consumer]
  -> [Inventory Release Worker]
  -> [Notification Service]
  -> [Search Indexer]
  -> [Data Warehouse Sink]

[Control & Ops]
  -> [Risk Engine]
  -> [Reconciliation Service]
  -> [Observability + Alert]
```

### 6.3 关键职责
- Order Service：订单状态机和幂等创建。
- Inventory Service：预占/确认/释放，防超卖核心。
- Payment Orchestrator：处理支付回调幂等与状态对齐。
- Fulfillment：订单拆单与发货状态管理。

## 7. API 设计（含请求/响应样例）
### 7.1 预览订单（价格、优惠、库存可售）
`POST /api/v1/orders/preview`

Request:
```json
{
  "userId": 10001,
  "items": [{"skuId": 9001, "qty": 2}],
  "couponId": "cp_100",
  "addressId": 30011
}
```

Response:
```json
{
  "previewId": "pv_8891",
  "totalAmount": 39900,
  "discountAmount": 2000,
  "shippingFee": 800,
  "payableAmount": 37700,
  "stockCheck": "PASS"
}
```

### 7.2 创建订单（幂等）
`POST /api/v1/orders`

Request:
```json
{
  "userId": 10001,
  "previewId": "pv_8891",
  "clientReqId": "req_20260224_abc",
  "items": [{"skuId": 9001, "qty": 2}]
}
```

Response:
```json
{
  "orderId": 88000123,
  "status": "PENDING_PAYMENT",
  "expireAt": "2026-02-24T10:35:00Z"
}
```

### 7.3 查询订单
`GET /api/v1/orders/{orderId}`

### 7.4 取消订单
`POST /api/v1/orders/{orderId}/cancel`

### 7.5 支付回调（内部）
`POST /internal/v1/payment/callback`

### 7.6 错误码语义
- `409_ORDER_ALREADY_EXISTS`：幂等重复下单。
- `422_STOCK_NOT_ENOUGH`：库存不足。
- `423_ORDER_STATE_INVALID`：当前状态不允许该操作。
- `503_FLASH_SALE_THROTTLED`：秒杀入口限流中。

## 8. 数据模型（核心表/索引）
### 8.1 订单主表
```sql
CREATE TABLE orders (
  order_id BIGINT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  status VARCHAR(32) NOT NULL,          -- CREATED/RESERVED/PENDING_PAYMENT/PAID/CANCELED/SHIPPED/COMPLETED/REFUNDED
  total_amount BIGINT NOT NULL,
  payable_amount BIGINT NOT NULL,
  payment_txn_id VARCHAR(64),
  expire_at TIMESTAMP NOT NULL,
  version BIGINT NOT NULL DEFAULT 1,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_orders_user_time ON orders(user_id, created_at DESC);
CREATE INDEX idx_orders_status_expire ON orders(status, expire_at);
```

### 8.2 订单明细表
```sql
CREATE TABLE order_item (
  order_id BIGINT NOT NULL,
  sku_id BIGINT NOT NULL,
  qty INT NOT NULL,
  unit_price BIGINT NOT NULL,
  promo_discount BIGINT NOT NULL DEFAULT 0,
  PRIMARY KEY(order_id, sku_id)
);
```

### 8.3 库存表（可售+预占）
```sql
CREATE TABLE sku_stock (
  sku_id BIGINT PRIMARY KEY,
  available_qty INT NOT NULL,
  reserved_qty INT NOT NULL,
  sold_qty INT NOT NULL,
  updated_at TIMESTAMP NOT NULL
);
```

### 8.4 预占记录表
```sql
CREATE TABLE stock_reservation (
  reservation_id BIGINT PRIMARY KEY,
  order_id BIGINT NOT NULL,
  sku_id BIGINT NOT NULL,
  qty INT NOT NULL,
  state VARCHAR(16) NOT NULL,           -- HOLD/CONFIRMED/RELEASED
  expire_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL,
  UNIQUE(order_id, sku_id)
);
CREATE INDEX idx_reservation_expire ON stock_reservation(state, expire_at);
```

### 8.5 订单事件审计表
```sql
CREATE TABLE order_event (
  event_id BIGINT PRIMARY KEY,
  order_id BIGINT NOT NULL,
  event_type VARCHAR(32) NOT NULL,
  payload JSON,
  created_at TIMESTAMP NOT NULL
);
CREATE INDEX idx_order_event_order_time ON order_event(order_id, created_at DESC);
```

## 9. 核心流程（至少 3 条）
### 9.1 正常下单支付流程
1. 用户提交订单请求，Order Service 校验幂等键。
2. 调 Inventory Service 预占库存（HOLD）。
3. 创建订单 `PENDING_PAYMENT`，设置支付超时（如 15 分钟）。
4. 用户支付成功，支付回调到 Payment Orchestrator。
5. 订单状态更新 `PAID`，库存预占转 `CONFIRMED`，进入履约。

### 9.2 高峰秒杀流程
1. 请求先经网关限流 + 排队（令牌/队列号）。
2. 合格请求进入库存预占逻辑，失败快速返回售罄。
3. 订单创建异步化，用户先拿“排队中/处理中”状态。
4. 结果通过轮询或推送返回。

### 9.3 故障恢复流程（支付成功但订单未更新）
1. 支付平台回调超时或消息丢失，订单仍 `PENDING_PAYMENT`。
2. 对账任务发现“支付成功但订单未置 PAID”。
3. 触发补偿任务重放支付事件。
4. 幂等更新订单状态并补齐履约事件。

### 9.4 超时取消流程
1. 订单到达 `expire_at` 仍未支付。
2. 定时任务将状态改为 `CANCELED`。
3. 库存预占从 HOLD 释放到 available。
4. 发送取消通知给用户。

## 10. 一致性与事务边界
### 10.1 一致性策略
- 单服务内：本地事务保证一致（订单主表+明细+事件）。
- 跨服务（订单/库存/支付）：Saga + 补偿事务。

### 10.2 关键边界
- 下单时保证“不超卖”优先于“绝对实时展示库存”。
- 支付回调要幂等，重复回调不应重复扣库存。

### 10.3 幂等设计
- 下单幂等键：`userId + clientReqId`
- 支付幂等键：`paymentTxnId`
- 事件幂等键：`eventId`

### 10.4 面试可复述
“电商链路做不到全局强事务，核心是把关键状态机做严谨，失败后可补偿且不重复执行。”

## 11. 可用性与容错
### 11.1 常见故障
- 秒杀流量打爆库存服务。
- 支付网关抖动导致回调延迟。
- MQ 积压导致通知和履约延迟。
- 热门 SKU 成为单点热点 key。

### 11.2 容错策略
- 限流+排队+熔断保护核心链路。
- 支付回调异步重试 + 对账兜底。
- DLQ 隔离异常事件并人工补偿。
- 热点库存做分桶或专用分片。

### 11.3 RTO / RPO
- 下单链路 RTO：`<= 5 分钟`
- 支付状态修复 RTO：`<= 30 分钟`
- 对账修复 RPO：日内可收敛

## 12. 可观测性（指标 + 告警阈值）
### 12.1 核心交易指标
- `order_create_qps`
- `order_create_p95_ms`
- `order_fail_rate`
- `oversell_count`

阈值示例：
- `order_create_p95_ms > 300` 持续 10 分钟 -> P1
- `oversell_count > 0` -> 立即 P0

### 12.2 库存与支付指标
- `reserve_success_rate`
- `stock_release_lag_sec`
- `payment_callback_delay_p95`

阈值示例：
- `reserve_success_rate < 99%` 持续 5 分钟 -> P1
- `payment_callback_delay_p95 > 60s` 持续 10 分钟 -> P1

### 12.3 补偿与对账指标
- `saga_compensation_count`
- `reconciliation_diff_count`
- `dlq_backlog`

阈值示例：
- `reconciliation_diff_count > baseline*2` -> P1
- `dlq_backlog > 10000` 持续 10 分钟 -> P1

## 13. 安全与风控
- 账号/IP/设备指纹联合风控防刷单。
- 高风险订单触发二次验证。
- 价格和优惠签名，防前端篡改。
- 退款链路审计，异常退款报警。
- 敏感信息（地址、手机号）加密/脱敏存储。

## 14. 成本与取舍
### 14.1 成本组成
- 交易链路高可用成本（多副本、容灾）。
- 风控和对账计算成本。
- 通知与日志存储成本。

### 14.2 关键取舍
- 预占时间太长：库存利用率低。
- 预占时间太短：用户支付体验差。
- 强一致库存 vs 高吞吐：核心 SKU 可牺牲部分吞吐换一致性。

### 14.3 降本策略
- 普通商品批量异步处理，核心商品专用链路。
- 冷订单历史归档，热订单高性能存储。
- 统一事件总线复用，减少重复集成。

## 15. 关键代码（Java 更细 + 前端功能代码）
### 15.1 Java：下单幂等 + 订单创建 + Outbox
```java
public class OrderCommandService {
    public CreateOrderResult createOrder(CreateOrderCmd cmd) {
        String idemKey = cmd.getUserId() + ":" + cmd.getClientReqId();
        Long existingOrderId = idemRepo.findOrderIdByKey(idemKey);
        if (existingOrderId != null) {
            return new CreateOrderResult(existingOrderId, true);
        }

        long orderId = idGenerator.nextId();
        transactionTemplate.executeWithoutResult(tx -> {
            orderRepo.insert(OrderEntity.pendingPayment(orderId, cmd));
            orderItemRepo.batchInsert(orderId, cmd.getItems());
            idemRepo.save(idemKey, orderId);
            outboxRepo.append("ORDER_CREATED", orderId, Map.of("userId", cmd.getUserId()));
        });
        return new CreateOrderResult(orderId, false);
    }
}
```

### 15.2 Java：库存预占（防超卖 SQL + 预占记录）
```java
public class InventoryReservationService {
    public boolean reserve(long orderId, long skuId, int qty, Instant expireAt) {
        int updated = stockRepo.reserveIfEnough(skuId, qty); 
        // SQL示意:
        // UPDATE sku_stock
        // SET available_qty = available_qty - ?, reserved_qty = reserved_qty + ?
        // WHERE sku_id = ? AND available_qty >= ?

        if (updated == 0) return false;

        reservationRepo.insert(orderId, skuId, qty, "HOLD", expireAt);
        return true;
    }

    public void confirm(long orderId) {
        List<Reservation> holds = reservationRepo.findByOrder(orderId, "HOLD");
        for (Reservation r : holds) {
            stockRepo.confirmReserved(r.getSkuId(), r.getQty()); // reserved->sold
            reservationRepo.updateState(r.getReservationId(), "CONFIRMED");
        }
    }

    public void releaseExpired(long orderId) {
        List<Reservation> holds = reservationRepo.findByOrder(orderId, "HOLD");
        for (Reservation r : holds) {
            stockRepo.releaseReserved(r.getSkuId(), r.getQty()); // reserved->available
            reservationRepo.updateState(r.getReservationId(), "RELEASED");
        }
    }
}
```

### 15.3 Java：支付回调幂等处理
```java
public class PaymentCallbackService {
    public void handlePaySuccess(PaymentCallback cb) {
        if (paymentEventRepo.exists(cb.getPaymentTxnId())) {
            return; // 幂等
        }

        transactionTemplate.executeWithoutResult(tx -> {
            OrderEntity order = orderRepo.findByIdForUpdate(cb.getOrderId());
            if ("PAID".equals(order.getStatus())) {
                paymentEventRepo.save(cb); // 记录回调，不重复处理
                return;
            }
            if (!"PENDING_PAYMENT".equals(order.getStatus())) {
                throw new IllegalStateException("invalid order state for pay callback");
            }

            orderRepo.updateStatus(order.getOrderId(), "PAID", order.getVersion() + 1);
            inventoryReservationService.confirm(order.getOrderId());
            paymentEventRepo.save(cb);
            outboxRepo.append("ORDER_PAID", order.getOrderId(), Map.of("paymentTxnId", cb.getPaymentTxnId()));
        });
    }
}
```

### 15.4 Java：超时取消补偿任务
```java
public class OrderTimeoutCancelJob {
    public void run() {
        List<OrderEntity> expired = orderRepo.findExpiredUnpaid(Instant.now(), 1000);
        for (OrderEntity order : expired) {
            tryCancel(order);
        }
    }

    private void tryCancel(OrderEntity order) {
        transactionTemplate.executeWithoutResult(tx -> {
            OrderEntity locked = orderRepo.findByIdForUpdate(order.getOrderId());
            if (!"PENDING_PAYMENT".equals(locked.getStatus())) return;

            orderRepo.updateStatus(locked.getOrderId(), "CANCELED", locked.getVersion() + 1);
            inventoryReservationService.releaseExpired(locked.getOrderId());
            outboxRepo.append("ORDER_CANCELED", locked.getOrderId(), Map.of("reason", "PAY_TIMEOUT"));
        });
    }
}
```

### 15.5 Java：对账修复任务（支付成功但订单未支付）
```java
public class ReconciliationRepairWorker {
    public void repairPayMismatch(LocalDate dt) {
        List<PayOrderDiff> diffs = reconciliationRepo.findPaidButOrderNotPaid(dt);
        for (PayOrderDiff d : diffs) {
            try {
                paymentCallbackService.handlePaySuccess(
                    new PaymentCallback(d.getOrderId(), d.getPaymentTxnId(), d.getAmount())
                );
            } catch (Exception ex) {
                dlqRepo.save("PAY_MISMATCH_REPAIR", d.getOrderId(), ex.getMessage());
            }
        }
    }
}
```

### 15.6 前端（React + TypeScript）：结算页（下单幂等按钮）
```tsx
import { useState } from "react";

export function CheckoutPage() {
  const [submitting, setSubmitting] = useState(false);
  const [orderId, setOrderId] = useState<number | null>(null);
  const clientReqId = `req_${Date.now()}`;

  const submitOrder = async () => {
    if (submitting) return;
    setSubmitting(true);
    const resp = await fetch("/api/v1/orders", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        userId: 10001,
        previewId: "pv_8891",
        clientReqId,
        items: [{ skuId: 9001, qty: 2 }]
      })
    });
    setSubmitting(false);
    if (!resp.ok) {
      alert(`下单失败: ${resp.status}`);
      return;
    }
    const data = await resp.json();
    setOrderId(data.orderId);
  };

  return (
    <div>
      <h3>确认订单</h3>
      <button disabled={submitting} onClick={submitOrder}>
        {submitting ? "提交中..." : "提交订单"}
      </button>
      {orderId && <p>订单创建成功: {orderId}</p>}
    </div>
  );
}
```

### 15.7 前端（React + TypeScript）：订单状态页（轮询支付状态）
```tsx
import { useEffect, useState } from "react";

type OrderView = {
  orderId: number;
  status: string;
  payableAmount: number;
  expireAt: string;
};

export function OrderStatusPage({ orderId }: { orderId: number }) {
  const [order, setOrder] = useState<OrderView | null>(null);

  useEffect(() => {
    let timer: number;
    const load = async () => {
      const resp = await fetch(`/api/v1/orders/${orderId}`);
      if (resp.ok) {
        const data = await resp.json();
        setOrder(data);
      }
      timer = window.setTimeout(load, 3000);
    };
    load();
    return () => window.clearTimeout(timer);
  }, [orderId]);

  if (!order) return <div>加载中...</div>;

  return (
    <div>
      <h3>订单 {order.orderId}</h3>
      <p>状态: {order.status}</p>
      <p>应付金额: {order.payableAmount}</p>
      <p>支付截止: {order.expireAt}</p>
      {order.status === "PENDING_PAYMENT" && <button>去支付</button>}
    </div>
  );
}
```

## 16. 测试策略
### 16.1 单元测试
- 订单状态机合法迁移。
- 库存预占/确认/释放边界。
- 幂等键重复请求行为。

### 16.2 集成测试
- 下单 -> 预占 -> 支付 -> 履约 全链路。
- 支付重复回调幂等验证。
- 超时取消与库存释放一致性。

### 16.3 压测
- 秒杀热点 SKU 压测（100k req/s）。
- 下单高峰 200k QPS 压测。
- MQ 积压与消费恢复压测。

### 16.4 故障注入
- 库存服务短时不可用。
- 支付回调延迟/丢失。
- 订单库主从切换。

## 17. 丰富例子（至少 10 个）
1. 秒杀瞬时流量暴涨，通过限流+排队保护库存服务。  
2. 用户重复点击“提交订单”，幂等键返回同一订单号。  
3. 支付成功回调重复两次，订单只变更一次。  
4. 支付超时 15 分钟自动取消并释放库存。  
5. 同一订单多仓拆单，分别履约发货。  
6. 热门 SKU 出现热点，采用分片库存计数降低热点。  
7. 促销规则变更导致金额差异，下单前再核价校验。  
8. 对账发现差异，补偿任务修复“支付成功未置 PAID”。  
9. 退款通过后库存按业务规则决定是否回补。  
10. 风控识别异常设备，拦截高风险订单。  
11. 通知系统积压时，主订单流程仍成功，不阻塞交易。  
12. 订单状态页提示“支付处理中”，避免用户重复支付。  

## 18. 面试追问 + 可复述回答
### Q1：如何防止超卖？
可复述：  
“库存扣减采用原子条件更新（available>=qty），并先预占后确认，超时自动释放。”

### Q2：订单和库存如何保持一致？
可复述：  
“本地事务保证单服务一致，跨服务用 Saga 和补偿，关键事件用 outbox+幂等消费。”

### Q3：支付回调重复怎么办？
可复述：  
“以 paymentTxnId 做幂等键，重复回调只记录不重复改状态。”

### Q4：秒杀怎么抗峰值？
可复述：  
“入口限流、排队削峰、异步下单、热点隔离，优先保障核心库存服务稳定。”

### Q5：订单超时取消会不会误杀已支付订单？
可复述：  
“取消前要锁单并二次校验状态，若已支付则不取消并转支付补偿流程。”

### Q6：为什么要对账？
可复述：  
“分布式链路不可能零误差，对账是发现并修复异常的最后保险。”

## 19. 新手学习路线
### 第 1 周：核心交易链路
- 做订单创建、订单查询、状态机。
- 做库存预占和释放。

### 第 2 周：支付与补偿
- 接支付回调，处理幂等。
- 做支付超时取消任务。

### 第 3 周：高峰治理
- 加限流、排队、热点库存优化。
- 做压测和瓶颈定位。

### 第 4 周：运营与风控
- 加通知、审计、对账和异常修复任务。
- 准备面试话术：超卖防护+补偿闭环。

## 20. 上场前 Checklist
- [ ] 我能画出下单到履约的完整状态机。  
- [ ] 我能说清库存预占、确认、释放三种状态。  
- [ ] 我能解释幂等键在下单和支付回调中的作用。  
- [ ] 我能给出至少 3 个交易链路告警阈值。  
- [ ] 我能描述一次支付异常的补偿修复流程。  
- [ ] 我能讲清秒杀流量治理策略。  
- [ ] 我能说明为什么要对账以及如何对账。  
- [ ] 我能展示前端下单防重和状态轮询逻辑。  

## 21. 30 秒总结
电商系统高分答案是：  
“用订单状态机管理全生命周期，用库存预占防超卖，用幂等和补偿保证跨服务正确性，用限流削峰扛住大促峰值，用对账兜底修复分布式异常。”  
把这句话落到表结构、流程、阈值和代码，你的面试表达就会很有实战感。  
