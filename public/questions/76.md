## 1. 题目元信息（先读源数据）
- title: Design Blockchain-Based System
- tags: 区块链、共识算法、智能合约、加密、分布式账本
- keyPoints: PoW/PoS共识、默克尔树、智能合约、钱包安全、交易验证
- learningCoreId: 90

## 2. 题目重述
设计一个区块链系统，支持交易上链、共识出块、状态查询、合约执行，并在节点故障与网络分区下保持可用与可恢复。

## 3. 目标与非目标
- 目标: 去中心化记账、可验证、防篡改、可审计、可恢复。
- 非目标: 不追求“无限 TPS”，不在首版支持复杂跨链协议。

## 4. 业务接口
- `POST /v1/tx`: 提交交易（带幂等键）。
- `GET /v1/tx/{hash}`: 查交易状态（pending/confirmed/failed）。
- `GET /v1/block/{height}`: 查区块。
- `POST /v1/contract/{addr}/call`: 合约只读调用。
- `POST /v1/contract/{addr}/send`: 合约写交易。

## 5. 核心数据模型
- Transaction: `hash, from, to, nonce, gas, payload, signature, status`。
- Block: `height, prevHash, txRoot, stateRoot, proposer, timestamp, signatures`。
- Account/State: `balance, nonce, storageRoot`。
- Mempool 索引: `sender+nonce`、`fee`、`arrivalTime`。

## 6. 架构分层
- P2P 网络层: 节点发现、gossip、反熵同步。
- 共识层: PoS+BFT（可替换）。
- 执行层: 交易校验、状态机、合约 VM。
- 存储层: 区块冷热分层、状态快照、WAL。
- API 网关层: 鉴权、限流、幂等、防重放。

## 7. 交易生命周期
1. 客户端签名并附 `idempotencyKey` 提交。
2. 节点验签、验 nonce、验余额，进入 mempool。
3. proposer 打包候选块，广播提议。
4. 验证节点投票确认（2f+1）。
5. 区块提交后写 WAL + 状态树更新 + 事件发布。
6. 回执返回 `confirmations`，客户端轮询/订阅确认深度。

## 8. 共识与最终性
- PoW: 简单但能耗高、确认慢。
- PoS+BFT: 能耗低、可提供更快最终性。
- 选型: 生产建议 PoS+BFT，目标 3~8 秒最终确认。
- 安全参数: 验证者质押、双签惩罚、epoch 轮转。

## 9. 存储与索引
- 区块: append-only 文件 + 高度索引。
- 状态: Merkle Patricia Trie / SMT。
- 查询: TxHash、Address、Height、Topic 二级索引。
- 归档策略: 热数据 30 天 SSD，冷数据对象存储。

## 10. 安全设计
- 钱包安全: HSM/KMS 托管热密钥，冷签分离。
- 交易安全: EIP-155 风格链 ID 防重放。
- 节点安全: mTLS、节点信誉分、黑名单与速率限制。
- 合约安全: 白名单 opcode、gas 上限、重入检测。

## 11. 阈值、SLO 与故障恢复路径（含 RTO/RPO）
- SLO 阈值:
1. `P99 提交接口延迟 <= 300ms`
2. `交易入池成功率 >= 99.95%`
3. `最终确认时间 P95 <= 8s`
4. `节点可用性 >= 99.99%`
- 告警阈值:
1. mempool backlog > 200k 持续 5 分钟
2. 出块间隔 > 2 倍基线持续 3 个区块
3. 共识投票失败率 > 1%
- 故障恢复路径:
1. 单节点故障: 自动摘流量 -> 重启进程 -> 回放 WAL -> 追块补齐。
2. 可用区故障: 切换到同城多 AZ 验证者集群，重新选主 proposer。
3. 链分叉异常: 停止出块 -> 以 finalized checkpoint 回滚 -> 状态重放 -> 恢复广播。
4. 状态库损坏: 从最近快照恢复 + 增量区块回放。
- RTO/RPO:
1. 单节点: `RTO <= 5 分钟`, `RPO = 0`
2. 单 AZ: `RTO <= 15 分钟`, `RPO <= 1 区块`
3. 区域级容灾: `RTO <= 45 分钟`, `RPO <= 5 区块`

## 12. 扩展性与性能
- 分片: 按账户/合约地址分片，跨片走异步消息。
- 执行并行: 乐观并行执行 + 冲突检测回滚。
- 网络: block/tx 分通道传播，优先传播头部与证明。
- 成本: 动态 fee 市场抑制拥堵。

## 13. 可观测性与运维
- 指标: 出块间隔、最终性延迟、mempool 深度、重组深度。
- 日志: 交易轨迹日志 + 共识投票审计日志。
- Trace: 交易从提交到确认全链路 traceId。
- Runbook: 节点失联、分叉、快照损坏三类预案。

## 14. 关键权衡
- 去中心化 vs 吞吐: 验证者越多，共识消息复杂度越高。
- 最终性速度 vs 安全阈值: 快速确认需要更严格罚没与网络质量。
- 链上执行 vs 链下处理: 链上强一致，链下高吞吐但需证明回链。

## 15. Java 实现要点（>=5）
```java
public final class TxValidator {
    public ValidationResult validate(Transaction tx, AccountState state) {
        if (!SignatureVerifier.verify(tx.payloadHash(), tx.signature(), tx.from())) {
            return ValidationResult.reject("BAD_SIGNATURE");
        }
        if (tx.nonce() != state.nonce() + 1) {
            return ValidationResult.reject("BAD_NONCE");
        }
        if (state.balance().compareTo(tx.maxCost()) < 0) {
            return ValidationResult.reject("INSUFFICIENT_BALANCE");
        }
        return ValidationResult.accept();
    }
}
```

```java
public final class IdempotencyStore {
    private final ConcurrentMap<String, String> resultByKey = new ConcurrentHashMap<>();

    public Optional<String> get(String key) {
        return Optional.ofNullable(resultByKey.get(key));
    }

    public String recordIfAbsent(String key, Supplier<String> producer) {
        return resultByKey.computeIfAbsent(key, k -> producer.get());
    }
}
```

```java
public final class MerkleRootBuilder {
    public byte[] build(List<byte[]> leaves) {
        List<byte[]> level = new ArrayList<>(leaves);
        while (level.size() > 1) {
            List<byte[]> next = new ArrayList<>();
            for (int i = 0; i < level.size(); i += 2) {
                byte[] left = level.get(i);
                byte[] right = (i + 1 < level.size()) ? level.get(i + 1) : left;
                next.add(Hash.sha256(Bytes.concat(left, right)));
            }
            level = next;
        }
        return level.get(0);
    }
}
```

```java
public final class ConsensusQuorum {
    private final int f;

    public ConsensusQuorum(int byzantineTolerance) {
        this.f = byzantineTolerance;
    }

    public boolean committed(int voteCount, int validatorCount) {
        int threshold = 2 * f + 1;
        return voteCount >= threshold && validatorCount >= (3 * f + 1);
    }
}
```

```java
public final class SnapshotRecovery {
    public RecoveryResult recover(Path snapshot, Path walDir) throws IOException {
        StateStore state = SnapshotLoader.load(snapshot);
        List<WalEntry> entries = WalReader.readAll(walDir);
        for (WalEntry e : entries) {
            state.apply(e.toStateTransition());
        }
        return new RecoveryResult(state.latestHeight(), state.stateRoot());
    }
}
```

## 16. React JavaScript 实现（>=2，含 API+成功失败分支+状态+轮询/重试/幂等/降级）
```javascript
import { useEffect, useRef, useState } from "react";

export function SubmitTxPanel() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [done, setDone] = useState(false);
  const [txHash, setTxHash] = useState("");
  const idemKeyRef = useRef(`idem-${Date.now()}`);

  async function submitTx(payload) {
    setLoading(true); setError(""); setDone(false);
    try {
      const res = await fetch("/v1/tx", {
        method: "POST",
        headers: { "Content-Type": "application/json", "Idempotency-Key": idemKeyRef.current },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error(`submit failed: ${res.status}`);
      const data = await res.json();
      setTxHash(data.hash);
      setDone(true);
    } catch (e) {
      setError(e.message);
      // 降级: 本地缓存待提交交易，稍后手动重放
      localStorage.setItem("lastFailedTx", JSON.stringify(payload));
    } finally {
      setLoading(false);
    }
  }

  return <button disabled={loading} onClick={() => submitTx({ to: "0xabc", amount: "1" })}>{loading ? "submitting" : "submit"}</button>;
}
```

```jsx
import { useEffect, useState } from "react";

export function TxStatusWatcher({ txHash }) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [done, setDone] = useState(false);
  const [status, setStatus] = useState("pending");

  useEffect(() => {
    if (!txHash) return;
    let stop = false;
    let timer = null;
    let retry = 0;

    async function poll() {
      setLoading(true); setError("");
      try {
        const res = await fetch(`/v1/tx/${txHash}`);
        if (!res.ok) throw new Error(`query failed: ${res.status}`);
        const data = await res.json();
        setStatus(data.status);
        if (data.status === "confirmed") {
          setDone(true);
          stop = true;
        }
        retry = 0;
      } catch (e) {
        setError(e.message);
        retry += 1;
        if (retry > 5) stop = true; // 重试上限，避免无限放大
      } finally {
        setLoading(false);
        if (!stop) timer = setTimeout(poll, Math.min(3000 * (retry + 1), 10000)); // 轮询+退避重试
      }
    }

    poll();
    return () => { stop = true; if (timer) clearTimeout(timer); };
  }, [txHash]);

  return <div>{loading ? "loading" : error ? `error:${error}` : done ? "done" : status}</div>;
}
```

## 17. 面试追问与答法
- 为什么需要幂等键: 防止客户端重试导致重复交易。
- 为什么要快照+WAL: 降低恢复时间并保证可回放一致性。
- 如何解释 finality: “被后续区块覆盖概率可忽略”或“BFT 已不可逆”。

## 18. 丰富例子（>=10）
1. 交易提交成功但回执超时，客户端用同一幂等键重试，服务端返回同一 txHash。
2. 验签失败交易进入拒绝队列并打审计日志，不入池。
3. nonce 间隙交易先挂起，待前序交易确认后自动激活。
4. proposer 宕机时在 2 个区块周期内完成轮转。
5. 单节点磁盘损坏后从最近快照+WAL 在 4 分钟内恢复。
6. 网络抖动导致投票不足时，触发 view change 并继续出块。
7. mempool 积压时提高最低 fee 阈值，低费交易延后。
8. 合约执行超 gas，状态回滚但消耗基础 gas。
9. 轻节点通过默克尔证明验证交易存在性。
10. 区块浏览器查询热地址时走二级索引缓存，P99 降到 120ms。
11. 发现分叉深度异常时暂停对外“最终确认”标记，待 checkpoint 对齐后恢复。
12. 跨片转账采用两阶段消息，失败时触发补偿解锁。

## 19. 常见错误
- 把“上链成功”当“最终确认”。
- 忽略 nonce 并发导致双花窗口。
- 无幂等键直接重试提交接口。
- 只做多副本，不做恢复演练与回放校验。

## 20. 最小可落地版本（MVP）
- 5~7 个验证节点，PoS+BFT。
- 仅支持转账和简单合约调用。
- 提供 tx 提交/查询、区块查询、节点健康检查。
- 启用快照+WAL+单区容灾，先达成可恢复再扩 TPS。

## 21. 评分与结论
- 架构完整性: 24/25
- 一致性与安全: 24/25
- 可扩展与性能: 23/25
- 可运维与容灾: 25/25
- 总分：96/100

## 22. 与母题差异
- 母题 `learningCoreId=90` 偏“去中心化与P2P网络通用框架”；本题更强调区块链账本、交易执行与经济安全。
- 本题新增必补知识:
1. 共识最终性与分叉恢复策略（checkpoint 回滚与重放）。
2. 交易 nonce/签名/幂等键三重防重复机制。
3. Merkle 证明与状态根校验链路。
4. 智能合约执行安全（gas、重入、沙箱限制）。
5. 质押与惩罚机制对安全阈值的影响。
6. 快照+WAL 的链上状态恢复工程化方案。
7. 跨片/跨域消息的一致性补偿设计。
