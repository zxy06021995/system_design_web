# Q48 Image Hosting (图片托管)

> 来源校验（questions.ts）  
> `title`: Image Hosting (图片托管)  
> `tags`: 对象存储, 图片处理, CDN, 缩略图, 去重  
> `keyPoints`: 上传链路优化, 异步处理流水线, CDN缓存策略, 访问鉴权, 成本优化  
> `learningCoreId`: 22（母题：视频流系统）

## 1. 三句话题目本质
1. 图片托管题本质是“高效上传、可靠存储、低延迟分发”。
2. 难点是上传峰值、处理异步化、CDN 缓存一致性和成本控制。
3. 高分回答要讲清：上传链路、处理流水线、访问鉴权、缓存策略和治理指标。

## 2. 一个真实场景故事
某社区平台用户日上传 3000 万张图，晚高峰上传失败率曾达到 4%。问题是服务端直传导致应用层带宽和 CPU 打满。改成客户端直传对象存储 + 回调处理流水线后，上传成功率升到 99.95%，并通过多尺寸缩略图和 WebP 转码把带宽成本下降 28%。

## 3. 术语白话表（>=10）
1. Pre-signed URL：预签名上传地址。
2. Multipart Upload：分片上传大文件。
3. Object Storage：对象存储（如 S3）。
4. CDN Cache Key：CDN 缓存键规则。
5. Derivative：图片衍生版本（缩略图、水印图）。
6. Content Hash：内容哈希，用于去重。
7. EXIF Strip：移除敏感元数据。
8. Hotlink Protection：防盗链。
9. Lifecycle Policy：存储生命周期策略。
10. Origin Shield：源站保护节点。
11. Soft Delete：软删除可恢复。
12. Purge：缓存主动失效。

## 4. 需求澄清（功能/非功能/不做范围/SLO）
### 4.1 功能需求
1. 支持图片上传、查询、删除。
2. 支持异步生成多尺寸缩略图和格式转换。
3. 支持全球 CDN 分发。
4. 支持访问鉴权与防盗链。
5. 支持去重与生命周期管理。

### 4.2 非功能需求
1. 上传高可用、分发低延迟。
2. 存储安全与数据可靠。
3. 成本可控（带宽+存储+处理）。
4. 处理流水线可扩展。

### 4.3 不做范围
1. 不做视频转码完整能力。
2. 不做复杂编辑器能力（滤镜、裁剪 UI）。
3. 不做 AI 内容审核全流程。

### 4.4 SLO
1. 上传成功率 >= 99.95%。
2. 图片首字节延迟 P95 <= 120ms（CDN 命中）。
3. 缩略图处理完成 P95 <= 5 秒。

## 5. 容量估算（数字推导）
1. 日上传 3000 万张，平均 350KB，约 `10.5TB/day` 原图。
2. 衍生图平均 3 份，按 0.4 倍体积估算，约 `12.6TB/day`。
3. 总新增约 `23.1TB/day`，30 天热存储约 693TB。
4. 峰值上传 1.2 万 QPS，处理队列峰值 2 万 job/s。
5. CDN 日请求 15 亿次，命中率目标 >= 92%。
6. 结论：必须直传+异步处理+冷热分层，否则成本与吞吐都不可控。

## 6. 架构（简版+完整版）
### 6.1 简版
`Client -> Upload API -> Object Storage -> CDN`

### 6.2 完整版
1. Upload API：签发预签名 URL、记录元数据。
2. Object Storage：原图存储。
3. Event Bus：上传完成事件入队。
4. Image Processor：压缩、转码、缩略图、水印。
5. Metadata Service：管理图片状态和衍生图映射。
6. CDN：全球分发与缓存策略。
7. Auth Service：访问令牌、防盗链校验。
8. Lifecycle Worker：冷热迁移与清理归档。

## 7. API 设计（请求/响应/错误码/幂等）
### 7.1 获取上传凭证
`POST /api/image/v1/upload-token`

响应：
```json
{
  "imageId": "img_1001",
  "uploadUrl": "https://object-store/...sig=...",
  "expireAt": "2026-02-24T10:20:00Z"
}
```

### 7.2 上传完成回调
`POST /api/image/v1/complete`

### 7.3 查询图片
`GET /api/image/v1/{imageId}?size=thumb_320`

错误码：
1. `400_INVALID_IMAGE_TYPE`
2. `401_TOKEN_EXPIRED`
3. `404_IMAGE_NOT_READY`
4. `429_UPLOAD_RATE_LIMITED`

幂等规则：
1. `complete` 使用 `uploadId` 幂等，重复回调不重复入队。
2. 删除接口使用 `requestId` 防重删。

## 8. 数据模型（实体/索引/分片）
1. `image_meta(image_id, owner_id, hash, state, origin_key, created_at)`。
2. `image_variant(image_id, variant, object_key, width, height, size)`。
3. `upload_session(upload_id, image_id, state, expire_at)`。
4. `image_audit(audit_id, actor, action, image_id, ts)`。
5. `cdn_purge_task(task_id, image_id, status, created_at)`。

索引策略：
1. `hash` 唯一索引支持去重命中。
2. `owner_id + created_at` 支持用户图片列表分页。
3. `image_id + variant` 唯一索引快速定位衍生图。

## 9. 核心流程（正常/高峰/故障恢复）
### 9.1 正常流程
1. 客户端请求上传 token。
2. 客户端直传对象存储。
3. 回调触发异步处理，生成衍生图并可 CDN 访问。

### 9.2 高峰流程
1. 上传服务仅做签名与元数据，避免传输瓶颈。
2. 处理队列按优先级（头像>相册）调度。
3. 非关键变体延迟生成，优先保障原图可访问。

### 9.3 故障恢复流程
1. 处理服务故障时保留原图访问能力。
2. 队列恢复后批量补生成衍生图。
3. CDN 异常时回源对象存储并降级限流。

## 10. 一致性与事务边界
1. 元数据状态与对象落地采用最终一致。
2. 上传完成回调成功后状态从 `UPLOADED` -> `PROCESSING`。
3. 处理失败可重试，超过阈值转 `FAILED` 并可人工重跑。
4. 删除流程：先逻辑删，再异步物理删和 CDN purge。
5. 去重命中要校验权限，避免跨租户泄漏。

## 11. 可用性与容错（含 RTO/RPO）
1. 对象存储多副本保障 durability。
2. 处理服务无状态可横向扩容。
3. 队列堆积时启用弹性消费者。
4. RTO：处理链路 15 分钟恢复。
5. RPO：原图不丢；衍生图可重建。

## 12. 可观测性（指标+阈值+处置动作）
1. `upload_success_rate` < 99.95%：排查签名服务和存储网关。
2. `process_queue_lag_sec` > 60：扩容处理 worker。
3. `variant_ready_p95_sec` > 5：降级非关键变体。
4. `cdn_hit_ratio` < 92%：优化缓存键与 TTL。
5. `origin_5xx_rate` > 1%：启用源站保护与限流。
6. `dedup_false_positive_rate` 异常：排查 hash 与元数据逻辑。

## 13. 安全与合规
1. 上传 token 短时有效并绑定对象 key。
2. 链接访问需签名或权限校验。
3. EXIF 清洗避免隐私泄露。
4. 防盗链与防刷策略。
5. 删除合规：可追溯并按法规清除。

## 14. 成本与取舍
1. 多变体生成体验好但处理成本高。
2. 长时间热存储查询快但昂贵。
3. 高 CDN 命中降低回源成本但需更精细缓存治理。
4. 取舍：热图热存，冷图归档；按访问热度动态生成变体。

## 15. Java 关键代码（>=5段）
### 15.1 核心算法/状态转移：上传状态机
```java
public void transit(String imageId, ImageState from, ImageState to) {
    if (!fsm.canTransit(from, to)) throw new IllegalStateException("invalid state");
    metaRepo.updateState(imageId, to.name());
}
```

### 15.2 幂等去重：complete 回调
```java
public void completeUpload(String uploadId, String imageId) {
    if (uploadRepo.isCompleted(uploadId)) return;
    uploadRepo.markCompleted(uploadId);
    queueProducer.send(new ProcessTask(imageId));
}
```

### 15.3 重试退避/失败处理：处理任务
```java
public void processWithRetry(ProcessTask task, int attempt) {
    try {
        processor.generateVariants(task.imageId());
    } catch (RuntimeException ex) {
        if (attempt >= 5) {
            metaRepo.markFailed(task.imageId(), ex.getMessage());
            dlqRepo.save(task.imageId(), ex.getMessage());
            return;
        }
        long delay = Math.min(2000, (1L << attempt) * 100L);
        retryQueue.enqueue(task, attempt + 1, delay);
    }
}
```

### 15.4 一致性边界：逻辑删+异步物理删
```java
@Transactional
public void deleteImage(String imageId, String actor) {
    metaRepo.markDeleted(imageId);
    auditRepo.insert(actor, "DELETE_IMAGE", imageId);
    outboxRepo.insert("IMAGE_DELETE", imageId);
}
```

### 15.5 观测触发/回滚判定
```java
public void guardPipeline() {
    long lag = metrics.gauge("process_queue_lag_sec").longValue();
    if (lag > 60) {
        scaler.scaleOut("image-processor");
        alerting.fire("IMAGE_PROCESS_LAG_HIGH", "lag=" + lag);
    }
    double hit = metrics.gauge("cdn_hit_ratio").value();
    if (hit < 0.92) cachePolicyOptimizer.tune();
}
```

## 16. 前端功能代码（React JS，仅 API 协作）
### 16.1 上传流程 API（loading/error/done）
```javascript
import { useState } from "react";

export function useImageUpload() {
  const [state, setState] = useState({ phase: "idle", imageId: "", error: "" });

  async function upload(file) {
    setState({ phase: "loading", imageId: "", error: "" });
    try {
      const tokenRes = await fetch("/api/image/v1/upload-token", { method: "POST" });
      if (!tokenRes.ok) throw new Error(`HTTP_${tokenRes.status}`);
      const token = await tokenRes.json();
      const putRes = await fetch(token.uploadUrl, { method: "PUT", body: file });
      if (!putRes.ok) throw new Error(`UPLOAD_${putRes.status}`);
      const doneRes = await fetch("/api/image/v1/complete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ uploadId: token.uploadId, imageId: token.imageId })
      });
      if (!doneRes.ok) throw new Error(`COMPLETE_${doneRes.status}`);
      setState({ phase: "done", imageId: token.imageId, error: "" });
    } catch (e) {
      setState({ phase: "error", imageId: "", error: String(e.message || e) });
    }
  }
  return { state, upload };
}
```

### 16.2 删除图片 API（幂等+重试）
```javascript
export async function deleteImage(imageId) {
  const reqId = `del-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  let delay = 120;
  for (let i = 0; i < 3; i++) {
    try {
      const res = await fetch(`/api/image/v1/${imageId}`, {
        method: "DELETE",
        headers: { "X-Idempotency-Key": reqId }
      });
      if (!res.ok) throw new Error(`HTTP_${res.status}`);
      return { ok: true };
    } catch (err) {
      if (i === 2) return { ok: false, error: String(err.message || err) };
      await new Promise((r) => setTimeout(r, delay));
      delay = Math.min(delay * 2, 900);
    }
  }
}
```

## 17. 测试策略
1. 单元测试：状态机、去重、变体生成策略。
2. 集成测试：直传->回调->处理->分发全链路。
3. 压测：上传峰值、处理队列峰值、CDN 查询峰值。
4. 故障测试：对象存储抖动、处理失败、CDN 回源故障。
5. 回归测试：删除合规、鉴权、防盗链策略。

## 18. 丰富例子（>=10）
1. 用户上传头像秒级可见。
2. 大图自动生成 3 种缩略图。
3. 重复图片通过 hash 命中去重。
4. 处理队列积压时只生成关键尺寸。
5. 某地域 CDN 故障切回源站。
6. 恶意盗链被签名校验拦截。
7. EXIF 清理去掉地理位置信息。
8. 删除后链接短时间失效并异步清理。
9. 热门图片 CDN 命中率提升到 95%。
10. 归档策略把 90 天未访问图转冷存。
11. 上传 token 过期返回重签流程。
12. 回补任务重跑失败变体并修复状态。

## 19. 面试追问 + 可复述回答
1. 为什么推荐直传对象存储？
回答：减少应用层带宽瓶颈，上传服务只做签名和元数据管理。
2. 图片处理为什么异步？
回答：同步处理会拉高上传延迟，异步可削峰并重试。
3. 如何做去重又防越权？
回答：内容 hash 去重时必须结合租户权限校验。
4. CDN 缓存失效怎么做？
回答：版本化 URL 优先，必要时精确 purge。
5. 与视频流母题区别？
回答：图片更关注上传与静态分发，不涉及长时播放和码率自适应。

## 20. 新手学习路线
1. 先做上传 token + 直传。
2. 增加异步处理和缩略图。
3. 接入 CDN 与访问鉴权。
4. 增加去重、删除和生命周期。
5. 做峰值压测与成本优化。

## 21. 上场前 Checklist
1. 能讲清直传与回调流程。
2. 能解释异步处理重试策略。
3. 能给出 CDN 命中率和队列积压阈值。
4. 能说出去重和安全边界。
5. 能讲明与母题 Q22 的差异。

## 22. 与母题差异（对应母题/共性/差异/新增知识/话术）
### 22.1 对应母题
Q22 视频流系统。

### 22.2 共性能力
1. 都有媒体存储与 CDN 分发。
2. 都强调异步处理流水线。
3. 都需要成本和体验平衡。

### 22.3 关键差异
1. Q22 重点是转码播放链路；Q48 重点是上传与图片变体。
2. Q48 延迟目标偏上传和首图加载，不是播放卡顿。
3. Q48 处理复杂度低于视频，但请求量更高更碎片化。
4. Q48 去重、盗链、防隐私泄露更突出。
5. Q48 更依赖 CDN 图片缓存策略与 URL 版本化。

### 22.4 本题新增知识点（>=5）
1. 预签名直传上传架构。
2. 图片衍生图异步生成策略。
3. 内容 hash 去重与权限边界。
4. CDN 缓存键与 purge 策略。
5. EXIF 清理与隐私合规。
6. 生命周期冷热分层降本。

### 22.5 面试差异话术
“Q22 讲视频播放与转码系统；Q48 讲图片上传与分发平台，核心在直传、异步处理、CDN 缓存与成本治理。”

---

## 单题自审（Q48）
### A. 完整性检查
1. 22 节完整：通过。
2. Java 代码段 5 段：通过。
3. React JS API 代码 2 段：通过。

### B. 易懂性检查
1. 术语白话 >=10：通过。
2. 正常/高峰/故障流程完整：通过。

### C. 专属性检查
1. 聚焦图片托管，不模板化：通过。
2. 上传链路、处理流水线、CDN 策略完整：通过。

### D. 工程落地检查
1. 阈值与动作绑定：通过。
2. RTO/RPO 与降级路径明确：通过。

### E. 代码相关性检查
1. Java 五类点位覆盖：通过。
2. 前端满足 API/状态流转/重试幂等：通过。

### F. 母题差异检查
1. 与 Q22 差异具体：通过。

### 自评分（100）
1. 完整性：20/20
2. 易懂性：19/20
3. 面试可讲性：19/20
4. 技术深度：19/20
5. 工程落地性：19/20

总分：96/100（通过）
