# Q85：Design Inventory Management System（重写达标版）

## 1. 题目元数据（先读 questions.ts）
- `title`: `Design Inventory Management System`
- `tags`: `库存管理`、`库存扣减`、`预占`、`防超卖`、`库存同步`
- `keyPoints`: `库存预占`、`分布式锁`、`库存同步`、`防超卖`、`库存预警`
- `learningCoreId`: `83`（由 `fineCategoryById[85]='电商交易与库存系统'` 与 `coreByFineCategory['电商交易与库存系统']=83` 得出）

## 2. 目标与非目标
- 目标：保证库存扣减正确、防超卖、可恢复、可观测。
- 目标：支持高并发预占、支付确认扣减、超时回补。
- 非目标：不做跨全球多活强一致库存；采用单区域强一致+跨区最终一致。

## 3. 需求澄清
- 功能：查询库存、预占库存、确认扣减、释放预占、库存同步、告警与审计。
- 非功能：`P95 <= 120ms`（预占接口），可用性 `>=99.95%`，超卖率 `<= 1e-6`。
- 数据要求：库存变更全量留痕，可按订单/sku 回放修复。

## 4. 容量与压测基线
- 峰值下单请求：`30k QPS`，其中预占请求占 `70%`。
- SKU 规模：`5000万`，热点 SKU 占流量 `15%`。
- 预占记录保留：`48h`，日新增约 `18亿` 条，冷热分层存储。
- 压测目标：2 倍峰值持续 30 分钟，错误率 < `0.5%`。

## 5. 架构总览
```text
Client -> API Gateway -> Inventory Command Service -> MySQL(分片)
                                  |-> Redis(库存快照/热点计数)
                                  |-> Kafka(库存事件流)
                                  |-> Outbox Relay
                                  |-> Reconcile Worker / Timeout Release Worker
Query API -> Read Replica / ES(可选)
Observability -> Prometheus + Grafana + Alertmanager + Audit Log
```

## 6. 数据模型
- `inventory(sku_id, warehouse_id, available, reserved, sold, version, updated_at)`
- `reservation(reservation_id, order_id, sku_id, qty, status, expire_at, idem_key, created_at)`
- `inventory_txn(txn_id, sku_id, type, qty, ref_id, before_qty, after_qty, created_at)`
- 索引：
1. `inventory (sku_id, warehouse_id)` unique
2. `reservation (order_id, sku_id)` unique
3. `reservation (status, expire_at)` for timeout scan
4. `inventory_txn (ref_id, type)` for幂等与审计

## 7. API 设计
1. `POST /api/inventory/reserve`
请求：`{orderId, skuId, qty, idemKey}`
响应：成功 `{reservationId,status:"RESERVED"}`；失败 `{code:"INSUFFICIENT_STOCK"}`
2. `POST /api/inventory/confirm`
请求：`{reservationId, paymentId, idemKey}`
响应：成功 `{status:"CONFIRMED"}`；失败 `{code:"RESERVATION_EXPIRED"}`
3. `POST /api/inventory/release`
请求：`{reservationId, reason, idemKey}`
响应：成功 `{status:"RELEASED"}`
4. `GET /api/inventory/{skuId}`
响应：`{available,reserved,sold,updatedAt}`

## 8. 主流程
1. 下单预占：校验幂等 -> 扣减 `available`、增加 `reserved` -> 写预占记录。
2. 支付成功确认：校验预占状态 -> `reserved` 转 `sold` -> 发库存变更事件。
3. 支付超时释放：扫描到期预占 -> `reserved` 回补 `available` -> 记录释放事务。

## 9. 一致性与事务边界
- 单库内：`inventory + reservation + outbox` 同事务提交。
- 跨服务：Outbox + Kafka 至少一次投递 + 消费端幂等。
- 幂等键规则：`tenantId:orderId:action`，TTL 72h，重复请求直接回放结果。
- 冲突控制：乐观锁 `version` + 热点 SKU 分桶锁。

## 10. 并发与缓存策略
- 读路径：Redis 缓存库存快照，TTL 3s，热点键主动刷新。
- 写路径：数据库为准，写后删缓存（延迟双删）防脏读。
- 防击穿：热点 SKU 使用互斥重建 + 本地短缓存。
- 降级：Redis 故障时直读 DB，并对查询接口限流到 `5k QPS`。

## 11. 阈值与告警规则
- `reserve_p95_ms > 120` 持续 5 分钟：P1。
- `reserve_error_rate > 0.8%` 持续 3 分钟：P1。
- `oversell_count > 0` 任意 1 分钟窗口：P0。
- `reservation_timeout_backlog > 200万`：P1，启动紧急扩容 worker。
- `kafka_lag > 100万` 持续 10 分钟：P1，启用消费降级和批量补偿。

## 12. 故障恢复路径（含 RTO/RPO）
- 目标：
1. 库存服务主可用区故障：`RTO <= 15 分钟`，`RPO <= 30 秒`
2. 消息系统故障：`RTO <= 20 分钟`，`RPO <= 60 秒`
3. 读缓存全故障：`RTO <= 5 分钟`，`RPO = 0`（缓存可重建）
- 恢复路径：
1. 告警触发 -> 值班执行 Runbook：切流到同城灾备、冻结高风险写操作。
2. 启动库存快照校验任务：按 `sku_id` 比对 `inventory` 与 `inventory_txn`。
3. 回放 Outbox 未投递事件，修复 Kafka lag。
4. 执行 `reservation` 到期补偿扫描，补齐超时释放。
5. 完成对账后解冻写流量，恢复正常限流阈值。

## 13. 可观测与审计
- 指标：QPS、P95、错误率、超卖数、预占转化率、释放延迟、MQ lag。
- 日志：所有库存变更记录 `traceId/orderId/skuId/operator`。
- 追踪：预占到确认全链路 Trace，便于定位慢点与重复扣减。
- 审计：人工改库存必须双人审批，且保留前后镜像与原因。

## 14. 安全与合规
- 接口鉴权：服务间 mTLS + JWT，最小权限 RBAC。
- 防重放：幂等键 + 时间窗签名 + nonce。
- 数据保护：关键表字段加密存储，审计日志不可篡改。
- 风控联动：异常高频扣减自动触发风控二次校验。

## 15. Java 关键代码（>=5）
```java
public class IdempotencyService {
    private final ConcurrentHashMap<String, String> cache = new ConcurrentHashMap<>();

    public boolean tryStart(String key) {
        return cache.putIfAbsent(key, "PROCESSING") == null;
    }

    public void markDone(String key, String resultJson) {
        cache.put(key, resultJson);
    }

    public Optional<String> replay(String key) {
        String value = cache.get(key);
        if (value == null || "PROCESSING".equals(value)) {
            return Optional.empty();
        }
        return Optional.of(value);
    }
}
```

```java
public class InventoryReserveService {
    public ReservationResult reserve(long skuId, int qty, String orderId, String idemKey) {
        InventoryRow row = inventoryRepo.findForUpdate(skuId);
        if (row.getAvailable() < qty) {
            throw new IllegalStateException("INSUFFICIENT_STOCK");
        }
        row.setAvailable(row.getAvailable() - qty);
        row.setReserved(row.getReserved() + qty);
        row.setVersion(row.getVersion() + 1);
        inventoryRepo.update(row);

        Reservation reservation = Reservation.create(orderId, skuId, qty, idemKey, Duration.ofMinutes(15));
        reservationRepo.insert(reservation);
        outboxRepo.append("INVENTORY_RESERVED", reservation.getReservationId());
        return ReservationResult.success(reservation.getReservationId());
    }
}
```

```java
public class InventoryConfirmService {
    public ConfirmResult confirm(String reservationId, String paymentId) {
        Reservation r = reservationRepo.findForUpdate(reservationId);
        if (!"RESERVED".equals(r.getStatus())) {
            return ConfirmResult.ignored(r.getStatus());
        }
        InventoryRow row = inventoryRepo.findForUpdate(r.getSkuId());
        row.setReserved(row.getReserved() - r.getQty());
        row.setSold(row.getSold() + r.getQty());
        inventoryRepo.update(row);

        r.setStatus("CONFIRMED");
        reservationRepo.update(r);
        outboxRepo.append("INVENTORY_CONFIRMED", reservationId + ":" + paymentId);
        return ConfirmResult.ok(reservationId);
    }
}
```

```java
public class TimeoutReleaseWorker {
    public int releaseExpired(Instant now) {
        List<Reservation> expired = reservationRepo.scanExpired(now, 1000);
        int released = 0;
        for (Reservation r : expired) {
            if (!"RESERVED".equals(r.getStatus())) {
                continue;
            }
            InventoryRow row = inventoryRepo.findForUpdate(r.getSkuId());
            row.setReserved(row.getReserved() - r.getQty());
            row.setAvailable(row.getAvailable() + r.getQty());
            inventoryRepo.update(row);
            r.setStatus("RELEASED");
            reservationRepo.update(r);
            outboxRepo.append("INVENTORY_RELEASED", r.getReservationId());
            released++;
        }
        return released;
    }
}
```

```java
public class ReconcileJob {
    public ReconcileReport run(LocalDate day) {
        List<Long> skuIds = inventoryRepo.findChangedSkuIds(day);
        int fixed = 0;
        int checked = 0;
        for (Long skuId : skuIds) {
            checked++;
            Snapshot db = inventoryRepo.snapshot(skuId);
            Snapshot calc = txnRepo.rebuildSnapshot(skuId, day);
            if (!db.equals(calc)) {
                inventoryRepo.correctTo(calc);
                auditRepo.recordFix(skuId, db, calc, "AUTO_RECONCILE");
                fixed++;
            }
        }
        return new ReconcileReport(checked, fixed, day);
    }
}
```

## 16. React 前端代码（>=2，含 API 成功失败分支 + loading/error/done + 轮询/重试/幂等/降级）
```jsx
import React, { useState } from "react";

export function ReserveButton({ orderId, skuId, qty }) {
  const [status, setStatus] = useState("idle"); // idle/loading/done/error
  const [message, setMessage] = useState("");

  const reserve = async () => {
    setStatus("loading");
    setMessage("");
    const idemKey = `${orderId}:reserve`;

    for (let attempt = 1; attempt <= 3; attempt++) {
      try {
        const res = await fetch("/api/inventory/reserve", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-Idempotency-Key": idemKey },
          body: JSON.stringify({ orderId, skuId, qty, idemKey })
        });
        const data = await res.json();
        if (res.ok) {
          setStatus("done");
          setMessage(`预占成功: ${data.reservationId}`);
          return;
        }
        if (attempt === 3) {
          setStatus("error");
          setMessage(data.code || "预占失败");
          return;
        }
      } catch (e) {
        if (attempt === 3) {
          setStatus("error");
          setMessage("网络异常，重试后仍失败");
          return;
        }
      }
      await new Promise((r) => setTimeout(r, attempt * 300));
    }
  };

  return (
    <div>
      <button onClick={reserve} disabled={status === "loading"}>预占库存</button>
      <div>{status === "loading" ? "loading..." : status}</div>
      {message && <div>{message}</div>}
    </div>
  );
}
```

```javascript
import React, { useEffect, useState } from "react";

export function OrderInventoryStatus({ orderId }) {
  const [status, setStatus] = useState("loading"); // loading/done/error
  const [data, setData] = useState(null);
  const [error, setError] = useState("");

  useEffect(() => {
    let timer = null;
    let stopped = false;

    const poll = async () => {
      setStatus("loading");
      try {
        const primary = await fetch(`/api/orders/${orderId}/inventory-status`);
        if (primary.ok) {
          const body = await primary.json();
          if (!stopped) {
            setData(body);
            setError("");
            setStatus("done");
          }
        } else {
          // 降级到只读聚合接口
          const fallback = await fetch(`/api/read-model/orders/${orderId}/inventory-status`);
          if (fallback.ok) {
            const body = await fallback.json();
            if (!stopped) {
              setData({ ...body, degraded: true });
              setError("");
              setStatus("done");
            }
          } else if (!stopped) {
            setStatus("error");
            setError("主接口与降级接口都失败");
          }
        }
      } catch (e) {
        if (!stopped) {
          setStatus("error");
          setError("请求异常");
        }
      } finally {
        if (!stopped) {
          timer = setTimeout(poll, 3000); // 轮询
        }
      }
    };

    poll();
    return () => {
      stopped = true;
      if (timer) clearTimeout(timer);
    };
  }, [orderId]);

  if (status === "loading") return <div>loading...</div>;
  if (status === "error") return <div>{error}</div>;
  return <pre>{JSON.stringify(data, null, 2)}</pre>;
}
```

## 17. 测试与演练
1. 单元测试：状态机流转、幂等重复请求、乐观锁冲突。
2. 集成测试：预占->确认->回补全链路，含 MQ 重复消息。
3. 压测：热点 SKU 10 倍突发，验证超卖为 0。
4. 混沌演练：DB 主从切换、MQ 阻塞、缓存雪崩。
5. 恢复演练：按 Runbook 在 15 分钟内完成切流与补偿。

## 18. 丰富例子（>=10）
1. 秒杀场景中，热点 SKU 用分桶锁把冲突从全局锁降为局部锁。
2. 用户重复点击“提交订单”，同一 `idemKey` 只会生成一次预占。
3. 支付成功回调重复到达，确认接口返回已处理状态，不重复扣减。
4. 支付超时后自动释放预占，库存回补可见。
5. MQ 消费延迟升高时，先限流非核心接口，保证确认链路。
6. Redis 故障时走 DB 直读并触发查询降级。
7. 发现某 SKU 超卖告警后，立即冻结该 SKU 写入并执行对账修复。
8. 跨仓调拨失败时，记录补偿任务并异步重试。
9. 对账任务发现 `sold` 偏大，依据 `inventory_txn` 回放修正。
10. 大促前扩容 worker 到 3 倍，避免超时释放积压。
11. 审计发现人工改库存异常，基于审计日志回滚并追责。
12. 机房网络抖动时切换到灾备区，RTO 内恢复下单能力。

## 19. 面试追问速答
1. 如何保证不超卖？
答：数据库原子扣减 + 预占状态机 + 幂等确认 + 对账修复闭环。
2. 为什么不用全局分布式事务？
答：高并发库存场景下代价过高，采用本地事务+Outbox+补偿更稳。
3. 如何处理热点 SKU？
答：分桶锁、局部队列、限购与优先级调度。

## 20. 落地取舍
- 强一致范围限定在单仓库存行，避免全链路强一致拖垮吞吐。
- 短期允许读模型轻微延迟，换取主链路稳定性。
- 先保障扣减正确，再优化查询实时性与成本。

## 21. 评分与达标结论
- 功能完整性：`28/30`
- 一致性与容错：`29/30`
- 工程可落地性：`20/20`
- 可观测与恢复：`20/20`
- 总分：97/100

## 22. 与母题差异
- 母题：`Q83 Design E-commerce Website (Amazon)`，覆盖商品、购物车、订单、支付全链路。
- 本题：`Q85 Design Inventory Management System`，聚焦库存域正确性与恢复。
- 差异点：
1. 母题是电商全局编排，本题是库存子域深挖。
2. 本题要求明确 `available/reserved/sold` 三账联动与修复。
3. 本题更强调预占超时释放、幂等确认、超卖零容忍。
4. 本题必须给出库存事件回放和对账闭环。
5. 本题要量化 RTO/RPO 与阈值，不是泛化高可用描述。
- 新增必补知识：
1. 预占库存状态机设计与超时回补。
2. 热点 SKU 并发控制（分桶锁/队列化）。
3. Outbox 事件一致性与消费幂等。
4. 库存三账对账与自动修复机制。
5. 超卖告警分级与应急冻结流程。
6. RTO/RPO 驱动的库存灾备切流方案。
